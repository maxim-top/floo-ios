/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 3.0.9
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigMovePointer {
    T *ptr;
    SwigMovePointer(T *p) : ptr(p) { }
    ~SwigMovePointer() { delete ptr; }
    SwigMovePointer& operator=(SwigMovePointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigMovePointer tmp(new T(t)); pointer = tmp; return *this; }
  operator T&() const { return *pointer.ptr; }
  T *operator&() { return pointer.ptr; }
};

template <typename T> T SwigValueInit() {
  return T();
}
#endif

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__))
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__))
# else
#   define SWIGUNUSED
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if defined(__GNUC__)
#  if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#    ifndef GCC_HASCLASSVISIBILITY
#      define GCC_HASCLASSVISIBILITY
#    endif
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif

/* Deal with Apple's deprecated 'AssertMacros.h' from Carbon-framework */
#if defined(__APPLE__) && !defined(__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES)
# define __ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES 0
#endif

/* Intel's compiler complains if a variable which was never initialised is
 * cast to void, which is a common idiom which we use to indicate that we
 * are aware a variable isn't used.  So we just silence that warning.
 * See: https://github.com/swig/swig/issues/192 for more discussion.
 */
#ifdef __INTEL_COMPILER
# pragma warning disable 592
#endif


#import <Foundation/Foundation.h>
#include <stdlib.h>
#include <string.h>


/* Contract support */

#define SWIG_contract_assert(nullreturn, expr, msg) if (!(expr)) { /*throw exception*/ return nullreturn; } else


/* Support for throwing Objc exceptions */
typedef enum {
  SWIG_ObjcOutOfMemoryError = 1, 
  SWIG_ObjcIOException, 
  SWIG_ObjcRuntimeException, 
  SWIG_ObjcIndexOutOfBoundsException,
  SWIG_ObjcArithmeticException,
  SWIG_ObjcIllegalArgumentException,
  SWIG_ObjcNullPointerException,
  SWIG_ObjcDirectorPureVirtual,
  SWIG_ObjcUnknownError
} SWIG_ObjcExceptionCodes;

typedef struct {
  SWIG_ObjcExceptionCodes code;
  const char *Objc_exception;
} SWIG_ObjcExceptions_t;


static void SWIGUNUSED SWIG_ObjcThrowException(SWIG_ObjcExceptionCodes code, const char *msg) {
  static const SWIG_ObjcExceptions_t Objc_exceptions[] = {
    { SWIG_ObjcOutOfMemoryError, "OutOfMemoryError" },
    { SWIG_ObjcIOException, "IOException" },
    { SWIG_ObjcRuntimeException, "RuntimeException" },
    { SWIG_ObjcIndexOutOfBoundsException, "IndexOutOfBoundsException" },
    { SWIG_ObjcArithmeticException, "ArithmeticException" },
    { SWIG_ObjcIllegalArgumentException, "IllegalArgumentException" },
    { SWIG_ObjcNullPointerException, "NullPointerException" },
    { SWIG_ObjcDirectorPureVirtual, "RuntimeException" },
    { SWIG_ObjcUnknownError,  "UnknownError" },
    { (SWIG_ObjcExceptionCodes)0,  "UnknownError" }
  };
  const SWIG_ObjcExceptions_t *except_ptr = Objc_exceptions;
  while (except_ptr->code != code && except_ptr->code)
   except_ptr++;
}

#include "floo_wrap.h"

#include "bmx_error.h"
#include "bmx_defines.h"
#include "bmx_device.h"
#include "bmx_base_object.h"
#include "structs4swig.h"
#include "bmx_message_attachment.h"
#include "bmx_message_config.h"
#include "bmx_message.h"
#include "bmx_conversation.h"
#include "bmx_sdk_config.h"
#include "bmx_network_listener.h"
#include "bmx_chat_service.h"
#include "bmx_chat_service_listener.h"
#include "bmx_push_service.h"
#include "bmx_push_service_listener.h"
#include "bmx_client.h"
#include "bmx_file_attachment.h"
#include "bmx_group.h"
#include "bmx_group_service.h"
#include "bmx_image_attachment.h"
#include "bmx_location_attachment.h"
#include "bmx_result_page.h"
#include "bmx_roster_item.h"
#include "bmx_roster_service.h"
#include "bmx_roster_service_listener.h"
#include "bmx_user_profile.h"
#include "bmx_user_service.h"
#include "bmx_user_service_listener.h"
#include "bmx_video_attachment.h"
#include "bmx_voice_attachment.h"
#include "bmx_group_service_listener.h"
#include "bmx_rtc_defines.h"
#include "bmx_rtc_config.h"
#include "bmx_rtc_engine.h"
#include "bmx_rtc_engine_listener.h"
#include "bmx_rtc_room.h"
#include "bmx_rtc_service.h"
#include "bmx_rtc_service_listener.h"
#include "bmx_rtc_session.h"
#include "bmx_rtc_signal_service.h"
#include "bmx_rtc_signal_service_listener.h"
#include <utility>


#include <stdint.h>		// Use the C99 official header


#include <stdexcept>


#include <vector>
#include <stdexcept>


#include <string>
using namespace floo;

const char* getStdString (NSString *aStr) {
    id value = aStr;
    if (value == [NSNull null] || aStr == nil) {
        aStr = @"";
    }
    return [aStr UTF8String];
}

SWIGINTERN std::vector< std::shared_ptr< floo::BMXMessage > >::const_reference std_vector_Sl_std_shared_ptr_Sl_floo_BMXMessage_Sg__Sg__get(std::vector< std::shared_ptr< floo::BMXMessage > > *self,int i){
                int size = int(self->size());
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_std_shared_ptr_Sl_floo_BMXMessage_Sg__Sg__set(std::vector< std::shared_ptr< floo::BMXMessage > > *self,int i,std::vector< std::shared_ptr< floo::BMXMessage > >::value_type const &val){
                int size = int(self->size());
                if (i>=0 && i<size)
                    (*self)[i] = val;
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN std::vector< std::string >::const_reference std_vector_Sl_std_string_Sg__get(std::vector< std::string > *self,int i){
                int size = int(self->size());
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_std_string_Sg__set(std::vector< std::string > *self,int i,std::vector< std::string >::value_type const &val){
                int size = int(self->size());
                if (i>=0 && i<size)
                    (*self)[i] = val;
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN std::vector< std::shared_ptr< floo::BMXConversation > >::const_reference std_vector_Sl_std_shared_ptr_Sl_floo_BMXConversation_Sg__Sg__get(std::vector< std::shared_ptr< floo::BMXConversation > > *self,int i){
                int size = int(self->size());
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_std_shared_ptr_Sl_floo_BMXConversation_Sg__Sg__set(std::vector< std::shared_ptr< floo::BMXConversation > > *self,int i,std::vector< std::shared_ptr< floo::BMXConversation > >::value_type const &val){
                int size = int(self->size());
                if (i>=0 && i<size)
                    (*self)[i] = val;
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN std::vector< std::shared_ptr< floo::BMXDevice > >::const_reference std_vector_Sl_std_shared_ptr_Sl_floo_BMXDevice_Sg__Sg__get(std::vector< std::shared_ptr< floo::BMXDevice > > *self,int i){
                int size = int(self->size());
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_std_shared_ptr_Sl_floo_BMXDevice_Sg__Sg__set(std::vector< std::shared_ptr< floo::BMXDevice > > *self,int i,std::vector< std::shared_ptr< floo::BMXDevice > >::value_type const &val){
                int size = int(self->size());
                if (i>=0 && i<size)
                    (*self)[i] = val;
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN std::vector< std::shared_ptr< floo::BMXGroup > >::const_reference std_vector_Sl_std_shared_ptr_Sl_floo_BMXGroup_Sg__Sg__get(std::vector< std::shared_ptr< floo::BMXGroup > > *self,int i){
                int size = int(self->size());
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_std_shared_ptr_Sl_floo_BMXGroup_Sg__Sg__set(std::vector< std::shared_ptr< floo::BMXGroup > > *self,int i,std::vector< std::shared_ptr< floo::BMXGroup > >::value_type const &val){
                int size = int(self->size());
                if (i>=0 && i<size)
                    (*self)[i] = val;
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN std::vector< std::shared_ptr< floo::BMXGroup::Member > >::const_reference std_vector_Sl_std_shared_ptr_Sl_BMXGroupMember_Sg__Sg__get(std::vector< std::shared_ptr< floo::BMXGroup::Member > > *self,int i){
                int size = int(self->size());
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_std_shared_ptr_Sl_BMXGroupMember_Sg__Sg__set(std::vector< std::shared_ptr< floo::BMXGroup::Member > > *self,int i,std::vector< std::shared_ptr< floo::BMXGroup::Member > >::value_type const &val){
                int size = int(self->size());
                if (i>=0 && i<size)
                    (*self)[i] = val;
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > >::const_reference std_vector_Sl_std_shared_ptr_Sl_BMXGroupBannedMember_Sg__Sg__get(std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > > *self,int i){
                int size = int(self->size());
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_std_shared_ptr_Sl_BMXGroupBannedMember_Sg__Sg__set(std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > > *self,int i,std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > >::value_type const &val){
                int size = int(self->size());
                if (i>=0 && i<size)
                    (*self)[i] = val;
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > >::const_reference std_vector_Sl_std_shared_ptr_Sl_BMXGroupSharedFile_Sg__Sg__get(std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > > *self,int i){
                int size = int(self->size());
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_std_shared_ptr_Sl_BMXGroupSharedFile_Sg__Sg__set(std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > > *self,int i,std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > >::value_type const &val){
                int size = int(self->size());
                if (i>=0 && i<size)
                    (*self)[i] = val;
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN std::vector< std::shared_ptr< floo::BMXGroup::Announcement > >::const_reference std_vector_Sl_std_shared_ptr_Sl_BMXGroupAnnouncement_Sg__Sg__get(std::vector< std::shared_ptr< floo::BMXGroup::Announcement > > *self,int i){
                int size = int(self->size());
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_std_shared_ptr_Sl_BMXGroupAnnouncement_Sg__Sg__set(std::vector< std::shared_ptr< floo::BMXGroup::Announcement > > *self,int i,std::vector< std::shared_ptr< floo::BMXGroup::Announcement > >::value_type const &val){
                int size = int(self->size());
                if (i>=0 && i<size)
                    (*self)[i] = val;
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN std::vector< std::shared_ptr< floo::BMXRosterService::Application > >::const_reference std_vector_Sl_std_shared_ptr_Sl_BMXRosterServiceApplication_Sg__Sg__get(std::vector< std::shared_ptr< floo::BMXRosterService::Application > > *self,int i){
                int size = int(self->size());
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_std_shared_ptr_Sl_BMXRosterServiceApplication_Sg__Sg__set(std::vector< std::shared_ptr< floo::BMXRosterService::Application > > *self,int i,std::vector< std::shared_ptr< floo::BMXRosterService::Application > >::value_type const &val){
                int size = int(self->size());
                if (i>=0 && i<size)
                    (*self)[i] = val;
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN std::vector< std::shared_ptr< floo::BMXGroup::Application > >::const_reference std_vector_Sl_std_shared_ptr_Sl_BMXGroupApplication_Sg__Sg__get(std::vector< std::shared_ptr< floo::BMXGroup::Application > > *self,int i){
                int size = int(self->size());
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_std_shared_ptr_Sl_BMXGroupApplication_Sg__Sg__set(std::vector< std::shared_ptr< floo::BMXGroup::Application > > *self,int i,std::vector< std::shared_ptr< floo::BMXGroup::Application > >::value_type const &val){
                int size = int(self->size());
                if (i>=0 && i<size)
                    (*self)[i] = val;
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN std::vector< std::shared_ptr< floo::BMXGroup::Invitation > >::const_reference std_vector_Sl_std_shared_ptr_Sl_BMXGroupInvitation_Sg__Sg__get(std::vector< std::shared_ptr< floo::BMXGroup::Invitation > > *self,int i){
                int size = int(self->size());
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_std_shared_ptr_Sl_BMXGroupInvitation_Sg__Sg__set(std::vector< std::shared_ptr< floo::BMXGroup::Invitation > > *self,int i,std::vector< std::shared_ptr< floo::BMXGroup::Invitation > >::value_type const &val){
                int size = int(self->size());
                if (i>=0 && i<size)
                    (*self)[i] = val;
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN std::vector< long long >::const_reference std_vector_Sl_long_SS_long_Sg__get(std::vector< long long > *self,int i){
                int size = int(self->size());
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_long_SS_long_Sg__set(std::vector< long long > *self,int i,std::vector< long long >::value_type const &val){
                int size = int(self->size());
                if (i>=0 && i<size)
                    (*self)[i] = val;
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN floo::BMXFileAttachment *floo_BMXFileAttachment_dynamic_cast(floo::BMXMessageAttachment *attachment){
    return dynamic_cast<floo::BMXFileAttachment *>(attachment);
  }
SWIGINTERN floo::BMXImageAttachment *floo_BMXImageAttachment_dynamic_cast(floo::BMXMessageAttachment *attachment){
    return dynamic_cast<floo::BMXImageAttachment *>(attachment);
  }
SWIGINTERN floo::BMXLocationAttachment *floo_BMXLocationAttachment_dynamic_cast(floo::BMXMessageAttachment *attachment){
    return dynamic_cast<floo::BMXLocationAttachment *>(attachment);
  }
SWIGINTERN std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > >::const_reference std_vector_Sl_std_vector_Sl_std_shared_ptr_Sl_floo_BMXMessage_Sg__Sg__Sg__get(std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > > *self,int i){
                int size = int(self->size());
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_std_vector_Sl_std_shared_ptr_Sl_floo_BMXMessage_Sg__Sg__Sg__set(std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > > *self,int i,std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > >::value_type const &val){
                int size = int(self->size());
                if (i>=0 && i<size)
                    (*self)[i] = val;
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN std::vector< std::shared_ptr< floo::BMXRosterItem > >::const_reference std_vector_Sl_std_shared_ptr_Sl_floo_BMXRosterItem_Sg__Sg__get(std::vector< std::shared_ptr< floo::BMXRosterItem > > *self,int i){
                int size = int(self->size());
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_std_shared_ptr_Sl_floo_BMXRosterItem_Sg__Sg__set(std::vector< std::shared_ptr< floo::BMXRosterItem > > *self,int i,std::vector< std::shared_ptr< floo::BMXRosterItem > >::value_type const &val){
                int size = int(self->size());
                if (i>=0 && i<size)
                    (*self)[i] = val;
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN floo::BMXVideoAttachment *floo_BMXVideoAttachment_dynamic_cast(floo::BMXMessageAttachment *attachment){
    return dynamic_cast<floo::BMXVideoAttachment *>(attachment);
  }
SWIGINTERN floo::BMXVoiceAttachment *floo_BMXVoiceAttachment_dynamic_cast(floo::BMXMessageAttachment *attachment){
    return dynamic_cast<floo::BMXVoiceAttachment *>(attachment);
  }
SWIGINTERN std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > >::const_reference std_vector_Sl_std_shared_ptr_Sl_floo_BMXJanusStreamInfo_Sg__Sg__get(std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > > *self,int i){
                int size = int(self->size());
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_std_shared_ptr_Sl_floo_BMXJanusStreamInfo_Sg__Sg__set(std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > > *self,int i,std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > >::value_type const &val){
                int size = int(self->size());
                if (i>=0 && i<size)
                    (*self)[i] = val;
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN std::vector< std::shared_ptr< floo::BMXRoomParticipant > >::const_reference std_vector_Sl_std_shared_ptr_Sl_floo_BMXRoomParticipant_Sg__Sg__get(std::vector< std::shared_ptr< floo::BMXRoomParticipant > > *self,int i){
                int size = int(self->size());
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_std_shared_ptr_Sl_floo_BMXRoomParticipant_Sg__Sg__set(std::vector< std::shared_ptr< floo::BMXRoomParticipant > > *self,int i,std::vector< std::shared_ptr< floo::BMXRoomParticipant > >::value_type const &val){
                int size = int(self->size());
                if (i>=0 && i<size)
                    (*self)[i] = val;
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN std::vector< std::shared_ptr< floo::BMXJanusPublisher > >::const_reference std_vector_Sl_std_shared_ptr_Sl_floo_BMXJanusPublisher_Sg__Sg__get(std::vector< std::shared_ptr< floo::BMXJanusPublisher > > *self,int i){
                int size = int(self->size());
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_std_shared_ptr_Sl_floo_BMXJanusPublisher_Sg__Sg__set(std::vector< std::shared_ptr< floo::BMXJanusPublisher > > *self,int i,std::vector< std::shared_ptr< floo::BMXJanusPublisher > >::value_type const &val){
                int size = int(self->size());
                if (i>=0 && i<size)
                    (*self)[i] = val;
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN std::vector< std::shared_ptr< floo::BMXRTCRoom > >::const_reference std_vector_Sl_std_shared_ptr_Sl_floo_BMXRTCRoom_Sg__Sg__get(std::vector< std::shared_ptr< floo::BMXRTCRoom > > *self,int i){
                int size = int(self->size());
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_std_shared_ptr_Sl_floo_BMXRTCRoom_Sg__Sg__set(std::vector< std::shared_ptr< floo::BMXRTCRoom > > *self,int i,std::vector< std::shared_ptr< floo::BMXRTCRoom > >::value_type const &val){
                int size = int(self->size());
                if (i>=0 && i<size)
                    (*self)[i] = val;
                else
                    throw std::out_of_range("vector index out of range");
            }

#ifdef __cplusplus
extern "C" {
#endif


void* _wrap_new_BMXMessageList__SWIG_0() {
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXMessage > > *result = 0 ;
  
  result = (std::vector< std::shared_ptr< floo::BMXMessage > > *)new std::vector< std::shared_ptr< floo::BMXMessage > >();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_BMXMessageList__SWIG_1(unsigned long imarg1) {
  std::vector< std::shared_ptr< floo::BMXMessage > >::size_type arg1 ;
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXMessage > > *result = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXMessage > >::size_type)imarg1; 
  result = (std::vector< std::shared_ptr< floo::BMXMessage > > *)new std::vector< std::shared_ptr< floo::BMXMessage > >(arg1);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

unsigned long _wrap_BMXMessageList_size(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXMessage > > *arg1 = (std::vector< std::shared_ptr< floo::BMXMessage > > *) 0 ;
  unsigned long imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXMessage > >::size_type result;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXMessage > > *)imarg1; 
  result = ((std::vector< std::shared_ptr< floo::BMXMessage > > const *)arg1)->size();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

unsigned long _wrap_BMXMessageList_capacity(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXMessage > > *arg1 = (std::vector< std::shared_ptr< floo::BMXMessage > > *) 0 ;
  unsigned long imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXMessage > >::size_type result;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXMessage > > *)imarg1; 
  result = ((std::vector< std::shared_ptr< floo::BMXMessage > > const *)arg1)->capacity();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXMessageList_reserve(void* imarg1, unsigned long imarg2) {
  std::vector< std::shared_ptr< floo::BMXMessage > > *arg1 = (std::vector< std::shared_ptr< floo::BMXMessage > > *) 0 ;
  std::vector< std::shared_ptr< floo::BMXMessage > >::size_type arg2 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXMessage > > *)imarg1; 
  arg2 = (std::vector< std::shared_ptr< floo::BMXMessage > >::size_type)imarg2; 
  (arg1)->reserve(arg2);
}

BOOL _wrap_BMXMessageList_isEmpty(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXMessage > > *arg1 = (std::vector< std::shared_ptr< floo::BMXMessage > > *) 0 ;
  BOOL imresult = 0 ;
  bool result;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXMessage > > *)imarg1; 
  result = (bool)((std::vector< std::shared_ptr< floo::BMXMessage > > const *)arg1)->empty();
  imresult = (result)? YES:NO; 
  return imresult;
}

void _wrap_BMXMessageList_clear(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXMessage > > *arg1 = (std::vector< std::shared_ptr< floo::BMXMessage > > *) 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXMessage > > *)imarg1; 
  (arg1)->clear();
}

void _wrap_BMXMessageList_add(void* imarg1, void* imarg2) {
  std::vector< std::shared_ptr< floo::BMXMessage > > *arg1 = (std::vector< std::shared_ptr< floo::BMXMessage > > *) 0 ;
  std::vector< std::shared_ptr< floo::BMXMessage > >::value_type *arg2 = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXMessage > > *)imarg1; 
  arg2 = (std::vector< std::shared_ptr< floo::BMXMessage > >::value_type *)imarg2; 
  (arg1)->push_back((std::vector< std::shared_ptr< floo::BMXMessage > >::value_type const &)*arg2);
}

void* _wrap_BMXMessageList_get(void* imarg1, int imarg2) {
  std::vector< std::shared_ptr< floo::BMXMessage > > *arg1 = (std::vector< std::shared_ptr< floo::BMXMessage > > *) 0 ;
  int arg2 ;
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXMessage > >::value_type *result = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXMessage > > *)imarg1; 
  arg2 = (int)imarg2; 
  try {
    result = (std::vector< std::shared_ptr< floo::BMXMessage > >::value_type *) &std_vector_Sl_std_shared_ptr_Sl_floo_BMXMessage_Sg__Sg__get(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_ObjcThrowException(SWIG_ObjcIndexOutOfBoundsException, (&_e)->what());
    return 0;
  }
  BMXMessage2Void(*result)
  imresult = (void*)lresult;
  return imresult;
}

void _wrap_BMXMessageList_set(void* imarg1, int imarg2, void* imarg3) {
  std::vector< std::shared_ptr< floo::BMXMessage > > *arg1 = (std::vector< std::shared_ptr< floo::BMXMessage > > *) 0 ;
  int arg2 ;
  std::vector< std::shared_ptr< floo::BMXMessage > >::value_type *arg3 = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXMessage > > *)imarg1; 
  arg2 = (int)imarg2; 
  arg3 = (std::vector< std::shared_ptr< floo::BMXMessage > >::value_type *)imarg3; 
  try {
    std_vector_Sl_std_shared_ptr_Sl_floo_BMXMessage_Sg__Sg__set(arg1,arg2,(std::shared_ptr< floo::BMXMessage > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_ObjcThrowException(SWIG_ObjcIndexOutOfBoundsException, (&_e)->what());
    return ;
  }
  
}

void _wrap_delete_BMXMessageList(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXMessage > > *arg1 = (std::vector< std::shared_ptr< floo::BMXMessage > > *) 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXMessage > > *)imarg1; 
  delete arg1;
}

void* _wrap_new_TagList__SWIG_0() {
  void* imresult = 0 ;
  std::vector< std::string > *result = 0 ;
  
  result = (std::vector< std::string > *)new std::vector< std::string >();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_TagList__SWIG_1(unsigned long imarg1) {
  std::vector< std::string >::size_type arg1 ;
  void* imresult = 0 ;
  std::vector< std::string > *result = 0 ;
  
  arg1 = (std::vector< std::string >::size_type)imarg1; 
  result = (std::vector< std::string > *)new std::vector< std::string >(arg1);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

unsigned long _wrap_TagList_size(void* imarg1) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ;
  unsigned long imresult = 0 ;
  std::vector< std::string >::size_type result;
  
  arg1 = (std::vector< std::string > *)imarg1; 
  result = ((std::vector< std::string > const *)arg1)->size();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

unsigned long _wrap_TagList_capacity(void* imarg1) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ;
  unsigned long imresult = 0 ;
  std::vector< std::string >::size_type result;
  
  arg1 = (std::vector< std::string > *)imarg1; 
  result = ((std::vector< std::string > const *)arg1)->capacity();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_TagList_reserve(void* imarg1, unsigned long imarg2) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ;
  std::vector< std::string >::size_type arg2 ;
  
  arg1 = (std::vector< std::string > *)imarg1; 
  arg2 = (std::vector< std::string >::size_type)imarg2; 
  (arg1)->reserve(arg2);
}

BOOL _wrap_TagList_isEmpty(void* imarg1) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ;
  BOOL imresult = 0 ;
  bool result;
  
  arg1 = (std::vector< std::string > *)imarg1; 
  result = (bool)((std::vector< std::string > const *)arg1)->empty();
  imresult = (result)? YES:NO; 
  return imresult;
}

void _wrap_TagList_clear(void* imarg1) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ;
  
  arg1 = (std::vector< std::string > *)imarg1; 
  (arg1)->clear();
}

void _wrap_TagList_add(void* imarg1, NSString* imarg2) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ;
  std::vector< std::string >::value_type *arg2 = 0 ;
  
  arg1 = (std::vector< std::string > *)imarg1; 
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  (arg1)->push_back((std::vector< std::string >::value_type const &)*arg2);
}

NSString* _wrap_TagList_get(void* imarg1, int imarg2) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ;
  int arg2 ;
  NSString* imresult = 0 ;
  std::vector< std::string >::value_type *result = 0 ;
  
  arg1 = (std::vector< std::string > *)imarg1; 
  arg2 = (int)imarg2; 
  try {
    result = (std::vector< std::string >::value_type *) &std_vector_Sl_std_string_Sg__get(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_ObjcThrowException(SWIG_ObjcIndexOutOfBoundsException, (&_e)->what());
    return 0;
  }
  
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_TagList_set(void* imarg1, int imarg2, NSString* imarg3) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ;
  int arg2 ;
  std::vector< std::string >::value_type *arg3 = 0 ;
  
  arg1 = (std::vector< std::string > *)imarg1; 
  arg2 = (int)imarg2; 
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str; 
  
  try {
    std_vector_Sl_std_string_Sg__set(arg1,arg2,(std::string const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_ObjcThrowException(SWIG_ObjcIndexOutOfBoundsException, (&_e)->what());
    return ;
  }
  
}

void _wrap_delete_TagList(void* imarg1) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ;
  
  arg1 = (std::vector< std::string > *)imarg1; 
  delete arg1;
}

void* _wrap_new_BMXConversationList__SWIG_0() {
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXConversation > > *result = 0 ;
  
  result = (std::vector< std::shared_ptr< floo::BMXConversation > > *)new std::vector< std::shared_ptr< floo::BMXConversation > >();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_BMXConversationList__SWIG_1(unsigned long imarg1) {
  std::vector< std::shared_ptr< floo::BMXConversation > >::size_type arg1 ;
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXConversation > > *result = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXConversation > >::size_type)imarg1; 
  result = (std::vector< std::shared_ptr< floo::BMXConversation > > *)new std::vector< std::shared_ptr< floo::BMXConversation > >(arg1);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

unsigned long _wrap_BMXConversationList_size(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXConversation > > *arg1 = (std::vector< std::shared_ptr< floo::BMXConversation > > *) 0 ;
  unsigned long imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXConversation > >::size_type result;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXConversation > > *)imarg1; 
  result = ((std::vector< std::shared_ptr< floo::BMXConversation > > const *)arg1)->size();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

unsigned long _wrap_BMXConversationList_capacity(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXConversation > > *arg1 = (std::vector< std::shared_ptr< floo::BMXConversation > > *) 0 ;
  unsigned long imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXConversation > >::size_type result;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXConversation > > *)imarg1; 
  result = ((std::vector< std::shared_ptr< floo::BMXConversation > > const *)arg1)->capacity();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXConversationList_reserve(void* imarg1, unsigned long imarg2) {
  std::vector< std::shared_ptr< floo::BMXConversation > > *arg1 = (std::vector< std::shared_ptr< floo::BMXConversation > > *) 0 ;
  std::vector< std::shared_ptr< floo::BMXConversation > >::size_type arg2 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXConversation > > *)imarg1; 
  arg2 = (std::vector< std::shared_ptr< floo::BMXConversation > >::size_type)imarg2; 
  (arg1)->reserve(arg2);
}

BOOL _wrap_BMXConversationList_isEmpty(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXConversation > > *arg1 = (std::vector< std::shared_ptr< floo::BMXConversation > > *) 0 ;
  BOOL imresult = 0 ;
  bool result;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXConversation > > *)imarg1; 
  result = (bool)((std::vector< std::shared_ptr< floo::BMXConversation > > const *)arg1)->empty();
  imresult = (result)? YES:NO; 
  return imresult;
}

void _wrap_BMXConversationList_clear(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXConversation > > *arg1 = (std::vector< std::shared_ptr< floo::BMXConversation > > *) 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXConversation > > *)imarg1; 
  (arg1)->clear();
}

void _wrap_BMXConversationList_add(void* imarg1, void* imarg2) {
  std::vector< std::shared_ptr< floo::BMXConversation > > *arg1 = (std::vector< std::shared_ptr< floo::BMXConversation > > *) 0 ;
  std::vector< std::shared_ptr< floo::BMXConversation > >::value_type *arg2 = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXConversation > > *)imarg1; 
  arg2 = (std::vector< std::shared_ptr< floo::BMXConversation > >::value_type *)imarg2; 
  (arg1)->push_back((std::vector< std::shared_ptr< floo::BMXConversation > >::value_type const &)*arg2);
}

void* _wrap_BMXConversationList_get(void* imarg1, int imarg2) {
  std::vector< std::shared_ptr< floo::BMXConversation > > *arg1 = (std::vector< std::shared_ptr< floo::BMXConversation > > *) 0 ;
  int arg2 ;
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXConversation > >::value_type *result = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXConversation > > *)imarg1; 
  arg2 = (int)imarg2; 
  try {
    result = (std::vector< std::shared_ptr< floo::BMXConversation > >::value_type *) &std_vector_Sl_std_shared_ptr_Sl_floo_BMXConversation_Sg__Sg__get(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_ObjcThrowException(SWIG_ObjcIndexOutOfBoundsException, (&_e)->what());
    return 0;
  }
  
  BMXConversation2Void(*result)
  imresult = (void*)lresult;
  return imresult;
}

void _wrap_BMXConversationList_set(void* imarg1, int imarg2, void* imarg3) {
  std::vector< std::shared_ptr< floo::BMXConversation > > *arg1 = (std::vector< std::shared_ptr< floo::BMXConversation > > *) 0 ;
  int arg2 ;
  std::vector< std::shared_ptr< floo::BMXConversation > >::value_type *arg3 = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXConversation > > *)imarg1; 
  arg2 = (int)imarg2; 
  arg3 = (std::vector< std::shared_ptr< floo::BMXConversation > >::value_type *)imarg3; 
  try {
    std_vector_Sl_std_shared_ptr_Sl_floo_BMXConversation_Sg__Sg__set(arg1,arg2,(std::shared_ptr< floo::BMXConversation > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_ObjcThrowException(SWIG_ObjcIndexOutOfBoundsException, (&_e)->what());
    return ;
  }
  
}

void _wrap_delete_BMXConversationList(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXConversation > > *arg1 = (std::vector< std::shared_ptr< floo::BMXConversation > > *) 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXConversation > > *)imarg1; 
  delete arg1;
}

void* _wrap_new_BMXDeviceList__SWIG_0() {
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXDevice > > *result = 0 ;
  
  result = (std::vector< std::shared_ptr< floo::BMXDevice > > *)new std::vector< std::shared_ptr< floo::BMXDevice > >();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_BMXDeviceList__SWIG_1(unsigned long imarg1) {
  std::vector< std::shared_ptr< floo::BMXDevice > >::size_type arg1 ;
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXDevice > > *result = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXDevice > >::size_type)imarg1; 
  result = (std::vector< std::shared_ptr< floo::BMXDevice > > *)new std::vector< std::shared_ptr< floo::BMXDevice > >(arg1);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

unsigned long _wrap_BMXDeviceList_size(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXDevice > > *arg1 = (std::vector< std::shared_ptr< floo::BMXDevice > > *) 0 ;
  unsigned long imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXDevice > >::size_type result;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXDevice > > *)imarg1; 
  result = ((std::vector< std::shared_ptr< floo::BMXDevice > > const *)arg1)->size();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

unsigned long _wrap_BMXDeviceList_capacity(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXDevice > > *arg1 = (std::vector< std::shared_ptr< floo::BMXDevice > > *) 0 ;
  unsigned long imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXDevice > >::size_type result;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXDevice > > *)imarg1; 
  result = ((std::vector< std::shared_ptr< floo::BMXDevice > > const *)arg1)->capacity();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXDeviceList_reserve(void* imarg1, unsigned long imarg2) {
  std::vector< std::shared_ptr< floo::BMXDevice > > *arg1 = (std::vector< std::shared_ptr< floo::BMXDevice > > *) 0 ;
  std::vector< std::shared_ptr< floo::BMXDevice > >::size_type arg2 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXDevice > > *)imarg1; 
  arg2 = (std::vector< std::shared_ptr< floo::BMXDevice > >::size_type)imarg2; 
  (arg1)->reserve(arg2);
}

BOOL _wrap_BMXDeviceList_isEmpty(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXDevice > > *arg1 = (std::vector< std::shared_ptr< floo::BMXDevice > > *) 0 ;
  BOOL imresult = 0 ;
  bool result;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXDevice > > *)imarg1; 
  result = (bool)((std::vector< std::shared_ptr< floo::BMXDevice > > const *)arg1)->empty();
  imresult = (result)? YES:NO; 
  return imresult;
}

void _wrap_BMXDeviceList_clear(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXDevice > > *arg1 = (std::vector< std::shared_ptr< floo::BMXDevice > > *) 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXDevice > > *)imarg1; 
  (arg1)->clear();
}

void _wrap_BMXDeviceList_add(void* imarg1, void* imarg2) {
  std::vector< std::shared_ptr< floo::BMXDevice > > *arg1 = (std::vector< std::shared_ptr< floo::BMXDevice > > *) 0 ;
  std::vector< std::shared_ptr< floo::BMXDevice > >::value_type *arg2 = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXDevice > > *)imarg1; 
  arg2 = (std::vector< std::shared_ptr< floo::BMXDevice > >::value_type *)imarg2; 
  (arg1)->push_back((std::vector< std::shared_ptr< floo::BMXDevice > >::value_type const &)*arg2);
}

void* _wrap_BMXDeviceList_get(void* imarg1, int imarg2) {
  std::vector< std::shared_ptr< floo::BMXDevice > > *arg1 = (std::vector< std::shared_ptr< floo::BMXDevice > > *) 0 ;
  int arg2 ;
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXDevice > >::value_type *result = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXDevice > > *)imarg1; 
  arg2 = (int)imarg2; 
  try {
    result = (std::vector< std::shared_ptr< floo::BMXDevice > >::value_type *) &std_vector_Sl_std_shared_ptr_Sl_floo_BMXDevice_Sg__Sg__get(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_ObjcThrowException(SWIG_ObjcIndexOutOfBoundsException, (&_e)->what());
    return 0;
  }
  BMXDevice2Void(*result)
  imresult = (void*)lresult;
  return imresult;
}

void _wrap_BMXDeviceList_set(void* imarg1, int imarg2, void* imarg3) {
  std::vector< std::shared_ptr< floo::BMXDevice > > *arg1 = (std::vector< std::shared_ptr< floo::BMXDevice > > *) 0 ;
  int arg2 ;
  std::vector< std::shared_ptr< floo::BMXDevice > >::value_type *arg3 = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXDevice > > *)imarg1; 
  arg2 = (int)imarg2; 
  arg3 = (std::vector< std::shared_ptr< floo::BMXDevice > >::value_type *)imarg3; 
  try {
    std_vector_Sl_std_shared_ptr_Sl_floo_BMXDevice_Sg__Sg__set(arg1,arg2,(std::shared_ptr< floo::BMXDevice > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_ObjcThrowException(SWIG_ObjcIndexOutOfBoundsException, (&_e)->what());
    return ;
  }
  
}

void _wrap_delete_BMXDeviceList(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXDevice > > *arg1 = (std::vector< std::shared_ptr< floo::BMXDevice > > *) 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXDevice > > *)imarg1; 
  delete arg1;
}

void* _wrap_new_BMXGroupList__SWIG_0() {
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup > > *result = 0 ;
  
  result = (std::vector< std::shared_ptr< floo::BMXGroup > > *)new std::vector< std::shared_ptr< floo::BMXGroup > >();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_BMXGroupList__SWIG_1(unsigned long imarg1) {
  std::vector< std::shared_ptr< floo::BMXGroup > >::size_type arg1 ;
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup > > *result = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup > >::size_type)imarg1; 
  result = (std::vector< std::shared_ptr< floo::BMXGroup > > *)new std::vector< std::shared_ptr< floo::BMXGroup > >(arg1);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

unsigned long _wrap_BMXGroupList_size(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXGroup > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup > > *) 0 ;
  unsigned long imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup > >::size_type result;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup > > *)imarg1; 
  result = ((std::vector< std::shared_ptr< floo::BMXGroup > > const *)arg1)->size();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

unsigned long _wrap_BMXGroupList_capacity(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXGroup > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup > > *) 0 ;
  unsigned long imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup > >::size_type result;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup > > *)imarg1; 
  result = ((std::vector< std::shared_ptr< floo::BMXGroup > > const *)arg1)->capacity();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXGroupList_reserve(void* imarg1, unsigned long imarg2) {
  std::vector< std::shared_ptr< floo::BMXGroup > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup > > *) 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup > >::size_type arg2 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup > > *)imarg1; 
  arg2 = (std::vector< std::shared_ptr< floo::BMXGroup > >::size_type)imarg2; 
  (arg1)->reserve(arg2);
}

BOOL _wrap_BMXGroupList_isEmpty(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXGroup > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup > > *) 0 ;
  BOOL imresult = 0 ;
  bool result;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup > > *)imarg1; 
  result = (bool)((std::vector< std::shared_ptr< floo::BMXGroup > > const *)arg1)->empty();
  imresult = (result)? YES:NO; 
  return imresult;
}

void _wrap_BMXGroupList_clear(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXGroup > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup > > *) 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup > > *)imarg1; 
  (arg1)->clear();
}

void _wrap_BMXGroupList_add(void* imarg1, void* imarg2) {
  std::vector< std::shared_ptr< floo::BMXGroup > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup > > *) 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup > >::value_type *arg2 = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup > > *)imarg1; 
  arg2 = (std::vector< std::shared_ptr< floo::BMXGroup > >::value_type *)imarg2; 
  (arg1)->push_back((std::vector< std::shared_ptr< floo::BMXGroup > >::value_type const &)*arg2);
}

void* _wrap_BMXGroupList_get(void* imarg1, int imarg2) {
  std::vector< std::shared_ptr< floo::BMXGroup > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup > > *) 0 ;
  int arg2 ;
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup > >::value_type *result = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup > > *)imarg1; 
  arg2 = (int)imarg2; 
  try {
    result = (std::vector< std::shared_ptr< floo::BMXGroup > >::value_type *) &std_vector_Sl_std_shared_ptr_Sl_floo_BMXGroup_Sg__Sg__get(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_ObjcThrowException(SWIG_ObjcIndexOutOfBoundsException, (&_e)->what());
    return 0;
  }
  BMXGroup2Void(*result)
  imresult = (void*)lresult;
  return imresult;
}

void _wrap_BMXGroupList_set(void* imarg1, int imarg2, void* imarg3) {
  std::vector< std::shared_ptr< floo::BMXGroup > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup > > *) 0 ;
  int arg2 ;
  std::vector< std::shared_ptr< floo::BMXGroup > >::value_type *arg3 = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup > > *)imarg1; 
  arg2 = (int)imarg2; 
  arg3 = (std::vector< std::shared_ptr< floo::BMXGroup > >::value_type *)imarg3; 
  try {
    std_vector_Sl_std_shared_ptr_Sl_floo_BMXGroup_Sg__Sg__set(arg1,arg2,(std::shared_ptr< floo::BMXGroup > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_ObjcThrowException(SWIG_ObjcIndexOutOfBoundsException, (&_e)->what());
    return ;
  }
  
}

void _wrap_delete_BMXGroupList(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXGroup > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup > > *) 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup > > *)imarg1; 
  delete arg1;
}

void* _wrap_new_BMXGroupMemberList__SWIG_0() {
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup::Member > > *result = 0 ;
  
  result = (std::vector< std::shared_ptr< floo::BMXGroup::Member > > *)new std::vector< std::shared_ptr< floo::BMXGroup::Member > >();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_BMXGroupMemberList__SWIG_1(unsigned long imarg1) {
  std::vector< std::shared_ptr< floo::BMXGroup::Member > >::size_type arg1 ;
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup::Member > > *result = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Member > >::size_type)imarg1;
  result = (std::vector< std::shared_ptr< floo::BMXGroup::Member > > *)new std::vector< std::shared_ptr< floo::BMXGroup::Member > >(arg1);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

unsigned long _wrap_BMXGroupMemberList_size(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXGroup::Member > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Member > > *) 0 ;
  unsigned long imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup::Member > >::size_type result;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Member > > *)imarg1;
  result = ((std::vector< std::shared_ptr< floo::BMXGroup::Member > > const *)arg1)->size();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

unsigned long _wrap_BMXGroupMemberList_capacity(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXGroup::Member > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Member > > *) 0 ;
  unsigned long imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup::Member > >::size_type result;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Member > > *)imarg1;
  result = ((std::vector< std::shared_ptr< floo::BMXGroup::Member > > const *)arg1)->capacity();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXGroupMemberList_reserve(void* imarg1, unsigned long imarg2) {
  std::vector< std::shared_ptr< floo::BMXGroup::Member > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Member > > *) 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup::Member > >::size_type arg2 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Member > > *)imarg1;
  arg2 = (std::vector< std::shared_ptr< floo::BMXGroup::Member > >::size_type)imarg2;
  (arg1)->reserve(arg2);
}

BOOL _wrap_BMXGroupMemberList_isEmpty(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXGroup::Member > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Member > > *) 0 ;
  BOOL imresult = 0 ;
  bool result;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Member > > *)imarg1;
  result = (bool)((std::vector< std::shared_ptr< floo::BMXGroup::Member > > const *)arg1)->empty();
  imresult = (result)? YES:NO; 
  return imresult;
}

void _wrap_BMXGroupMemberList_clear(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXGroup::Member > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Member > > *) 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Member > > *)imarg1;
  (arg1)->clear();
}

void _wrap_BMXGroupMemberList_add(void* imarg1, void* imarg2) {
  std::vector< std::shared_ptr< floo::BMXGroup::Member > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Member > > *) 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup::Member > >::value_type *arg2 = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Member > > *)imarg1;
  arg2 = (std::vector< std::shared_ptr< floo::BMXGroup::Member > >::value_type *)imarg2;
  (arg1)->push_back((std::vector< std::shared_ptr< floo::BMXGroup::Member > >::value_type const &)*arg2);
}

void* _wrap_BMXGroupMemberList_get(void* imarg1, int imarg2) {
  std::vector< std::shared_ptr< floo::BMXGroup::Member > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Member > > *) 0 ;
  int arg2 ;
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup::Member > >::value_type *result = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Member > > *)imarg1;
  arg2 = (int)imarg2; 
  try {
    result = (std::vector< std::shared_ptr< floo::BMXGroup::Member > >::value_type *) &std_vector_Sl_std_shared_ptr_Sl_BMXGroupMember_Sg__Sg__get(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_ObjcThrowException(SWIG_ObjcIndexOutOfBoundsException, (&_e)->what());
    return 0;
  }
  BMXGroupMember2Void(*result)
  imresult = (void*)lresult;
  return imresult;
}

void _wrap_BMXGroupMemberList_set(void* imarg1, int imarg2, void* imarg3) {
  std::vector< std::shared_ptr< floo::BMXGroup::Member > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Member > > *) 0 ;
  int arg2 ;
  std::vector< std::shared_ptr< floo::BMXGroup::Member > >::value_type *arg3 = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Member > > *)imarg1;
  arg2 = (int)imarg2; 
  arg3 = (std::vector< std::shared_ptr< floo::BMXGroup::Member > >::value_type *)imarg3;
  try {
    std_vector_Sl_std_shared_ptr_Sl_BMXGroupMember_Sg__Sg__set(arg1,arg2,(std::shared_ptr< floo::BMXGroup::Member > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_ObjcThrowException(SWIG_ObjcIndexOutOfBoundsException, (&_e)->what());
    return ;
  }
  
}

void _wrap_delete_BMXGroupMemberList(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXGroup::Member > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Member > > *) 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Member > > *)imarg1;
  delete arg1;
}

void* _wrap_new_BMXGroupBannedMemberList__SWIG_0() {
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > > *result = 0 ;
  
  result = (std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > > *)new std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > >();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_BMXGroupBannedMemberList__SWIG_1(unsigned long imarg1) {
  std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > >::size_type arg1 ;
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > > *result = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > >::size_type)imarg1; 
  result = (std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > > *)new std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > >(arg1);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

unsigned long _wrap_BMXGroupBannedMemberList_size(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > > *) 0 ;
  unsigned long imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > >::size_type result;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > > *)imarg1; 
  result = ((std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > > const *)arg1)->size();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

unsigned long _wrap_BMXGroupBannedMemberList_capacity(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > > *) 0 ;
  unsigned long imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > >::size_type result;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > > *)imarg1; 
  result = ((std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > > const *)arg1)->capacity();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXGroupBannedMemberList_reserve(void* imarg1, unsigned long imarg2) {
  std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > > *) 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > >::size_type arg2 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > > *)imarg1; 
  arg2 = (std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > >::size_type)imarg2; 
  (arg1)->reserve(arg2);
}

BOOL _wrap_BMXGroupBannedMemberList_isEmpty(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > > *) 0 ;
  BOOL imresult = 0 ;
  bool result;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > > *)imarg1; 
  result = (bool)((std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > > const *)arg1)->empty();
  imresult = (result)? YES:NO; 
  return imresult;
}

void _wrap_BMXGroupBannedMemberList_clear(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > > *) 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > > *)imarg1; 
  (arg1)->clear();
}

void _wrap_BMXGroupBannedMemberList_add(void* imarg1, void* imarg2) {
  std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > > *) 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > >::value_type *arg2 = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > > *)imarg1; 
  arg2 = (std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > >::value_type *)imarg2; 
  (arg1)->push_back((std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > >::value_type const &)*arg2);
}

void* _wrap_BMXGroupBannedMemberList_get(void* imarg1, int imarg2) {
  std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > > *) 0 ;
  int arg2 ;
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > >::value_type *result = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > > *)imarg1; 
  arg2 = (int)imarg2; 
  try {
    result = (std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > >::value_type *) &std_vector_Sl_std_shared_ptr_Sl_BMXGroupBannedMember_Sg__Sg__get(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_ObjcThrowException(SWIG_ObjcIndexOutOfBoundsException, (&_e)->what());
    return 0;
  }
  BMXGroupBannedMember2Void(*result)
  imresult = (void*)lresult;
  return imresult;
}

void _wrap_BMXGroupBannedMemberList_set(void* imarg1, int imarg2, void* imarg3) {
  std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > > *) 0 ;
  int arg2 ;
  std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > >::value_type *arg3 = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > > *)imarg1; 
  arg2 = (int)imarg2; 
  arg3 = (std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > >::value_type *)imarg3; 
  try {
    std_vector_Sl_std_shared_ptr_Sl_BMXGroupBannedMember_Sg__Sg__set(arg1,arg2,(std::shared_ptr< floo::BMXGroup::BannedMember > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_ObjcThrowException(SWIG_ObjcIndexOutOfBoundsException, (&_e)->what());
    return ;
  }
  
}

void _wrap_delete_BMXGroupBannedMemberList(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > > *) 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > > *)imarg1; 
  delete arg1;
}

void* _wrap_new_BMXGroupSharedFileList__SWIG_0() {
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > > *result = 0 ;
  
  result = (std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > > *)new std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > >();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_BMXGroupSharedFileList__SWIG_1(unsigned long imarg1) {
  std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > >::size_type arg1 ;
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > > *result = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > >::size_type)imarg1; 
  result = (std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > > *)new std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > >(arg1);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

unsigned long _wrap_BMXGroupSharedFileList_size(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > > *) 0 ;
  unsigned long imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > >::size_type result;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > > *)imarg1; 
  result = ((std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > > const *)arg1)->size();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

unsigned long _wrap_BMXGroupSharedFileList_capacity(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > > *) 0 ;
  unsigned long imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > >::size_type result;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > > *)imarg1; 
  result = ((std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > > const *)arg1)->capacity();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXGroupSharedFileList_reserve(void* imarg1, unsigned long imarg2) {
  std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > > *) 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > >::size_type arg2 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > > *)imarg1; 
  arg2 = (std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > >::size_type)imarg2; 
  (arg1)->reserve(arg2);
}

BOOL _wrap_BMXGroupSharedFileList_isEmpty(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > > *) 0 ;
  BOOL imresult = 0 ;
  bool result;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > > *)imarg1; 
  result = (bool)((std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > > const *)arg1)->empty();
  imresult = (result)? YES:NO; 
  return imresult;
}

void _wrap_BMXGroupSharedFileList_clear(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > > *) 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > > *)imarg1; 
  (arg1)->clear();
}

void _wrap_BMXGroupSharedFileList_add(void* imarg1, void* imarg2) {
  std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > > *) 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > >::value_type *arg2 = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > > *)imarg1; 
  arg2 = (std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > >::value_type *)imarg2; 
  (arg1)->push_back((std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > >::value_type const &)*arg2);
}

void* _wrap_BMXGroupSharedFileList_get(void* imarg1, int imarg2) {
  std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > > *) 0 ;
  int arg2 ;
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > >::value_type *result = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > > *)imarg1; 
  arg2 = (int)imarg2; 
  try {
    result = (std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > >::value_type *) &std_vector_Sl_std_shared_ptr_Sl_BMXGroupSharedFile_Sg__Sg__get(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_ObjcThrowException(SWIG_ObjcIndexOutOfBoundsException, (&_e)->what());
    return 0;
  }
  BMXGroupSharedFile2Void(*result)
  imresult = (void*)lresult;
  return imresult;
}

void _wrap_BMXGroupSharedFileList_set(void* imarg1, int imarg2, void* imarg3) {
  std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > > *) 0 ;
  int arg2 ;
  std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > >::value_type *arg3 = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > > *)imarg1; 
  arg2 = (int)imarg2; 
  arg3 = (std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > >::value_type *)imarg3; 
  try {
    std_vector_Sl_std_shared_ptr_Sl_BMXGroupSharedFile_Sg__Sg__set(arg1,arg2,(std::shared_ptr< floo::BMXGroup::SharedFile > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_ObjcThrowException(SWIG_ObjcIndexOutOfBoundsException, (&_e)->what());
    return ;
  }
  
}

void _wrap_delete_BMXGroupSharedFileList(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > > *) 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::SharedFile > > *)imarg1; 
  delete arg1;
}

void* _wrap_new_BMXGroupAnnouncementList__SWIG_0() {
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup::Announcement > > *result = 0 ;
  
  result = (std::vector< std::shared_ptr< floo::BMXGroup::Announcement > > *)new std::vector< std::shared_ptr< floo::BMXGroup::Announcement > >();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_BMXGroupAnnouncementList__SWIG_1(unsigned long imarg1) {
  std::vector< std::shared_ptr< floo::BMXGroup::Announcement > >::size_type arg1 ;
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup::Announcement > > *result = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Announcement > >::size_type)imarg1; 
  result = (std::vector< std::shared_ptr< floo::BMXGroup::Announcement > > *)new std::vector< std::shared_ptr< floo::BMXGroup::Announcement > >(arg1);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

unsigned long _wrap_BMXGroupAnnouncementList_size(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXGroup::Announcement > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Announcement > > *) 0 ;
  unsigned long imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup::Announcement > >::size_type result;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Announcement > > *)imarg1; 
  result = ((std::vector< std::shared_ptr< floo::BMXGroup::Announcement > > const *)arg1)->size();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

unsigned long _wrap_BMXGroupAnnouncementList_capacity(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXGroup::Announcement > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Announcement > > *) 0 ;
  unsigned long imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup::Announcement > >::size_type result;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Announcement > > *)imarg1; 
  result = ((std::vector< std::shared_ptr< floo::BMXGroup::Announcement > > const *)arg1)->capacity();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXGroupAnnouncementList_reserve(void* imarg1, unsigned long imarg2) {
  std::vector< std::shared_ptr< floo::BMXGroup::Announcement > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Announcement > > *) 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup::Announcement > >::size_type arg2 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Announcement > > *)imarg1; 
  arg2 = (std::vector< std::shared_ptr< floo::BMXGroup::Announcement > >::size_type)imarg2; 
  (arg1)->reserve(arg2);
}

BOOL _wrap_BMXGroupAnnouncementList_isEmpty(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXGroup::Announcement > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Announcement > > *) 0 ;
  BOOL imresult = 0 ;
  bool result;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Announcement > > *)imarg1; 
  result = (bool)((std::vector< std::shared_ptr< floo::BMXGroup::Announcement > > const *)arg1)->empty();
  imresult = (result)? YES:NO; 
  return imresult;
}

void _wrap_BMXGroupAnnouncementList_clear(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXGroup::Announcement > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Announcement > > *) 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Announcement > > *)imarg1; 
  (arg1)->clear();
}

void _wrap_BMXGroupAnnouncementList_add(void* imarg1, void* imarg2) {
  std::vector< std::shared_ptr< floo::BMXGroup::Announcement > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Announcement > > *) 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup::Announcement > >::value_type *arg2 = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Announcement > > *)imarg1; 
  arg2 = (std::vector< std::shared_ptr< floo::BMXGroup::Announcement > >::value_type *)imarg2; 
  (arg1)->push_back((std::vector< std::shared_ptr< floo::BMXGroup::Announcement > >::value_type const &)*arg2);
}

void* _wrap_BMXGroupAnnouncementList_get(void* imarg1, int imarg2) {
  std::vector< std::shared_ptr< floo::BMXGroup::Announcement > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Announcement > > *) 0 ;
  int arg2 ;
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup::Announcement > >::value_type *result = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Announcement > > *)imarg1; 
  arg2 = (int)imarg2; 
  try {
    result = (std::vector< std::shared_ptr< floo::BMXGroup::Announcement > >::value_type *) &std_vector_Sl_std_shared_ptr_Sl_BMXGroupAnnouncement_Sg__Sg__get(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_ObjcThrowException(SWIG_ObjcIndexOutOfBoundsException, (&_e)->what());
    return 0;
  }
  BMXGroupAnnouncement2Void(*result)
  imresult = (void*)lresult;

  return imresult;
}

void _wrap_BMXGroupAnnouncementList_set(void* imarg1, int imarg2, void* imarg3) {
  std::vector< std::shared_ptr< floo::BMXGroup::Announcement > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Announcement > > *) 0 ;
  int arg2 ;
  std::vector< std::shared_ptr< floo::BMXGroup::Announcement > >::value_type *arg3 = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Announcement > > *)imarg1; 
  arg2 = (int)imarg2; 
  arg3 = (std::vector< std::shared_ptr< floo::BMXGroup::Announcement > >::value_type *)imarg3; 
  try {
    std_vector_Sl_std_shared_ptr_Sl_BMXGroupAnnouncement_Sg__Sg__set(arg1,arg2,(std::shared_ptr< floo::BMXGroup::Announcement > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_ObjcThrowException(SWIG_ObjcIndexOutOfBoundsException, (&_e)->what());
    return ;
  }
  
}

void _wrap_delete_BMXGroupAnnouncementList(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXGroup::Announcement > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Announcement > > *) 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Announcement > > *)imarg1; 
  delete arg1;
}

void* _wrap_new_BMXRosterServiceApplicationList__SWIG_0() {
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXRosterService::Application > > *result = 0 ;
  
  result = (std::vector< std::shared_ptr< floo::BMXRosterService::Application > > *)new std::vector< std::shared_ptr< floo::BMXRosterService::Application > >();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_BMXRosterServiceApplicationList__SWIG_1(unsigned long imarg1) {
  std::vector< std::shared_ptr< floo::BMXRosterService::Application > >::size_type arg1 ;
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXRosterService::Application > > *result = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXRosterService::Application > >::size_type)imarg1; 
  result = (std::vector< std::shared_ptr< floo::BMXRosterService::Application > > *)new std::vector< std::shared_ptr< floo::BMXRosterService::Application > >(arg1);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

unsigned long _wrap_BMXRosterServiceApplicationList_size(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXRosterService::Application > > *arg1 = (std::vector< std::shared_ptr< floo::BMXRosterService::Application > > *) 0 ;
  unsigned long imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXRosterService::Application > >::size_type result;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXRosterService::Application > > *)imarg1; 
  result = ((std::vector< std::shared_ptr< floo::BMXRosterService::Application > > const *)arg1)->size();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

unsigned long _wrap_BMXRosterServiceApplicationList_capacity(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXRosterService::Application > > *arg1 = (std::vector< std::shared_ptr< floo::BMXRosterService::Application > > *) 0 ;
  unsigned long imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXRosterService::Application > >::size_type result;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXRosterService::Application > > *)imarg1; 
  result = ((std::vector< std::shared_ptr< floo::BMXRosterService::Application > > const *)arg1)->capacity();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXRosterServiceApplicationList_reserve(void* imarg1, unsigned long imarg2) {
  std::vector< std::shared_ptr< floo::BMXRosterService::Application > > *arg1 = (std::vector< std::shared_ptr< floo::BMXRosterService::Application > > *) 0 ;
  std::vector< std::shared_ptr< floo::BMXRosterService::Application > >::size_type arg2 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXRosterService::Application > > *)imarg1; 
  arg2 = (std::vector< std::shared_ptr< floo::BMXRosterService::Application > >::size_type)imarg2; 
  (arg1)->reserve(arg2);
}

BOOL _wrap_BMXRosterServiceApplicationList_isEmpty(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXRosterService::Application > > *arg1 = (std::vector< std::shared_ptr< floo::BMXRosterService::Application > > *) 0 ;
  BOOL imresult = 0 ;
  bool result;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXRosterService::Application > > *)imarg1; 
  result = (bool)((std::vector< std::shared_ptr< floo::BMXRosterService::Application > > const *)arg1)->empty();
  imresult = (result)? YES:NO; 
  return imresult;
}

void _wrap_BMXRosterServiceApplicationList_clear(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXRosterService::Application > > *arg1 = (std::vector< std::shared_ptr< floo::BMXRosterService::Application > > *) 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXRosterService::Application > > *)imarg1; 
  (arg1)->clear();
}

void _wrap_BMXRosterServiceApplicationList_add(void* imarg1, void* imarg2) {
  std::vector< std::shared_ptr< floo::BMXRosterService::Application > > *arg1 = (std::vector< std::shared_ptr< floo::BMXRosterService::Application > > *) 0 ;
  std::vector< std::shared_ptr< floo::BMXRosterService::Application > >::value_type *arg2 = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXRosterService::Application > > *)imarg1; 
  arg2 = (std::vector< std::shared_ptr< floo::BMXRosterService::Application > >::value_type *)imarg2; 
  (arg1)->push_back((std::vector< std::shared_ptr< floo::BMXRosterService::Application > >::value_type const &)*arg2);
}

void* _wrap_BMXRosterServiceApplicationList_get(void* imarg1, int imarg2) {
  std::vector< std::shared_ptr< floo::BMXRosterService::Application > > *arg1 = (std::vector< std::shared_ptr< floo::BMXRosterService::Application > > *) 0 ;
  int arg2 ;
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXRosterService::Application > >::value_type *result = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXRosterService::Application > > *)imarg1; 
  arg2 = (int)imarg2; 
  try {
    result = (std::vector< std::shared_ptr< floo::BMXRosterService::Application > >::value_type *) &std_vector_Sl_std_shared_ptr_Sl_BMXRosterServiceApplication_Sg__Sg__get(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_ObjcThrowException(SWIG_ObjcIndexOutOfBoundsException, (&_e)->what());
    return 0;
  }
  BMXRosterServiceApplication2Void(*result)
  imresult = (void*)lresult;
  return imresult;
}

void _wrap_BMXRosterServiceApplicationList_set(void* imarg1, int imarg2, void* imarg3) {
  std::vector< std::shared_ptr< floo::BMXRosterService::Application > > *arg1 = (std::vector< std::shared_ptr< floo::BMXRosterService::Application > > *) 0 ;
  int arg2 ;
  std::vector< std::shared_ptr< floo::BMXRosterService::Application > >::value_type *arg3 = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXRosterService::Application > > *)imarg1; 
  arg2 = (int)imarg2; 
  arg3 = (std::vector< std::shared_ptr< floo::BMXRosterService::Application > >::value_type *)imarg3; 
  try {
    std_vector_Sl_std_shared_ptr_Sl_BMXRosterServiceApplication_Sg__Sg__set(arg1,arg2,(std::shared_ptr< floo::BMXRosterService::Application > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_ObjcThrowException(SWIG_ObjcIndexOutOfBoundsException, (&_e)->what());
    return ;
  }
  
}

void _wrap_delete_BMXRosterServiceApplicationList(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXRosterService::Application > > *arg1 = (std::vector< std::shared_ptr< floo::BMXRosterService::Application > > *) 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXRosterService::Application > > *)imarg1; 
  delete arg1;
}

void* _wrap_new_BMXGroupApplicationList__SWIG_0() {
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup::Application > > *result = 0 ;
  
  result = (std::vector< std::shared_ptr< floo::BMXGroup::Application > > *)new std::vector< std::shared_ptr< floo::BMXGroup::Application > >();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_BMXGroupApplicationList__SWIG_1(unsigned long imarg1) {
  std::vector< std::shared_ptr< floo::BMXGroup::Application > >::size_type arg1 ;
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup::Application > > *result = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Application > >::size_type)imarg1; 
  result = (std::vector< std::shared_ptr< floo::BMXGroup::Application > > *)new std::vector< std::shared_ptr< floo::BMXGroup::Application > >(arg1);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

unsigned long _wrap_BMXGroupApplicationList_size(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXGroup::Application > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Application > > *) 0 ;
  unsigned long imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup::Application > >::size_type result;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Application > > *)imarg1; 
  result = ((std::vector< std::shared_ptr< floo::BMXGroup::Application > > const *)arg1)->size();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

unsigned long _wrap_BMXGroupApplicationList_capacity(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXGroup::Application > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Application > > *) 0 ;
  unsigned long imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup::Application > >::size_type result;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Application > > *)imarg1; 
  result = ((std::vector< std::shared_ptr< floo::BMXGroup::Application > > const *)arg1)->capacity();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXGroupApplicationList_reserve(void* imarg1, unsigned long imarg2) {
  std::vector< std::shared_ptr< floo::BMXGroup::Application > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Application > > *) 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup::Application > >::size_type arg2 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Application > > *)imarg1; 
  arg2 = (std::vector< std::shared_ptr< floo::BMXGroup::Application > >::size_type)imarg2; 
  (arg1)->reserve(arg2);
}

BOOL _wrap_BMXGroupApplicationList_isEmpty(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXGroup::Application > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Application > > *) 0 ;
  BOOL imresult = 0 ;
  bool result;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Application > > *)imarg1; 
  result = (bool)((std::vector< std::shared_ptr< floo::BMXGroup::Application > > const *)arg1)->empty();
  imresult = (result)? YES:NO; 
  return imresult;
}

void _wrap_BMXGroupApplicationList_clear(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXGroup::Application > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Application > > *) 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Application > > *)imarg1; 
  (arg1)->clear();
}

void _wrap_BMXGroupApplicationList_add(void* imarg1, void* imarg2) {
  std::vector< std::shared_ptr< floo::BMXGroup::Application > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Application > > *) 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup::Application > >::value_type *arg2 = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Application > > *)imarg1; 
  arg2 = (std::vector< std::shared_ptr< floo::BMXGroup::Application > >::value_type *)imarg2; 
  (arg1)->push_back((std::vector< std::shared_ptr< floo::BMXGroup::Application > >::value_type const &)*arg2);
}

void* _wrap_BMXGroupApplicationList_get(void* imarg1, int imarg2) {
  std::vector< std::shared_ptr< floo::BMXGroup::Application > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Application > > *) 0 ;
  int arg2 ;
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup::Application > >::value_type *result = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Application > > *)imarg1; 
  arg2 = (int)imarg2; 
  try {
    result = (std::vector< std::shared_ptr< floo::BMXGroup::Application > >::value_type *) &std_vector_Sl_std_shared_ptr_Sl_BMXGroupApplication_Sg__Sg__get(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_ObjcThrowException(SWIG_ObjcIndexOutOfBoundsException, (&_e)->what());
    return 0;
  }
  BMXGroupApplication2Void(*result)
  imresult = (void*)lresult;
  return imresult;
}

void _wrap_BMXGroupApplicationList_set(void* imarg1, int imarg2, void* imarg3) {
  std::vector< std::shared_ptr< floo::BMXGroup::Application > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Application > > *) 0 ;
  int arg2 ;
  std::vector< std::shared_ptr< floo::BMXGroup::Application > >::value_type *arg3 = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Application > > *)imarg1; 
  arg2 = (int)imarg2; 
  arg3 = (std::vector< std::shared_ptr< floo::BMXGroup::Application > >::value_type *)imarg3; 
  try {
    std_vector_Sl_std_shared_ptr_Sl_BMXGroupApplication_Sg__Sg__set(arg1,arg2,(std::shared_ptr< floo::BMXGroup::Application > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_ObjcThrowException(SWIG_ObjcIndexOutOfBoundsException, (&_e)->what());
    return ;
  }
  
}

void _wrap_delete_BMXGroupApplicationList(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXGroup::Application > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Application > > *) 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Application > > *)imarg1; 
  delete arg1;
}

void* _wrap_new_BMXGroupInvitationList__SWIG_0() {
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup::Invitation > > *result = 0 ;
  
  result = (std::vector< std::shared_ptr< floo::BMXGroup::Invitation > > *)new std::vector< std::shared_ptr< floo::BMXGroup::Invitation > >();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_BMXGroupInvitationList__SWIG_1(unsigned long imarg1) {
  std::vector< std::shared_ptr< floo::BMXGroup::Invitation > >::size_type arg1 ;
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup::Invitation > > *result = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Invitation > >::size_type)imarg1; 
  result = (std::vector< std::shared_ptr< floo::BMXGroup::Invitation > > *)new std::vector< std::shared_ptr< floo::BMXGroup::Invitation > >(arg1);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

unsigned long _wrap_BMXGroupInvitationList_size(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXGroup::Invitation > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Invitation > > *) 0 ;
  unsigned long imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup::Invitation > >::size_type result;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Invitation > > *)imarg1; 
  result = ((std::vector< std::shared_ptr< floo::BMXGroup::Invitation > > const *)arg1)->size();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

unsigned long _wrap_BMXGroupInvitationList_capacity(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXGroup::Invitation > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Invitation > > *) 0 ;
  unsigned long imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup::Invitation > >::size_type result;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Invitation > > *)imarg1; 
  result = ((std::vector< std::shared_ptr< floo::BMXGroup::Invitation > > const *)arg1)->capacity();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXGroupInvitationList_reserve(void* imarg1, unsigned long imarg2) {
  std::vector< std::shared_ptr< floo::BMXGroup::Invitation > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Invitation > > *) 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup::Invitation > >::size_type arg2 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Invitation > > *)imarg1; 
  arg2 = (std::vector< std::shared_ptr< floo::BMXGroup::Invitation > >::size_type)imarg2; 
  (arg1)->reserve(arg2);
}

BOOL _wrap_BMXGroupInvitationList_isEmpty(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXGroup::Invitation > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Invitation > > *) 0 ;
  BOOL imresult = 0 ;
  bool result;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Invitation > > *)imarg1; 
  result = (bool)((std::vector< std::shared_ptr< floo::BMXGroup::Invitation > > const *)arg1)->empty();
  imresult = (result)? YES:NO; 
  return imresult;
}

void _wrap_BMXGroupInvitationList_clear(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXGroup::Invitation > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Invitation > > *) 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Invitation > > *)imarg1; 
  (arg1)->clear();
}

void _wrap_BMXGroupInvitationList_add(void* imarg1, void* imarg2) {
  std::vector< std::shared_ptr< floo::BMXGroup::Invitation > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Invitation > > *) 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup::Invitation > >::value_type *arg2 = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Invitation > > *)imarg1; 
  arg2 = (std::vector< std::shared_ptr< floo::BMXGroup::Invitation > >::value_type *)imarg2; 
  (arg1)->push_back((std::vector< std::shared_ptr< floo::BMXGroup::Invitation > >::value_type const &)*arg2);
}

void* _wrap_BMXGroupInvitationList_get(void* imarg1, int imarg2) {
  std::vector< std::shared_ptr< floo::BMXGroup::Invitation > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Invitation > > *) 0 ;
  int arg2 ;
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup::Invitation > >::value_type *result = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Invitation > > *)imarg1; 
  arg2 = (int)imarg2; 
  try {
    result = (std::vector< std::shared_ptr< floo::BMXGroup::Invitation > >::value_type *) &std_vector_Sl_std_shared_ptr_Sl_BMXGroupInvitation_Sg__Sg__get(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_ObjcThrowException(SWIG_ObjcIndexOutOfBoundsException, (&_e)->what());
    return 0;
  }
  BMXGroupInvitation2Void(*result)
  imresult = (void*)lresult;
  return imresult;
}

void _wrap_BMXGroupInvitationList_set(void* imarg1, int imarg2, void* imarg3) {
  std::vector< std::shared_ptr< floo::BMXGroup::Invitation > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Invitation > > *) 0 ;
  int arg2 ;
  std::vector< std::shared_ptr< floo::BMXGroup::Invitation > >::value_type *arg3 = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Invitation > > *)imarg1; 
  arg2 = (int)imarg2; 
  arg3 = (std::vector< std::shared_ptr< floo::BMXGroup::Invitation > >::value_type *)imarg3; 
  try {
    std_vector_Sl_std_shared_ptr_Sl_BMXGroupInvitation_Sg__Sg__set(arg1,arg2,(std::shared_ptr< floo::BMXGroup::Invitation > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_ObjcThrowException(SWIG_ObjcIndexOutOfBoundsException, (&_e)->what());
    return ;
  }
  
}

void _wrap_delete_BMXGroupInvitationList(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXGroup::Invitation > > *arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Invitation > > *) 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Invitation > > *)imarg1; 
  delete arg1;
}

void* _wrap_new_ListOfLongLong__SWIG_0() {
  void* imresult = 0 ;
  std::vector< long long > *result = 0 ;
  
  result = (std::vector< long long > *)new std::vector< long long >();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_ListOfLongLong__SWIG_1(unsigned long imarg1) {
  std::vector< long long >::size_type arg1 ;
  void* imresult = 0 ;
  std::vector< long long > *result = 0 ;
  
  arg1 = (std::vector< long long >::size_type)imarg1; 
  result = (std::vector< long long > *)new std::vector< long long >(arg1);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

unsigned long _wrap_ListOfLongLong_size(void* imarg1) {
  std::vector< long long > *arg1 = (std::vector< long long > *) 0 ;
  unsigned long imresult = 0 ;
  std::vector< long long >::size_type result;
  
  arg1 = (std::vector< long long > *)imarg1; 
  result = ((std::vector< long long > const *)arg1)->size();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

unsigned long _wrap_ListOfLongLong_capacity(void* imarg1) {
  std::vector< long long > *arg1 = (std::vector< long long > *) 0 ;
  unsigned long imresult = 0 ;
  std::vector< long long >::size_type result;
  
  arg1 = (std::vector< long long > *)imarg1; 
  result = ((std::vector< long long > const *)arg1)->capacity();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_ListOfLongLong_reserve(void* imarg1, unsigned long imarg2) {
  std::vector< long long > *arg1 = (std::vector< long long > *) 0 ;
  std::vector< long long >::size_type arg2 ;
  
  arg1 = (std::vector< long long > *)imarg1; 
  arg2 = (std::vector< long long >::size_type)imarg2; 
  (arg1)->reserve(arg2);
}

BOOL _wrap_ListOfLongLong_isEmpty(void* imarg1) {
  std::vector< long long > *arg1 = (std::vector< long long > *) 0 ;
  BOOL imresult = 0 ;
  bool result;
  
  arg1 = (std::vector< long long > *)imarg1; 
  result = (bool)((std::vector< long long > const *)arg1)->empty();
  imresult = (result)? YES:NO; 
  return imresult;
}

void _wrap_ListOfLongLong_clear(void* imarg1) {
  std::vector< long long > *arg1 = (std::vector< long long > *) 0 ;
  
  arg1 = (std::vector< long long > *)imarg1; 
  (arg1)->clear();
}

void _wrap_ListOfLongLong_add(void* imarg1, long long * imarg2) {
  std::vector< long long > *arg1 = (std::vector< long long > *) 0 ;
  std::vector< long long >::value_type *arg2 = 0 ;
  
  arg1 = (std::vector< long long > *)imarg1; 
  arg2 = (std::vector< long long >::value_type *)imarg2; 
  (arg1)->push_back((std::vector< long long >::value_type const &)*arg2);
}

long long * _wrap_ListOfLongLong_get(void* imarg1, int imarg2) {
  std::vector< long long > *arg1 = (std::vector< long long > *) 0 ;
  int arg2 ;
  long long * imresult = 0 ;
  std::vector< long long >::value_type *result = 0 ;
  
  arg1 = (std::vector< long long > *)imarg1; 
  arg2 = (int)imarg2; 
  try {
    result = (std::vector< long long >::value_type *) &std_vector_Sl_long_SS_long_Sg__get(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_ObjcThrowException(SWIG_ObjcIndexOutOfBoundsException, (&_e)->what());
    return 0;
  }
  
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_ListOfLongLong_set(void* imarg1, int imarg2, long long * imarg3) {
  std::vector< long long > *arg1 = (std::vector< long long > *) 0 ;
  int arg2 ;
  std::vector< long long >::value_type *arg3 = 0 ;
  
  arg1 = (std::vector< long long > *)imarg1; 
  arg2 = (int)imarg2; 
  arg3 = (std::vector< long long >::value_type *)imarg3; 
  try {
    std_vector_Sl_long_SS_long_Sg__set(arg1,arg2,(long long const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_ObjcThrowException(SWIG_ObjcIndexOutOfBoundsException, (&_e)->what());
    return ;
  }
  
}

void _wrap_delete_ListOfLongLong(void* imarg1) {
  std::vector< long long > *arg1 = (std::vector< long long > *) 0 ;
  
  arg1 = (std::vector< long long > *)imarg1; 
  delete arg1;
}

NSString* _wrap_getErrorMessage(int imarg1) {
  floo::BMXErrorCode arg1 ;
  NSString* imresult = 0 ;
  std::string result;
  
  arg1 = (floo::BMXErrorCode)imarg1; 
  result = floo::getErrorMessage(arg1);
  imresult = [NSString stringWithUTF8String: (&result)->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void* _wrap_new_BMXError(int imarg1) {
  floo::BMXErrorCode arg1 ;
  void* imresult = 0 ;
  floo::BMXError *result = 0 ;
  
  arg1 = (floo::BMXErrorCode)imarg1; 
  result = (floo::BMXError *)new floo::BMXError(arg1);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_delete_BMXError(void* imarg1) {
  floo::BMXError *arg1 = (floo::BMXError *) 0 ;
  
  arg1 = (floo::BMXError *)imarg1; 
  delete arg1;
}

int _wrap_BMXError_errorCode(void* imarg1) {
  floo::BMXError *arg1 = (floo::BMXError *) 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXError *)imarg1; 
  result = (floo::BMXErrorCode)(arg1)->errorCode();
  imresult = (int)result; 
  return imresult;
}

NSString* _wrap_BMXError_description(void* imarg1) {
  floo::BMXError *arg1 = (floo::BMXError *) 0 ;
  NSString* imresult = 0 ;
  std::string result;
  
  arg1 = (floo::BMXError *)imarg1; 
  result = (arg1)->description();
  imresult = [NSString stringWithUTF8String: (&result)->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

int _wrap_CONNECT_MAX_RETRY_get() {
  int imresult = 0 ;
  int result;
  
  result = (int)(3);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_delete_BMXDevice(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXDevicePtr arg1 ;
  floo::BMXDevicePtr *argp1 = *(floo::BMXDevicePtr **)&larg1;
  delete argp1;
}

int _wrap_BMXDevice_deviceSN(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXDevicePtr arg1 ;
  floo::BMXDevicePtr *argp1 = *(floo::BMXDevicePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  int result;
  
  result = (int)(arg1)->deviceSN();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

long long _wrap_BMXDevice_userId(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXDevicePtr arg1 ;
  floo::BMXDevicePtr *argp1 = *(floo::BMXDevicePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  long long imresult = 0 ;
  int64_t result;
  
  result = (int64_t)(arg1)->userId();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

int _wrap_BMXDevice_platform(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXDevicePtr arg1 ;
  floo::BMXDevicePtr *argp1 = *(floo::BMXDevicePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  int result;
  
  result = (int)(arg1)->platform();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

NSString* _wrap_BMXDevice_userAgent(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXDevicePtr arg1 ;
  floo::BMXDevicePtr *argp1 = *(floo::BMXDevicePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string result;
  
  result = (arg1)->userAgent();
  imresult = [NSString stringWithUTF8String: (&result)->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXDevice_setUserAgent(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXDevicePtr arg1 ;
  floo::BMXDevicePtr *argp1 = *(floo::BMXDevicePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  (arg1)->setUserAgent((std::string const &)*arg2);
}

BOOL _wrap_BMXDevice_isCurrentDevice(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXDevicePtr arg1 ;
  floo::BMXDevicePtr *argp1 = *(floo::BMXDevicePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BOOL imresult = 0 ;
  bool result;
  
  result = (bool)(arg1)->isCurrentDevice();
  imresult = (result)? YES:NO; 
  return imresult;
}

void _wrap_delete_BMXBaseObject(void* imarg1) {
  floo::BMXBaseObject *arg1 = (floo::BMXBaseObject *) 0 ;
  
  arg1 = (floo::BMXBaseObject *)imarg1; 
  delete arg1;
}

void* _wrap_new_BMXBaseObject() {
  void* imresult = 0 ;
  floo::BMXBaseObject *result = 0 ;
  
  result = (floo::BMXBaseObject *)new floo::BMXBaseObject();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_BMXSDKConfigHostConfig__SWIG_0() {
  void* imresult = 0 ;
  BMXSDKConfigHostConfig *result = 0 ;
  
  result = (BMXSDKConfigHostConfig *)new BMXSDKConfigHostConfig();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_BMXSDKConfigHostConfig__SWIG_1(NSString* imarg1, int imarg2, NSString* imarg3) {
  std::string *arg1 = 0 ;
  int arg2 ;
  std::string *arg3 = 0 ;
  void* imresult = 0 ;
  BMXSDKConfigHostConfig *result = 0 ;
  
  if(!imarg1) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg1_str(getStdString(imarg1));
  arg1 = &arg1_str; 
  
  arg2 = (int)imarg2; 
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str; 
  
  result = (BMXSDKConfigHostConfig *)new BMXSDKConfigHostConfig((std::string const &)*arg1,arg2,(std::string const &)*arg3);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXSDKConfigHostConfig_imHost_set(void* imarg1, NSString* imarg2) {
  BMXSDKConfigHostConfig *arg1 = (BMXSDKConfigHostConfig *) 0 ;
  std::string *arg2 = 0 ;
  
  arg1 = (BMXSDKConfigHostConfig *)imarg1; 
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  if (arg1) (arg1)->imHost = *arg2;
}

NSString* _wrap_BMXSDKConfigHostConfig_imHost_get(void* imarg1) {
  BMXSDKConfigHostConfig *arg1 = (BMXSDKConfigHostConfig *) 0 ;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  arg1 = (BMXSDKConfigHostConfig *)imarg1; 
  result = (std::string *) & ((arg1)->imHost);
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXSDKConfigHostConfig_imPort_set(void* imarg1, int imarg2) {
  BMXSDKConfigHostConfig *arg1 = (BMXSDKConfigHostConfig *) 0 ;
  int arg2 ;
  
  arg1 = (BMXSDKConfigHostConfig *)imarg1; 
  arg2 = (int)imarg2; 
  if (arg1) (arg1)->imPort = arg2;
}

int _wrap_BMXSDKConfigHostConfig_imPort_get(void* imarg1) {
  BMXSDKConfigHostConfig *arg1 = (BMXSDKConfigHostConfig *) 0 ;
  int imresult = 0 ;
  int result;
  
  arg1 = (BMXSDKConfigHostConfig *)imarg1; 
  result = (int) ((arg1)->imPort);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXSDKConfigHostConfig_restHost_set(void* imarg1, NSString* imarg2) {
  BMXSDKConfigHostConfig *arg1 = (BMXSDKConfigHostConfig *) 0 ;
  std::string *arg2 = 0 ;
  
  arg1 = (BMXSDKConfigHostConfig *)imarg1; 
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  if (arg1) (arg1)->restHost = *arg2;
}

NSString* _wrap_BMXSDKConfigHostConfig_restHost_get(void* imarg1) {
  BMXSDKConfigHostConfig *arg1 = (BMXSDKConfigHostConfig *) 0 ;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  arg1 = (BMXSDKConfigHostConfig *)imarg1; 
  result = (std::string *) & ((arg1)->restHost);
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_delete_BMXSDKConfigHostConfig(void* imarg1) {
  BMXSDKConfigHostConfig *arg1 = (BMXSDKConfigHostConfig *) 0 ;
  
  arg1 = (BMXSDKConfigHostConfig *)imarg1; 
  delete arg1;
}

void* _wrap_new_BMXGroupMember(long long imarg1, NSString* imarg2, long long imarg3) {
  int64_t arg1 ;
  std::string *arg2 = 0 ;
  int64_t arg3 ;
  void* imresult = 0 ;
  floo::BMXGroup::Member *result = 0 ;
  
  arg1 = (int64_t)imarg1; 
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  arg3 = (int64_t)imarg3; 
  result = (floo::BMXGroup::Member *)new floo::BMXGroup::Member(arg1,(std::string const &)*arg2,arg3);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_delete_BMXGroupMember(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroup::MemberPtr arg1 ;
  floo::BMXGroup::MemberPtr *argp1 = *(floo::BMXGroup::MemberPtr **)&larg1;
  delete argp1;
}

void _wrap_BMXGroupMember_mUid_set(void* imarg1, long long imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroup::MemberPtr arg1 ;
  floo::BMXGroup::MemberPtr *argp1 = *(floo::BMXGroup::MemberPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int64_t arg2 ;
  
  arg2 = (int64_t)imarg2; 
  if (arg1) (arg1)->mUid = arg2;
}

long long _wrap_BMXGroupMember_mUid_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroup::MemberPtr arg1 ;
  floo::BMXGroup::MemberPtr *argp1 = *(floo::BMXGroup::MemberPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  long long imresult = 0 ;
  int64_t result;
  
  result = (int64_t) ((arg1)->mUid);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXGroupMember_mGroupNickname_set(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroup::MemberPtr arg1 ;
  floo::BMXGroup::MemberPtr *argp1 = *(floo::BMXGroup::MemberPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  if (arg1) (arg1)->mGroupNickname = *arg2;
}

NSString* _wrap_BMXGroupMember_mGroupNickname_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroup::MemberPtr arg1 ;
  floo::BMXGroup::MemberPtr *argp1 = *(floo::BMXGroup::MemberPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) & ((arg1)->mGroupNickname);
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXGroupMember_mCreateTime_set(void* imarg1, long long imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroup::MemberPtr arg1 ;
  floo::BMXGroup::MemberPtr *argp1 = *(floo::BMXGroup::MemberPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int64_t arg2 ;
  
  arg2 = (int64_t)imarg2; 
  if (arg1) (arg1)->mCreateTime = arg2;
}

long long _wrap_BMXGroupMember_mCreateTime_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroup::MemberPtr arg1 ;
  floo::BMXGroup::MemberPtr *argp1 = *(floo::BMXGroup::MemberPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  long long imresult = 0 ;
  int64_t result;
  
  result = (int64_t) ((arg1)->mCreateTime);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_BMXGroupBannedMember() {
  void* imresult = 0 ;
  BMXGroupBannedMember *result = 0 ;
  
  result = (BMXGroupBannedMember *)new BMXGroupBannedMember();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_delete_BMXGroupBannedMember(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroup::BannedMemberPtr arg1 ;
  floo::BMXGroup::BannedMemberPtr *argp1 = *(floo::BMXGroup::BannedMemberPtr **)&larg1;
  delete argp1;
}

void _wrap_BMXGroupBannedMember_mUid_set(void* imarg1, long long imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroup::BannedMemberPtr arg1 ;
  floo::BMXGroup::BannedMemberPtr *argp1 = *(floo::BMXGroup::BannedMemberPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int64_t arg2 ;
  
  arg2 = (int64_t)imarg2; 
  if (arg1) (arg1)->mUid = arg2;
}

long long _wrap_BMXGroupBannedMember_mUid_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroup::BannedMemberPtr arg1 ;
  floo::BMXGroup::BannedMemberPtr *argp1 = *(floo::BMXGroup::BannedMemberPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  long long imresult = 0 ;
  int64_t result;
  
  result = (int64_t) ((arg1)->mUid);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXGroupBannedMember_mGroupNickname_set(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroup::BannedMemberPtr arg1 ;
  floo::BMXGroup::BannedMemberPtr *argp1 = *(floo::BMXGroup::BannedMemberPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  if (arg1) (arg1)->mGroupNickname = *arg2;
}

NSString* _wrap_BMXGroupBannedMember_mGroupNickname_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroup::BannedMemberPtr arg1 ;
  floo::BMXGroup::BannedMemberPtr *argp1 = *(floo::BMXGroup::BannedMemberPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) & ((arg1)->mGroupNickname);
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXGroupBannedMember_mCreateTime_set(void* imarg1, long long imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroup::BannedMemberPtr arg1 ;
  floo::BMXGroup::BannedMemberPtr *argp1 = *(floo::BMXGroup::BannedMemberPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int64_t arg2 ;
  
  arg2 = (int64_t)imarg2; 
  if (arg1) (arg1)->mCreateTime = arg2;
}

long long _wrap_BMXGroupBannedMember_mCreateTime_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroup::BannedMemberPtr arg1 ;
  floo::BMXGroup::BannedMemberPtr *argp1 = *(floo::BMXGroup::BannedMemberPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  long long imresult = 0 ;
  int64_t result;
  
  result = (int64_t) ((arg1)->mCreateTime);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXGroupBannedMember_mExpired_set(void* imarg1, long long imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroup::BannedMemberPtr arg1 ;
  floo::BMXGroup::BannedMemberPtr *argp1 = *(floo::BMXGroup::BannedMemberPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int64_t arg2 ;
  
  arg2 = (int64_t)imarg2; 
  if (arg1) (arg1)->mExpired = arg2;
}

long long _wrap_BMXGroupBannedMember_mExpired_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroup::BannedMemberPtr arg1 ;
  floo::BMXGroup::BannedMemberPtr *argp1 = *(floo::BMXGroup::BannedMemberPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  long long imresult = 0 ;
  int64_t result;
  
  result = (int64_t) ((arg1)->mExpired);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_BMXGroupSharedFile() {
  void* imresult = 0 ;
  floo::BMXGroup::SharedFile *result = 0 ;
  
  result = (floo::BMXGroup::SharedFile *)new floo::BMXGroup::SharedFile();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_delete_BMXGroupSharedFile(void* imarg1) {
  floo::BMXGroup::SharedFile *arg1 = (floo::BMXGroup::SharedFile *) 0 ;
  
  arg1 = (floo::BMXGroup::SharedFile *)imarg1; 
  delete arg1;
}

void _wrap_BMXGroupSharedFile_mFileId_set(void* imarg1, long long imarg2) {
  floo::BMXGroup::SharedFile *arg1 = (floo::BMXGroup::SharedFile *) 0 ;
  int64_t arg2 ;
  
  arg1 = (floo::BMXGroup::SharedFile *)imarg1; 
  arg2 = (int64_t)imarg2; 
  if (arg1) (arg1)->mFileId = arg2;
}

long long _wrap_BMXGroupSharedFile_mFileId_get(void* imarg1) {
  floo::BMXGroup::SharedFile *arg1 = (floo::BMXGroup::SharedFile *) 0 ;
  long long imresult = 0 ;
  int64_t result;
  
  arg1 = (floo::BMXGroup::SharedFile *)imarg1; 
  result = (int64_t) ((arg1)->mFileId);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXGroupSharedFile_mGroupId_set(void* imarg1, long long imarg2) {
  floo::BMXGroup::SharedFile *arg1 = (floo::BMXGroup::SharedFile *) 0 ;
  int64_t arg2 ;
  
  arg1 = (floo::BMXGroup::SharedFile *)imarg1; 
  arg2 = (int64_t)imarg2; 
  if (arg1) (arg1)->mGroupId = arg2;
}

long long _wrap_BMXGroupSharedFile_mGroupId_get(void* imarg1) {
  floo::BMXGroup::SharedFile *arg1 = (floo::BMXGroup::SharedFile *) 0 ;
  long long imresult = 0 ;
  int64_t result;
  
  arg1 = (floo::BMXGroup::SharedFile *)imarg1; 
  result = (int64_t) ((arg1)->mGroupId);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXGroupSharedFile_mUploader_set(void* imarg1, long long imarg2) {
  floo::BMXGroup::SharedFile *arg1 = (floo::BMXGroup::SharedFile *) 0 ;
  int64_t arg2 ;
  
  arg1 = (floo::BMXGroup::SharedFile *)imarg1; 
  arg2 = (int64_t)imarg2; 
  if (arg1) (arg1)->mUploader = arg2;
}

long long _wrap_BMXGroupSharedFile_mUploader_get(void* imarg1) {
  floo::BMXGroup::SharedFile *arg1 = (floo::BMXGroup::SharedFile *) 0 ;
  long long imresult = 0 ;
  int64_t result;
  
  arg1 = (floo::BMXGroup::SharedFile *)imarg1; 
  result = (int64_t) ((arg1)->mUploader);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXGroupSharedFile_mSize_set(void* imarg1, int imarg2) {
  floo::BMXGroup::SharedFile *arg1 = (floo::BMXGroup::SharedFile *) 0 ;
  int arg2 ;
  
  arg1 = (floo::BMXGroup::SharedFile *)imarg1; 
  arg2 = (int)imarg2; 
  if (arg1) (arg1)->mSize = arg2;
}

int _wrap_BMXGroupSharedFile_mSize_get(void* imarg1) {
  floo::BMXGroup::SharedFile *arg1 = (floo::BMXGroup::SharedFile *) 0 ;
  int imresult = 0 ;
  int result;
  
  arg1 = (floo::BMXGroup::SharedFile *)imarg1; 
  result = (int) ((arg1)->mSize);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXGroupSharedFile_mCreateTime_set(void* imarg1, long long imarg2) {
  floo::BMXGroup::SharedFile *arg1 = (floo::BMXGroup::SharedFile *) 0 ;
  int64_t arg2 ;
  
  arg1 = (floo::BMXGroup::SharedFile *)imarg1; 
  arg2 = (int64_t)imarg2; 
  if (arg1) (arg1)->mCreateTime = arg2;
}

long long _wrap_BMXGroupSharedFile_mCreateTime_get(void* imarg1) {
  floo::BMXGroup::SharedFile *arg1 = (floo::BMXGroup::SharedFile *) 0 ;
  long long imresult = 0 ;
  int64_t result;
  
  arg1 = (floo::BMXGroup::SharedFile *)imarg1; 
  result = (int64_t) ((arg1)->mCreateTime);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXGroupSharedFile_mUpdateTime_set(void* imarg1, long long imarg2) {
  floo::BMXGroup::SharedFile *arg1 = (floo::BMXGroup::SharedFile *) 0 ;
  int64_t arg2 ;
  
  arg1 = (floo::BMXGroup::SharedFile *)imarg1; 
  arg2 = (int64_t)imarg2; 
  if (arg1) (arg1)->mUpdateTime = arg2;
}

long long _wrap_BMXGroupSharedFile_mUpdateTime_get(void* imarg1) {
  floo::BMXGroup::SharedFile *arg1 = (floo::BMXGroup::SharedFile *) 0 ;
  long long imresult = 0 ;
  int64_t result;
  
  arg1 = (floo::BMXGroup::SharedFile *)imarg1; 
  result = (int64_t) ((arg1)->mUpdateTime);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXGroupSharedFile_mRatelUrl_set(void* imarg1, NSString* imarg2) {
  floo::BMXGroup::SharedFile *arg1 = (floo::BMXGroup::SharedFile *) 0 ;
  std::string *arg2 = 0 ;
  
  arg1 = (floo::BMXGroup::SharedFile *)imarg1; 
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  if (arg1) (arg1)->mRatelUrl = *arg2;
}

NSString* _wrap_BMXGroupSharedFile_mRatelUrl_get(void* imarg1) {
  floo::BMXGroup::SharedFile *arg1 = (floo::BMXGroup::SharedFile *) 0 ;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  arg1 = (floo::BMXGroup::SharedFile *)imarg1; 
  result = (std::string *) & ((arg1)->mRatelUrl);
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXGroupSharedFile_mUrl_set(void* imarg1, NSString* imarg2) {
  floo::BMXGroup::SharedFile *arg1 = (floo::BMXGroup::SharedFile *) 0 ;
  std::string *arg2 = 0 ;
  
  arg1 = (floo::BMXGroup::SharedFile *)imarg1; 
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  if (arg1) (arg1)->mUrl = *arg2;
}

NSString* _wrap_BMXGroupSharedFile_mUrl_get(void* imarg1) {
  floo::BMXGroup::SharedFile *arg1 = (floo::BMXGroup::SharedFile *) 0 ;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  arg1 = (floo::BMXGroup::SharedFile *)imarg1; 
  result = (std::string *) & ((arg1)->mUrl);
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXGroupSharedFile_mPath_set(void* imarg1, NSString* imarg2) {
  floo::BMXGroup::SharedFile *arg1 = (floo::BMXGroup::SharedFile *) 0 ;
  std::string *arg2 = 0 ;
  
  arg1 = (floo::BMXGroup::SharedFile *)imarg1; 
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  if (arg1) (arg1)->mPath = *arg2;
}

NSString* _wrap_BMXGroupSharedFile_mPath_get(void* imarg1) {
  floo::BMXGroup::SharedFile *arg1 = (floo::BMXGroup::SharedFile *) 0 ;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  arg1 = (floo::BMXGroup::SharedFile *)imarg1; 
  result = (std::string *) & ((arg1)->mPath);
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXGroupSharedFile_mDisplayName_set(void* imarg1, NSString* imarg2) {
  floo::BMXGroup::SharedFile *arg1 = (floo::BMXGroup::SharedFile *) 0 ;
  std::string *arg2 = 0 ;
  
  arg1 = (floo::BMXGroup::SharedFile *)imarg1; 
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  if (arg1) (arg1)->mDisplayName = *arg2;
}

NSString* _wrap_BMXGroupSharedFile_mDisplayName_get(void* imarg1) {
  floo::BMXGroup::SharedFile *arg1 = (floo::BMXGroup::SharedFile *) 0 ;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  arg1 = (floo::BMXGroup::SharedFile *)imarg1; 
  result = (std::string *) & ((arg1)->mDisplayName);
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXGroupSharedFile_mType_set(void* imarg1, NSString* imarg2) {
  floo::BMXGroup::SharedFile *arg1 = (floo::BMXGroup::SharedFile *) 0 ;
  std::string *arg2 = 0 ;
  
  arg1 = (floo::BMXGroup::SharedFile *)imarg1; 
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  if (arg1) (arg1)->mType = *arg2;
}

NSString* _wrap_BMXGroupSharedFile_mType_get(void* imarg1) {
  floo::BMXGroup::SharedFile *arg1 = (floo::BMXGroup::SharedFile *) 0 ;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  arg1 = (floo::BMXGroup::SharedFile *)imarg1; 
  result = (std::string *) & ((arg1)->mType);
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void* _wrap_new_BMXGroupAnnouncement() {
  void* imresult = 0 ;
  floo::BMXGroup::Announcement *result = 0 ;
  
  result = (floo::BMXGroup::Announcement *)new floo::BMXGroup::Announcement();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_delete_BMXGroupAnnouncement(void* imarg1) {
  floo::BMXGroup::Announcement *arg1 = (floo::BMXGroup::Announcement *) 0 ;
  
  arg1 = (floo::BMXGroup::Announcement *)imarg1; 
  delete arg1;
}

void _wrap_BMXGroupAnnouncement_mTitle_set(void* imarg1, NSString* imarg2) {
  floo::BMXGroup::Announcement *arg1 = (floo::BMXGroup::Announcement *) 0 ;
  std::string *arg2 = 0 ;
  
  arg1 = (floo::BMXGroup::Announcement *)imarg1; 
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  if (arg1) (arg1)->mTitle = *arg2;
}

NSString* _wrap_BMXGroupAnnouncement_mTitle_get(void* imarg1) {
  floo::BMXGroup::Announcement *arg1 = (floo::BMXGroup::Announcement *) 0 ;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  arg1 = (floo::BMXGroup::Announcement *)imarg1; 
  result = (std::string *) & ((arg1)->mTitle);
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXGroupAnnouncement_mContent_set(void* imarg1, NSString* imarg2) {
  floo::BMXGroup::Announcement *arg1 = (floo::BMXGroup::Announcement *) 0 ;
  std::string *arg2 = 0 ;
  
  arg1 = (floo::BMXGroup::Announcement *)imarg1; 
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  if (arg1) (arg1)->mContent = *arg2;
}

NSString* _wrap_BMXGroupAnnouncement_mContent_get(void* imarg1) {
  floo::BMXGroup::Announcement *arg1 = (floo::BMXGroup::Announcement *) 0 ;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  arg1 = (floo::BMXGroup::Announcement *)imarg1; 
  result = (std::string *) & ((arg1)->mContent);
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXGroupAnnouncement_mAuthor_set(void* imarg1, long long imarg2) {
  floo::BMXGroup::Announcement *arg1 = (floo::BMXGroup::Announcement *) 0 ;
  int64_t arg2 ;
  
  arg1 = (floo::BMXGroup::Announcement *)imarg1; 
  arg2 = (int64_t)imarg2; 
  if (arg1) (arg1)->mAuthor = arg2;
}

long long _wrap_BMXGroupAnnouncement_mAuthor_get(void* imarg1) {
  floo::BMXGroup::Announcement *arg1 = (floo::BMXGroup::Announcement *) 0 ;
  long long imresult = 0 ;
  int64_t result;
  
  arg1 = (floo::BMXGroup::Announcement *)imarg1; 
  result = (int64_t) ((arg1)->mAuthor);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXGroupAnnouncement_mCreateTime_set(void* imarg1, long long imarg2) {
  floo::BMXGroup::Announcement *arg1 = (floo::BMXGroup::Announcement *) 0 ;
  int64_t arg2 ;
  
  arg1 = (floo::BMXGroup::Announcement *)imarg1; 
  arg2 = (int64_t)imarg2; 
  if (arg1) (arg1)->mCreateTime = arg2;
}

long long _wrap_BMXGroupAnnouncement_mCreateTime_get(void* imarg1) {
  floo::BMXGroup::Announcement *arg1 = (floo::BMXGroup::Announcement *) 0 ;
  long long imresult = 0 ;
  int64_t result;
  
  arg1 = (floo::BMXGroup::Announcement *)imarg1; 
  result = (int64_t) ((arg1)->mCreateTime);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXGroupAnnouncement_mId_set(void* imarg1, long long imarg2) {
  floo::BMXGroup::Announcement *arg1 = (floo::BMXGroup::Announcement *) 0 ;
  int64_t arg2 ;
  
  arg1 = (floo::BMXGroup::Announcement *)imarg1; 
  arg2 = (int64_t)imarg2; 
  if (arg1) (arg1)->mId = arg2;
}

long long _wrap_BMXGroupAnnouncement_mId_get(void* imarg1) {
  floo::BMXGroup::Announcement *arg1 = (floo::BMXGroup::Announcement *) 0 ;
  long long imresult = 0 ;
  int64_t result;
  
  arg1 = (floo::BMXGroup::Announcement *)imarg1; 
  result = (int64_t) ((arg1)->mId);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_BMXGroupInvitation() {
  void* imresult = 0 ;
  floo::BMXGroup::Invitation *result = 0 ;
  
  result = (floo::BMXGroup::Invitation *)new floo::BMXGroup::Invitation();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_delete_BMXGroupInvitation(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroup::InvitationPtr arg1 ;
  floo::BMXGroup::InvitationPtr *argp1 = *(floo::BMXGroup::InvitationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  
  delete argp1;
}

void _wrap_BMXGroupInvitation_mGroupId_set(void* imarg1, long long imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroup::InvitationPtr arg1 ;
  floo::BMXGroup::InvitationPtr *argp1 = *(floo::BMXGroup::InvitationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int64_t arg2 ;
  
  arg2 = (int64_t)imarg2; 
  if (arg1) (arg1)->mGroupId = arg2;
}

long long _wrap_BMXGroupInvitation_mGroupId_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroup::InvitationPtr arg1 ;
  floo::BMXGroup::InvitationPtr *argp1 = *(floo::BMXGroup::InvitationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  long long imresult = 0 ;
  int64_t result;
  
  result = (int64_t) ((arg1)->mGroupId);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXGroupInvitation_mInviterId_set(void* imarg1, long long imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroup::InvitationPtr arg1 ;
  floo::BMXGroup::InvitationPtr *argp1 = *(floo::BMXGroup::InvitationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int64_t arg2 ;
  
  arg2 = (int64_t)imarg2; 
  if (arg1) (arg1)->mInviterId = arg2;
}

long long _wrap_BMXGroupInvitation_mInviterId_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroup::InvitationPtr arg1 ;
  floo::BMXGroup::InvitationPtr *argp1 = *(floo::BMXGroup::InvitationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  long long imresult = 0 ;
  int64_t result;
  
  result = (int64_t) ((arg1)->mInviterId);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXGroupInvitation_mReason_set(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroup::InvitationPtr arg1 ;
  floo::BMXGroup::InvitationPtr *argp1 = *(floo::BMXGroup::InvitationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  if (arg1) (arg1)->mReason = *arg2;
}

NSString* _wrap_BMXGroupInvitation_mReason_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroup::InvitationPtr arg1 ;
  floo::BMXGroup::InvitationPtr *argp1 = *(floo::BMXGroup::InvitationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) & ((arg1)->mReason);
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXGroupInvitation_mStatus_set(void* imarg1, int imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroup::InvitationPtr arg1 ;
  floo::BMXGroup::InvitationPtr *argp1 = *(floo::BMXGroup::InvitationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  floo::BMXGroup::InvitationStatus arg2 ;
  
  arg2 = (floo::BMXGroup::InvitationStatus)imarg2; 
  if (arg1) (arg1)->mStatus = arg2;
}

int _wrap_BMXGroupInvitation_mStatus_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroup::InvitationPtr arg1 ;
  floo::BMXGroup::InvitationPtr *argp1 = *(floo::BMXGroup::InvitationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  floo::BMXGroup::InvitationStatus result;
  
  result = (floo::BMXGroup::InvitationStatus) ((arg1)->mStatus);
  imresult = (int)result; 
  return imresult;
}

void _wrap_BMXGroupInvitation_mExpired_set(void* imarg1, long long imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroup::InvitationPtr arg1 ;
  floo::BMXGroup::InvitationPtr *argp1 = *(floo::BMXGroup::InvitationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int64_t arg2 ;
  
  arg2 = (int64_t)imarg2; 
  if (arg1) (arg1)->mExpired = arg2;
}

long long _wrap_BMXGroupInvitation_mExpired_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroup::InvitationPtr arg1 ;
  floo::BMXGroup::InvitationPtr *argp1 = *(floo::BMXGroup::InvitationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  long long imresult = 0 ;
  int64_t result;
  
  result = (int64_t) ((arg1)->mExpired);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_BMXGroupApplication() {
  void* imresult = 0 ;
  floo::BMXGroup::Application *result = 0 ;
  
  result = (floo::BMXGroup::Application *)new floo::BMXGroup::Application();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_delete_BMXGroupApplication(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroup::ApplicationPtr arg1 ;
  floo::BMXGroup::ApplicationPtr *argp1 = *(floo::BMXGroup::ApplicationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  
  delete argp1;
}

void _wrap_BMXGroupApplication_mGroupId_set(void* imarg1, long long imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroup::ApplicationPtr arg1 ;
  floo::BMXGroup::ApplicationPtr *argp1 = *(floo::BMXGroup::ApplicationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int64_t arg2 ;
  
  arg2 = (int64_t)imarg2; 
  if (arg1) (arg1)->mGroupId = arg2;
}

long long _wrap_BMXGroupApplication_mGroupId_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroup::ApplicationPtr arg1 ;
  floo::BMXGroup::ApplicationPtr *argp1 = *(floo::BMXGroup::ApplicationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  long long imresult = 0 ;
  int64_t result;
  
  result = (int64_t) ((arg1)->mGroupId);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXGroupApplication_mApplicationId_set(void* imarg1, long long imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroup::ApplicationPtr arg1 ;
  floo::BMXGroup::ApplicationPtr *argp1 = *(floo::BMXGroup::ApplicationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int64_t arg2 ;
  
  arg2 = (int64_t)imarg2; 
  if (arg1) (arg1)->mApplicationId = arg2;
}

long long _wrap_BMXGroupApplication_mApplicationId_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroup::ApplicationPtr arg1 ;
  floo::BMXGroup::ApplicationPtr *argp1 = *(floo::BMXGroup::ApplicationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  long long imresult = 0 ;
  int64_t result;
  
  result = (int64_t) ((arg1)->mApplicationId);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXGroupApplication_mReason_set(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroup::ApplicationPtr arg1 ;
  floo::BMXGroup::ApplicationPtr *argp1 = *(floo::BMXGroup::ApplicationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  if (arg1) (arg1)->mReason = *arg2;
}

NSString* _wrap_BMXGroupApplication_mReason_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroup::ApplicationPtr arg1 ;
  floo::BMXGroup::ApplicationPtr *argp1 = *(floo::BMXGroup::ApplicationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) & ((arg1)->mReason);
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXGroupApplication_mStatus_set(void* imarg1, int imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroup::ApplicationPtr arg1 ;
  floo::BMXGroup::ApplicationPtr *argp1 = *(floo::BMXGroup::ApplicationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  floo::BMXGroup::ApplicationStatus arg2 ;
  
  arg2 = (floo::BMXGroup::ApplicationStatus)imarg2; 
  if (arg1) (arg1)->mStatus = arg2;
}

int _wrap_BMXGroupApplication_mStatus_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroup::ApplicationPtr arg1 ;
  floo::BMXGroup::ApplicationPtr *argp1 = *(floo::BMXGroup::ApplicationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  floo::BMXGroup::ApplicationStatus result;
  
  result = (floo::BMXGroup::ApplicationStatus) ((arg1)->mStatus);
  imresult = (int)result; 
  return imresult;
}

void _wrap_BMXGroupApplication_mExpired_set(void* imarg1, long long imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroup::ApplicationPtr arg1 ;
  floo::BMXGroup::ApplicationPtr *argp1 = *(floo::BMXGroup::ApplicationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int64_t arg2 ;
  
  arg2 = (int64_t)imarg2; 
  if (arg1) (arg1)->mExpired = arg2;
}

long long _wrap_BMXGroupApplication_mExpired_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroup::ApplicationPtr arg1 ;
  floo::BMXGroup::ApplicationPtr *argp1 = *(floo::BMXGroup::ApplicationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  long long imresult = 0 ;
  int64_t result;
  
  result = (int64_t) ((arg1)->mExpired);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_BMXGroupServiceCreateGroupOptions__SWIG_0() {
  void* imresult = 0 ;
  floo::BMXGroupService::CreateGroupOptions *result = 0 ;
  
  result = (floo::BMXGroupService::CreateGroupOptions *)new floo::BMXGroupService::CreateGroupOptions();
  BMXGroupServiceCreateGroupOptions2Void(result)
  imresult = (void*)lresult;
  return imresult;
}

void* _wrap_new_BMXGroupServiceCreateGroupOptions__SWIG_1(NSString* imarg1, NSString* imarg2, BOOL imarg3, BOOL imarg4) {
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  bool arg3 ;
  bool arg4 ;
  void* imresult = 0 ;
  floo::BMXGroupService::CreateGroupOptions *result = 0 ;
  
  if(!imarg1) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg1_str(getStdString(imarg1));
  arg1 = &arg1_str; 
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  arg3 = imarg3? true : false; 
  arg4 = imarg4? true : false; 
  result = (floo::BMXGroupService::CreateGroupOptions *)new floo::BMXGroupService::CreateGroupOptions((std::string const &)*arg1,(std::string const &)*arg2,arg3,arg4);
  BMXGroupServiceCreateGroupOptions2Void(result)
  imresult = (void*)lresult;
  return imresult;
}

void* _wrap_new_BMXGroupServiceCreateGroupOptions__SWIG_2(NSString* imarg1, NSString* imarg2, BOOL imarg3) {
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  bool arg3 ;
  void* imresult = 0 ;
  floo::BMXGroupService::CreateGroupOptions *result = 0 ;
  
  if(!imarg1) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg1_str(getStdString(imarg1));
  arg1 = &arg1_str; 
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  arg3 = imarg3? true : false; 
  result = (floo::BMXGroupService::CreateGroupOptions *)new floo::BMXGroupService::CreateGroupOptions((std::string const &)*arg1,(std::string const &)*arg2,arg3);
  BMXGroupServiceCreateGroupOptions2Void(result)
  imresult = (void*)lresult;
  return imresult;
}

void* _wrap_new_BMXGroupServiceCreateGroupOptions__SWIG_3(NSString* imarg1, NSString* imarg2) {
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  void* imresult = 0 ;
  floo::BMXGroupService::CreateGroupOptions *result = 0 ;
  
  if(!imarg1) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg1_str(getStdString(imarg1));
  arg1 = &arg1_str; 
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  result = (floo::BMXGroupService::CreateGroupOptions *)new floo::BMXGroupService::CreateGroupOptions((std::string const &)*arg1,(std::string const &)*arg2);
  BMXGroupServiceCreateGroupOptions2Void(result)
  imresult = (void*)lresult;
  return imresult;
}

void _wrap_BMXGroupServiceCreateGroupOptions_mName_set(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroupService::CreateGroupOptionsPtr arg1 ;
  floo::BMXGroupService::CreateGroupOptionsPtr *argp1 = *(floo::BMXGroupService::CreateGroupOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  if (arg1) (arg1)->mName = *arg2;
}

NSString* _wrap_BMXGroupServiceCreateGroupOptions_mName_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroupService::CreateGroupOptionsPtr arg1 ;
  floo::BMXGroupService::CreateGroupOptionsPtr *argp1 = *(floo::BMXGroupService::CreateGroupOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) & ((arg1)->mName);
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXGroupServiceCreateGroupOptions_mDescription_set(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroupService::CreateGroupOptionsPtr arg1 ;
  floo::BMXGroupService::CreateGroupOptionsPtr *argp1 = *(floo::BMXGroupService::CreateGroupOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  if (arg1) (arg1)->mDescription = *arg2;
}

NSString* _wrap_BMXGroupServiceCreateGroupOptions_mDescription_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroupService::CreateGroupOptionsPtr arg1 ;
  floo::BMXGroupService::CreateGroupOptionsPtr *argp1 = *(floo::BMXGroupService::CreateGroupOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) & ((arg1)->mDescription);
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXGroupServiceCreateGroupOptions_mIsPublic_set(void* imarg1, BOOL imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroupService::CreateGroupOptionsPtr arg1 ;
  floo::BMXGroupService::CreateGroupOptionsPtr *argp1 = *(floo::BMXGroupService::CreateGroupOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  bool arg2 ;
  
  arg2 = imarg2? true : false; 
  if (arg1) (arg1)->mIsPublic = arg2;
}

BOOL _wrap_BMXGroupServiceCreateGroupOptions_mIsPublic_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroupService::CreateGroupOptionsPtr arg1 ;
  floo::BMXGroupService::CreateGroupOptionsPtr *argp1 = *(floo::BMXGroupService::CreateGroupOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BOOL imresult = 0 ;
  bool result;
  
  result = (bool) ((arg1)->mIsPublic);
  imresult = (result)? YES:NO; 
  return imresult;
}

void _wrap_BMXGroupServiceCreateGroupOptions_mIsChatroom_set(void* imarg1, BOOL imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroupService::CreateGroupOptionsPtr arg1 ;
  floo::BMXGroupService::CreateGroupOptionsPtr *argp1 = *(floo::BMXGroupService::CreateGroupOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  bool arg2 ;
  
  arg2 = imarg2? true : false; 
  if (arg1) (arg1)->mIsChatroom = arg2;
}

BOOL _wrap_BMXGroupServiceCreateGroupOptions_mIsChatroom_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroupService::CreateGroupOptionsPtr arg1 ;
  floo::BMXGroupService::CreateGroupOptionsPtr *argp1 = *(floo::BMXGroupService::CreateGroupOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BOOL imresult = 0 ;
  bool result;
  
  result = (bool) ((arg1)->mIsChatroom);
  imresult = (result)? YES:NO; 
  return imresult;
}

void _wrap_BMXGroupServiceCreateGroupOptions_mMessage_set(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroupService::CreateGroupOptionsPtr arg1 ;
  floo::BMXGroupService::CreateGroupOptionsPtr *argp1 = *(floo::BMXGroupService::CreateGroupOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  if (arg1) (arg1)->mMessage = *arg2;
}

NSString* _wrap_BMXGroupServiceCreateGroupOptions_mMessage_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroupService::CreateGroupOptionsPtr arg1 ;
  floo::BMXGroupService::CreateGroupOptionsPtr *argp1 = *(floo::BMXGroupService::CreateGroupOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) & ((arg1)->mMessage);
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXGroupServiceCreateGroupOptions_mMembers_set(void* imarg1, void* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroupService::CreateGroupOptionsPtr arg1 ;
  floo::BMXGroupService::CreateGroupOptionsPtr *argp1 = *(floo::BMXGroupService::CreateGroupOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::vector< int64_t > *arg2 = (std::vector< int64_t > *) 0 ;
  
  arg2 = (std::vector< int64_t > *)imarg2; 
  if (arg1) (arg1)->mMembers = *arg2;
}

void* _wrap_BMXGroupServiceCreateGroupOptions_mMembers_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroupService::CreateGroupOptionsPtr arg1 ;
  floo::BMXGroupService::CreateGroupOptionsPtr *argp1 = *(floo::BMXGroupService::CreateGroupOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  void* imresult = 0 ;
  std::vector< int64_t > *result = 0 ;
  
  result = (std::vector< int64_t > *)& ((arg1)->mMembers);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_delete_BMXGroupServiceCreateGroupOptions(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroupService::CreateGroupOptionsPtr arg1 ;
  floo::BMXGroupService::CreateGroupOptionsPtr *argp1 = *(floo::BMXGroupService::CreateGroupOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  
  delete argp1;
}

void* _wrap_new_BMXMessageAttachmentSize__SWIG_0(double imarg1, double imarg2) {
  double arg1 ;
  double arg2 ;
  void* imresult = 0 ;
  BMXMessageAttachmentSize *result = 0 ;
  
  arg1 = (double)imarg1; 
  arg2 = (double)imarg2; 
  result = (BMXMessageAttachmentSize *)new BMXMessageAttachmentSize(arg1,arg2);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_BMXMessageAttachmentSize__SWIG_1(double imarg1) {
  double arg1 ;
  void* imresult = 0 ;
  BMXMessageAttachmentSize *result = 0 ;
  
  arg1 = (double)imarg1; 
  result = (BMXMessageAttachmentSize *)new BMXMessageAttachmentSize(arg1);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_BMXMessageAttachmentSize__SWIG_2() {
  void* imresult = 0 ;
  BMXMessageAttachmentSize *result = 0 ;
  
  result = (BMXMessageAttachmentSize *)new BMXMessageAttachmentSize();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXMessageAttachmentSize_mWidth_set(void* imarg1, double imarg2) {
  BMXMessageAttachmentSize *arg1 = (BMXMessageAttachmentSize *) 0 ;
  double arg2 ;
  
  arg1 = (BMXMessageAttachmentSize *)imarg1; 
  arg2 = (double)imarg2; 
  if (arg1) (arg1)->mWidth = arg2;
}

double _wrap_BMXMessageAttachmentSize_mWidth_get(void* imarg1) {
  BMXMessageAttachmentSize *arg1 = (BMXMessageAttachmentSize *) 0 ;
  double imresult = 0 ;
  double result;
  
  arg1 = (BMXMessageAttachmentSize *)imarg1; 
  result = (double) ((arg1)->mWidth);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXMessageAttachmentSize_mHeight_set(void* imarg1, double imarg2) {
  BMXMessageAttachmentSize *arg1 = (BMXMessageAttachmentSize *) 0 ;
  double arg2 ;
  
  arg1 = (BMXMessageAttachmentSize *)imarg1; 
  arg2 = (double)imarg2; 
  if (arg1) (arg1)->mHeight = arg2;
}

double _wrap_BMXMessageAttachmentSize_mHeight_get(void* imarg1) {
  BMXMessageAttachmentSize *arg1 = (BMXMessageAttachmentSize *) 0 ;
  double imresult = 0 ;
  double result;
  
  arg1 = (BMXMessageAttachmentSize *)imarg1; 
  result = (double) ((arg1)->mHeight);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_delete_BMXMessageAttachmentSize(void* imarg1) {
  BMXMessageAttachmentSize *arg1 = (BMXMessageAttachmentSize *) 0 ;
  
  arg1 = (BMXMessageAttachmentSize *)imarg1; 
  delete arg1;
}

void* _wrap_new_BMXPushUserProfileMessagePushSetting() {
  void* imresult = 0 ;
  BMXPushUserProfileMessagePushSetting *result = 0 ;
  
  result = (BMXPushUserProfileMessagePushSetting *)new BMXPushUserProfileMessagePushSetting();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXPushUserProfileMessagePushSetting_mPushEnabled_set(void* imarg1, BOOL imarg2) {
  BMXPushUserProfileMessagePushSetting *arg1 = (BMXPushUserProfileMessagePushSetting *) 0 ;
  bool arg2 ;
  
  arg1 = (BMXPushUserProfileMessagePushSetting *)imarg1; 
  arg2 = imarg2? true : false; 
  if (arg1) (arg1)->mPushEnabled = arg2;
}

BOOL _wrap_BMXPushUserProfileMessagePushSetting_mPushEnabled_get(void* imarg1) {
  BMXPushUserProfileMessagePushSetting *arg1 = (BMXPushUserProfileMessagePushSetting *) 0 ;
  BOOL imresult = 0 ;
  bool result;
  
  arg1 = (BMXPushUserProfileMessagePushSetting *)imarg1; 
  result = (bool) ((arg1)->mPushEnabled);
  imresult = (result)? YES:NO; 
  return imresult;
}

void _wrap_BMXPushUserProfileMessagePushSetting_mSilenceStartTime_set(void* imarg1, int imarg2) {
  BMXPushUserProfileMessagePushSetting *arg1 = (BMXPushUserProfileMessagePushSetting *) 0 ;
  int arg2 ;
  
  arg1 = (BMXPushUserProfileMessagePushSetting *)imarg1; 
  arg2 = (int)imarg2; 
  if (arg1) (arg1)->mSilenceStartTime = arg2;
}

int _wrap_BMXPushUserProfileMessagePushSetting_mSilenceStartTime_get(void* imarg1) {
  BMXPushUserProfileMessagePushSetting *arg1 = (BMXPushUserProfileMessagePushSetting *) 0 ;
  int imresult = 0 ;
  int result;
  
  arg1 = (BMXPushUserProfileMessagePushSetting *)imarg1; 
  result = (int) ((arg1)->mSilenceStartTime);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXPushUserProfileMessagePushSetting_mSilenceEndTime_set(void* imarg1, int imarg2) {
  BMXPushUserProfileMessagePushSetting *arg1 = (BMXPushUserProfileMessagePushSetting *) 0 ;
  int arg2 ;
  
  arg1 = (BMXPushUserProfileMessagePushSetting *)imarg1; 
  arg2 = (int)imarg2; 
  if (arg1) (arg1)->mSilenceEndTime = arg2;
}

int _wrap_BMXPushUserProfileMessagePushSetting_mSilenceEndTime_get(void* imarg1) {
  BMXPushUserProfileMessagePushSetting *arg1 = (BMXPushUserProfileMessagePushSetting *) 0 ;
  int imresult = 0 ;
  int result;
  
  arg1 = (BMXPushUserProfileMessagePushSetting *)imarg1; 
  result = (int) ((arg1)->mSilenceEndTime);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXPushUserProfileMessagePushSetting_mPushStartTime_set(void* imarg1, int imarg2) {
  BMXPushUserProfileMessagePushSetting *arg1 = (BMXPushUserProfileMessagePushSetting *) 0 ;
  int arg2 ;
  
  arg1 = (BMXPushUserProfileMessagePushSetting *)imarg1; 
  arg2 = (int)imarg2; 
  if (arg1) (arg1)->mPushStartTime = arg2;
}

int _wrap_BMXPushUserProfileMessagePushSetting_mPushStartTime_get(void* imarg1) {
  BMXPushUserProfileMessagePushSetting *arg1 = (BMXPushUserProfileMessagePushSetting *) 0 ;
  int imresult = 0 ;
  int result;
  
  arg1 = (BMXPushUserProfileMessagePushSetting *)imarg1; 
  result = (int) ((arg1)->mPushStartTime);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXPushUserProfileMessagePushSetting_mPushEndTime_set(void* imarg1, int imarg2) {
  BMXPushUserProfileMessagePushSetting *arg1 = (BMXPushUserProfileMessagePushSetting *) 0 ;
  int arg2 ;
  
  arg1 = (BMXPushUserProfileMessagePushSetting *)imarg1; 
  arg2 = (int)imarg2; 
  if (arg1) (arg1)->mPushEndTime = arg2;
}

int _wrap_BMXPushUserProfileMessagePushSetting_mPushEndTime_get(void* imarg1) {
  BMXPushUserProfileMessagePushSetting *arg1 = (BMXPushUserProfileMessagePushSetting *) 0 ;
  int imresult = 0 ;
  int result;
  
  arg1 = (BMXPushUserProfileMessagePushSetting *)imarg1; 
  result = (int) ((arg1)->mPushEndTime);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_delete_BMXPushUserProfileMessagePushSetting(void* imarg1) {
  BMXPushUserProfileMessagePushSetting *arg1 = (BMXPushUserProfileMessagePushSetting *) 0 ;
  
  arg1 = (BMXPushUserProfileMessagePushSetting *)imarg1; 
  delete arg1;
}

void* _wrap_new_BMXRosterServiceApplication() {
  void* imresult = 0 ;
  floo::BMXRosterService::Application *result = 0 ;
  
  result = (floo::BMXRosterService::Application *)new floo::BMXRosterService::Application();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_delete_BMXRosterServiceApplication(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRosterService::ApplicationPtr arg1 ;
  floo::BMXRosterService::ApplicationPtr *argp1 = *(floo::BMXRosterService::ApplicationPtr **)&larg1;
  delete argp1;
}

void _wrap_BMXRosterServiceApplication_mRosterId_set(void* imarg1, long long imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRosterService::ApplicationPtr arg1 ;
  floo::BMXRosterService::ApplicationPtr *argp1 = *(floo::BMXRosterService::ApplicationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int64_t arg2 ;
  
  arg2 = (int64_t)imarg2; 
  if (arg1) (arg1)->mRosterId = arg2;
}

long long _wrap_BMXRosterServiceApplication_mRosterId_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRosterService::ApplicationPtr arg1 ;
  floo::BMXRosterService::ApplicationPtr *argp1 = *(floo::BMXRosterService::ApplicationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  long long imresult = 0 ;
  int64_t result;
  
  result = (int64_t) ((arg1)->mRosterId);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXRosterServiceApplication_mReason_set(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRosterService::ApplicationPtr arg1 ;
  floo::BMXRosterService::ApplicationPtr *argp1 = *(floo::BMXRosterService::ApplicationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  if (arg1) (arg1)->mReason = *arg2;
}

NSString* _wrap_BMXRosterServiceApplication_mReason_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRosterService::ApplicationPtr arg1 ;
  floo::BMXRosterService::ApplicationPtr *argp1 = *(floo::BMXRosterService::ApplicationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) & ((arg1)->mReason);
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXRosterServiceApplication_mStatus_set(void* imarg1, int imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRosterService::ApplicationPtr arg1 ;
  floo::BMXRosterService::ApplicationPtr *argp1 = *(floo::BMXRosterService::ApplicationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  floo::BMXRosterService::ApplicationStatus arg2 ;
  
  arg2 = (floo::BMXRosterService::ApplicationStatus)imarg2; 
  if (arg1) (arg1)->mStatus = arg2;
}

int _wrap_BMXRosterServiceApplication_mStatus_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRosterService::ApplicationPtr arg1 ;
  floo::BMXRosterService::ApplicationPtr *argp1 = *(floo::BMXRosterService::ApplicationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  floo::BMXRosterService::ApplicationStatus result;
  
  result = (floo::BMXRosterService::ApplicationStatus) ((arg1)->mStatus);
  imresult = (int)result; 
  return imresult;
}

void _wrap_BMXRosterServiceApplication_mExpire_set(void* imarg1, long long imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRosterService::ApplicationPtr arg1 ;
  floo::BMXRosterService::ApplicationPtr *argp1 = *(floo::BMXRosterService::ApplicationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int64_t arg2 ;
  
  arg2 = (int64_t)imarg2; 
  if (arg1) (arg1)->mExpire = arg2;
}

long long _wrap_BMXRosterServiceApplication_mExpire_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRosterService::ApplicationPtr arg1 ;
  floo::BMXRosterService::ApplicationPtr *argp1 = *(floo::BMXRosterService::ApplicationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  long long imresult = 0 ;
  int64_t result;
  
  result = (int64_t) ((arg1)->mExpire);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_BMXUserProfileAuthQuestion() {
  void* imresult = 0 ;
  BMXUserProfileAuthQuestion *result = 0 ;
  
  result = (BMXUserProfileAuthQuestion *)new BMXUserProfileAuthQuestion();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXUserProfileAuthQuestion_mQuestion_set(void* imarg1, NSString* imarg2) {
  BMXUserProfileAuthQuestion *arg1 = (BMXUserProfileAuthQuestion *) 0 ;
  std::string *arg2 = 0 ;
  
  arg1 = (BMXUserProfileAuthQuestion *)imarg1; 
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  if (arg1) (arg1)->mQuestion = *arg2;
}

NSString* _wrap_BMXUserProfileAuthQuestion_mQuestion_get(void* imarg1) {
  BMXUserProfileAuthQuestion *arg1 = (BMXUserProfileAuthQuestion *) 0 ;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  arg1 = (BMXUserProfileAuthQuestion *)imarg1; 
  result = (std::string *) & ((arg1)->mQuestion);
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXUserProfileAuthQuestion_mAnswer_set(void* imarg1, NSString* imarg2) {
  BMXUserProfileAuthQuestion *arg1 = (BMXUserProfileAuthQuestion *) 0 ;
  std::string *arg2 = 0 ;
  
  arg1 = (BMXUserProfileAuthQuestion *)imarg1; 
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  if (arg1) (arg1)->mAnswer = *arg2;
}

NSString* _wrap_BMXUserProfileAuthQuestion_mAnswer_get(void* imarg1) {
  BMXUserProfileAuthQuestion *arg1 = (BMXUserProfileAuthQuestion *) 0 ;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  arg1 = (BMXUserProfileAuthQuestion *)imarg1; 
  result = (std::string *) & ((arg1)->mAnswer);
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_delete_BMXUserProfileAuthQuestion(void* imarg1) {
  BMXUserProfileAuthQuestion *arg1 = (BMXUserProfileAuthQuestion *) 0 ;
  
  arg1 = (BMXUserProfileAuthQuestion *)imarg1; 
  delete arg1;
}

void* _wrap_new_BMXUserProfileMessageSetting() {
  void* imresult = 0 ;
  BMXUserProfileMessageSetting *result = 0 ;
  
  result = (BMXUserProfileMessageSetting *)new BMXUserProfileMessageSetting();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXUserProfileMessageSetting_mPushEnabled_set(void* imarg1, BOOL imarg2) {
  BMXUserProfileMessageSetting *arg1 = (BMXUserProfileMessageSetting *) 0 ;
  bool arg2 ;
  
  arg1 = (BMXUserProfileMessageSetting *)imarg1; 
  arg2 = imarg2? true : false; 
  if (arg1) (arg1)->mPushEnabled = arg2;
}

BOOL _wrap_BMXUserProfileMessageSetting_mPushEnabled_get(void* imarg1) {
  BMXUserProfileMessageSetting *arg1 = (BMXUserProfileMessageSetting *) 0 ;
  BOOL imresult = 0 ;
  bool result;
  
  arg1 = (BMXUserProfileMessageSetting *)imarg1; 
  result = (bool) ((arg1)->mPushEnabled);
  imresult = (result)? YES:NO; 
  return imresult;
}

void _wrap_BMXUserProfileMessageSetting_mPushDetail_set(void* imarg1, BOOL imarg2) {
  BMXUserProfileMessageSetting *arg1 = (BMXUserProfileMessageSetting *) 0 ;
  bool arg2 ;
  
  arg1 = (BMXUserProfileMessageSetting *)imarg1; 
  arg2 = imarg2? true : false; 
  if (arg1) (arg1)->mPushDetail = arg2;
}

BOOL _wrap_BMXUserProfileMessageSetting_mPushDetail_get(void* imarg1) {
  BMXUserProfileMessageSetting *arg1 = (BMXUserProfileMessageSetting *) 0 ;
  BOOL imresult = 0 ;
  bool result;
  
  arg1 = (BMXUserProfileMessageSetting *)imarg1; 
  result = (bool) ((arg1)->mPushDetail);
  imresult = (result)? YES:NO; 
  return imresult;
}

void _wrap_BMXUserProfileMessageSetting_mPushNickname_set(void* imarg1, NSString* imarg2) {
  BMXUserProfileMessageSetting *arg1 = (BMXUserProfileMessageSetting *) 0 ;
  std::string *arg2 = 0 ;
  
  arg1 = (BMXUserProfileMessageSetting *)imarg1; 
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  if (arg1) (arg1)->mPushNickname = *arg2;
}

NSString* _wrap_BMXUserProfileMessageSetting_mPushNickname_get(void* imarg1) {
  BMXUserProfileMessageSetting *arg1 = (BMXUserProfileMessageSetting *) 0 ;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  arg1 = (BMXUserProfileMessageSetting *)imarg1; 
  result = (std::string *) & ((arg1)->mPushNickname);
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXUserProfileMessageSetting_mNotificationSound_set(void* imarg1, BOOL imarg2) {
  BMXUserProfileMessageSetting *arg1 = (BMXUserProfileMessageSetting *) 0 ;
  bool arg2 ;
  
  arg1 = (BMXUserProfileMessageSetting *)imarg1; 
  arg2 = imarg2? true : false; 
  if (arg1) (arg1)->mNotificationSound = arg2;
}

BOOL _wrap_BMXUserProfileMessageSetting_mNotificationSound_get(void* imarg1) {
  BMXUserProfileMessageSetting *arg1 = (BMXUserProfileMessageSetting *) 0 ;
  BOOL imresult = 0 ;
  bool result;
  
  arg1 = (BMXUserProfileMessageSetting *)imarg1; 
  result = (bool) ((arg1)->mNotificationSound);
  imresult = (result)? YES:NO; 
  return imresult;
}

void _wrap_BMXUserProfileMessageSetting_mNotificationVibrate_set(void* imarg1, BOOL imarg2) {
  BMXUserProfileMessageSetting *arg1 = (BMXUserProfileMessageSetting *) 0 ;
  bool arg2 ;
  
  arg1 = (BMXUserProfileMessageSetting *)imarg1; 
  arg2 = imarg2? true : false; 
  if (arg1) (arg1)->mNotificationVibrate = arg2;
}

BOOL _wrap_BMXUserProfileMessageSetting_mNotificationVibrate_get(void* imarg1) {
  BMXUserProfileMessageSetting *arg1 = (BMXUserProfileMessageSetting *) 0 ;
  BOOL imresult = 0 ;
  bool result;
  
  arg1 = (BMXUserProfileMessageSetting *)imarg1; 
  result = (bool) ((arg1)->mNotificationVibrate);
  imresult = (result)? YES:NO; 
  return imresult;
}

void _wrap_BMXUserProfileMessageSetting_mAutoDownloadAttachment_set(void* imarg1, BOOL imarg2) {
  BMXUserProfileMessageSetting *arg1 = (BMXUserProfileMessageSetting *) 0 ;
  bool arg2 ;
  
  arg1 = (BMXUserProfileMessageSetting *)imarg1; 
  arg2 = imarg2? true : false; 
  if (arg1) (arg1)->mAutoDownloadAttachment = arg2;
}

BOOL _wrap_BMXUserProfileMessageSetting_mAutoDownloadAttachment_get(void* imarg1) {
  BMXUserProfileMessageSetting *arg1 = (BMXUserProfileMessageSetting *) 0 ;
  BOOL imresult = 0 ;
  bool result;
  
  arg1 = (BMXUserProfileMessageSetting *)imarg1; 
  result = (bool) ((arg1)->mAutoDownloadAttachment);
  imresult = (result)? YES:NO; 
  return imresult;
}

void _wrap_BMXUserProfileMessageSetting_mSilenceStartTime_set(void* imarg1, int imarg2) {
  BMXUserProfileMessageSetting *arg1 = (BMXUserProfileMessageSetting *) 0 ;
  int arg2 ;
  
  arg1 = (BMXUserProfileMessageSetting *)imarg1; 
  arg2 = (int)imarg2; 
  if (arg1) (arg1)->mSilenceStartTime = arg2;
}

int _wrap_BMXUserProfileMessageSetting_mSilenceStartTime_get(void* imarg1) {
  BMXUserProfileMessageSetting *arg1 = (BMXUserProfileMessageSetting *) 0 ;
  int imresult = 0 ;
  int result;
  
  arg1 = (BMXUserProfileMessageSetting *)imarg1; 
  result = (int) ((arg1)->mSilenceStartTime);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXUserProfileMessageSetting_mSilenceEndTime_set(void* imarg1, int imarg2) {
  BMXUserProfileMessageSetting *arg1 = (BMXUserProfileMessageSetting *) 0 ;
  int arg2 ;
  
  arg1 = (BMXUserProfileMessageSetting *)imarg1; 
  arg2 = (int)imarg2; 
  if (arg1) (arg1)->mSilenceEndTime = arg2;
}

int _wrap_BMXUserProfileMessageSetting_mSilenceEndTime_get(void* imarg1) {
  BMXUserProfileMessageSetting *arg1 = (BMXUserProfileMessageSetting *) 0 ;
  int imresult = 0 ;
  int result;
  
  arg1 = (BMXUserProfileMessageSetting *)imarg1; 
  result = (int) ((arg1)->mSilenceEndTime);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXUserProfileMessageSetting_mPushStartTime_set(void* imarg1, int imarg2) {
  BMXUserProfileMessageSetting *arg1 = (BMXUserProfileMessageSetting *) 0 ;
  int arg2 ;
  
  arg1 = (BMXUserProfileMessageSetting *)imarg1; 
  arg2 = (int)imarg2; 
  if (arg1) (arg1)->mPushStartTime = arg2;
}

int _wrap_BMXUserProfileMessageSetting_mPushStartTime_get(void* imarg1) {
  BMXUserProfileMessageSetting *arg1 = (BMXUserProfileMessageSetting *) 0 ;
  int imresult = 0 ;
  int result;
  
  arg1 = (BMXUserProfileMessageSetting *)imarg1; 
  result = (int) ((arg1)->mPushStartTime);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXUserProfileMessageSetting_mPushEndTime_set(void* imarg1, int imarg2) {
  BMXUserProfileMessageSetting *arg1 = (BMXUserProfileMessageSetting *) 0 ;
  int arg2 ;
  
  arg1 = (BMXUserProfileMessageSetting *)imarg1; 
  arg2 = (int)imarg2; 
  if (arg1) (arg1)->mPushEndTime = arg2;
}

int _wrap_BMXUserProfileMessageSetting_mPushEndTime_get(void* imarg1) {
  BMXUserProfileMessageSetting *arg1 = (BMXUserProfileMessageSetting *) 0 ;
  int imresult = 0 ;
  int result;
  
  arg1 = (BMXUserProfileMessageSetting *)imarg1; 
  result = (int) ((arg1)->mPushEndTime);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_delete_BMXUserProfileMessageSetting(void* imarg1) {
  BMXUserProfileMessageSetting *arg1 = (BMXUserProfileMessageSetting *) 0 ;
  
  arg1 = (BMXUserProfileMessageSetting *)imarg1; 
  delete arg1;
}

void* _wrap_new_BMXRoomCreateOptions__SWIG_0(int imarg1, NSString* imarg2, NSString* imarg3, NSString* imarg4, BOOL imarg5, BOOL imarg6) {
  int arg1 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  bool arg5 ;
  bool arg6 ;
  void* imresult = 0 ;
  floo::BMXRTCSignalService::BMXRoomCreateOptions *result = 0 ;
  
  arg1 = (int)imarg1;
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str;
  
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str;
  
  if(!imarg4) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg4_str(getStdString(imarg4));
  arg4 = &arg4_str;
  
  arg5 = imarg5? true : false;
  arg6 = imarg6? true : false;
  result = (floo::BMXRTCSignalService::BMXRoomCreateOptions *)new floo::BMXRTCSignalService::BMXRoomCreateOptions(arg1,(std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4,arg5,arg6);
  BMXRoomCreateOptions2Void(result)
  imresult = (void*)lresult;
  return imresult;
}

void* _wrap_new_BMXRoomCreateOptions__SWIG_1(int imarg1, NSString* imarg2, NSString* imarg3, NSString* imarg4, BOOL imarg5) {
  int arg1 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  bool arg5 ;
  void* imresult = 0 ;
  floo::BMXRTCSignalService::BMXRoomCreateOptions *result = 0 ;
  
  arg1 = (int)imarg1;
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str;
  
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str;
  
  if(!imarg4) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg4_str(getStdString(imarg4));
  arg4 = &arg4_str;
  
  arg5 = imarg5? true : false;
  result = (floo::BMXRTCSignalService::BMXRoomCreateOptions *)new floo::BMXRTCSignalService::BMXRoomCreateOptions(arg1,(std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4,arg5);
  BMXRoomCreateOptions2Void(result)
  imresult = (void*)lresult;
  return imresult;
}

void* _wrap_new_BMXRoomCreateOptions__SWIG_2(int imarg1, NSString* imarg2, NSString* imarg3, NSString* imarg4) {
  int arg1 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  void* imresult = 0 ;
  floo::BMXRTCSignalService::BMXRoomCreateOptions *result = 0 ;
  
  arg1 = (int)imarg1;
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str;
  
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str;
  
  if(!imarg4) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg4_str(getStdString(imarg4));
  arg4 = &arg4_str;
  
  result = (floo::BMXRTCSignalService::BMXRoomCreateOptions *)new floo::BMXRTCSignalService::BMXRoomCreateOptions(arg1,(std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4);
  BMXRoomCreateOptions2Void(result)
  imresult = (void*)lresult;
  return imresult;
}

void* _wrap_new_BMXRoomCreateOptions__SWIG_3(int imarg1, NSString* imarg2, NSString* imarg3) {
  int arg1 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void* imresult = 0 ;
  floo::BMXRTCSignalService::BMXRoomCreateOptions *result = 0 ;
  
  arg1 = (int)imarg1;
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str;
  
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str;
  
  result = (floo::BMXRTCSignalService::BMXRoomCreateOptions *)new floo::BMXRTCSignalService::BMXRoomCreateOptions(arg1,(std::string const &)*arg2,(std::string const &)*arg3);
  BMXRoomCreateOptions2Void(result)
  imresult = (void*)lresult;
  return imresult;
}

void* _wrap_new_BMXRoomCreateOptions__SWIG_4(int imarg1, NSString* imarg2) {
  int arg1 ;
  std::string *arg2 = 0 ;
  void* imresult = 0 ;
  floo::BMXRTCSignalService::BMXRoomCreateOptions *result = 0 ;
  
  arg1 = (int)imarg1;
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str;
  
  result = (floo::BMXRTCSignalService::BMXRoomCreateOptions *)new floo::BMXRTCSignalService::BMXRoomCreateOptions(arg1,(std::string const &)*arg2);
  BMXRoomCreateOptions2Void(result)
  imresult = (void*)lresult;
  return imresult;
}

void* _wrap_new_BMXRoomCreateOptions__SWIG_5(int imarg1) {
  int arg1 ;
  void* imresult = 0 ;
  floo::BMXRTCSignalService::BMXRoomCreateOptions *result = 0 ;
  
  arg1 = (int)imarg1;
  result = (floo::BMXRTCSignalService::BMXRoomCreateOptions *)new floo::BMXRTCSignalService::BMXRoomCreateOptions(arg1);
  BMXRoomCreateOptions2Void(result)
  imresult = (void*)lresult;
  return imresult;
}

void* _wrap_new_BMXRoomCreateOptions__SWIG_6() {
  void* imresult = 0 ;
  floo::BMXRTCSignalService::BMXRoomCreateOptions *result = 0 ;
  
  result = (floo::BMXRTCSignalService::BMXRoomCreateOptions *)new floo::BMXRTCSignalService::BMXRoomCreateOptions();
  BMXRoomCreateOptions2Void(result)
  imresult = (void*)lresult;
  return imresult;
}

void _wrap_BMXRoomCreateOptions_mRoomId_set(void* imarg1, long long imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXRoomCreateOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXRoomCreateOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXRoomCreateOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int64_t arg2 ;
  
  arg2 = (int64_t)imarg2;
  if (arg1) (arg1)->mRoomId = arg2;
}

long long _wrap_BMXRoomCreateOptions_mRoomId_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXRoomCreateOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXRoomCreateOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXRoomCreateOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  long long imresult = 0 ;
  int64_t result;
  
  result = (int64_t) ((arg1)->mRoomId);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_BMXRoomCreateOptions_mDescription_set(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXRoomCreateOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXRoomCreateOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXRoomCreateOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str;
  
  if (arg1) (arg1)->mDescription = *arg2;
}

NSString* _wrap_BMXRoomCreateOptions_mDescription_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXRoomCreateOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXRoomCreateOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXRoomCreateOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) & ((arg1)->mDescription);
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXRoomCreateOptions_mSecret_set(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXRoomCreateOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXRoomCreateOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXRoomCreateOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str;
  
  if (arg1) (arg1)->mSecret = *arg2;
}

NSString* _wrap_BMXRoomCreateOptions_mSecret_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXRoomCreateOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXRoomCreateOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXRoomCreateOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) & ((arg1)->mSecret);
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXRoomCreateOptions_mPin_set(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXRoomCreateOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXRoomCreateOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXRoomCreateOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str;
  
  if (arg1) (arg1)->mPin = *arg2;
}

NSString* _wrap_BMXRoomCreateOptions_mPin_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXRoomCreateOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXRoomCreateOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXRoomCreateOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) & ((arg1)->mPin);
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXRoomCreateOptions_mIsPermanent_set(void* imarg1, BOOL imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXRoomCreateOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXRoomCreateOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXRoomCreateOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  bool arg2 ;
  
  arg2 = imarg2? true : false;
  if (arg1) (arg1)->mIsPermanent = arg2;
}

BOOL _wrap_BMXRoomCreateOptions_mIsPermanent_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXRoomCreateOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXRoomCreateOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXRoomCreateOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BOOL imresult = 0 ;
  bool result;
  
  result = (bool) ((arg1)->mIsPermanent);
  imresult = (result)? YES:NO;
  return imresult;
}

void _wrap_BMXRoomCreateOptions_mIsPrivate_set(void* imarg1, BOOL imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXRoomCreateOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXRoomCreateOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXRoomCreateOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  bool arg2 ;
  
  arg2 = imarg2? true : false;
  if (arg1) (arg1)->mIsPrivate = arg2;
}

BOOL _wrap_BMXRoomCreateOptions_mIsPrivate_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXRoomCreateOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXRoomCreateOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXRoomCreateOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BOOL imresult = 0 ;
  bool result;
  
  result = (bool) ((arg1)->mIsPrivate);
  imresult = (result)? YES:NO;
  return imresult;
}

void _wrap_delete_BMXRoomCreateOptions(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXRoomCreateOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXRoomCreateOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXRoomCreateOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  
  delete argp1;
}

void* _wrap_new_BMXRoomEditOptions__SWIG_0(NSString* imarg1, NSString* imarg2, NSString* imarg3, BOOL imarg4, BOOL imarg5) {
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  bool arg4 ;
  bool arg5 ;
  void* imresult = 0 ;
  floo::BMXRTCSignalService::BMXRoomEditOptions *result = 0 ;
  
  if(!imarg1) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg1_str(getStdString(imarg1));
  arg1 = &arg1_str;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str;
  
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str;
  
  arg4 = imarg4? true : false;
  arg5 = imarg5? true : false;
  result = (floo::BMXRTCSignalService::BMXRoomEditOptions *)new floo::BMXRTCSignalService::BMXRoomEditOptions((std::string const &)*arg1,(std::string const &)*arg2,(std::string const &)*arg3,arg4,arg5);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void* _wrap_new_BMXRoomEditOptions__SWIG_1(NSString* imarg1, NSString* imarg2, NSString* imarg3, BOOL imarg4) {
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  bool arg4 ;
  void* imresult = 0 ;
  floo::BMXRTCSignalService::BMXRoomEditOptions *result = 0 ;
  
  if(!imarg1) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg1_str(getStdString(imarg1));
  arg1 = &arg1_str;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str;
  
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str;
  
  arg4 = imarg4? true : false;
  result = (floo::BMXRTCSignalService::BMXRoomEditOptions *)new floo::BMXRTCSignalService::BMXRoomEditOptions((std::string const &)*arg1,(std::string const &)*arg2,(std::string const &)*arg3,arg4);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void* _wrap_new_BMXRoomEditOptions__SWIG_2(NSString* imarg1, NSString* imarg2, NSString* imarg3) {
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void* imresult = 0 ;
  floo::BMXRTCSignalService::BMXRoomEditOptions *result = 0 ;
  
  if(!imarg1) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg1_str(getStdString(imarg1));
  arg1 = &arg1_str;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str;
  
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str;
  
  result = (floo::BMXRTCSignalService::BMXRoomEditOptions *)new floo::BMXRTCSignalService::BMXRoomEditOptions((std::string const &)*arg1,(std::string const &)*arg2,(std::string const &)*arg3);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void* _wrap_new_BMXRoomEditOptions__SWIG_3(NSString* imarg1, NSString* imarg2) {
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  void* imresult = 0 ;
  floo::BMXRTCSignalService::BMXRoomEditOptions *result = 0 ;
  
  if(!imarg1) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg1_str(getStdString(imarg1));
  arg1 = &arg1_str;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str;
  
  result = (floo::BMXRTCSignalService::BMXRoomEditOptions *)new floo::BMXRTCSignalService::BMXRoomEditOptions((std::string const &)*arg1,(std::string const &)*arg2);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void* _wrap_new_BMXRoomEditOptions__SWIG_4(NSString* imarg1) {
  std::string *arg1 = 0 ;
  void* imresult = 0 ;
  floo::BMXRTCSignalService::BMXRoomEditOptions *result = 0 ;
  
  if(!imarg1) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg1_str(getStdString(imarg1));
  arg1 = &arg1_str;
  
  result = (floo::BMXRTCSignalService::BMXRoomEditOptions *)new floo::BMXRTCSignalService::BMXRoomEditOptions((std::string const &)*arg1);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void* _wrap_new_BMXRoomEditOptions__SWIG_5() {
  void* imresult = 0 ;
  floo::BMXRTCSignalService::BMXRoomEditOptions *result = 0 ;
  
  result = (floo::BMXRTCSignalService::BMXRoomEditOptions *)new floo::BMXRTCSignalService::BMXRoomEditOptions();
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_BMXRoomEditOptions_mNewDescription_set(void* imarg1, NSString* imarg2) {
  floo::BMXRTCSignalService::BMXRoomEditOptions *arg1 = (floo::BMXRTCSignalService::BMXRoomEditOptions *) 0 ;
  std::string *arg2 = 0 ;
  
  arg1 = (floo::BMXRTCSignalService::BMXRoomEditOptions *)imarg1;
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str;
  
  if (arg1) (arg1)->mNewDescription = *arg2;
}

NSString* _wrap_BMXRoomEditOptions_mNewDescription_get(void* imarg1) {
  floo::BMXRTCSignalService::BMXRoomEditOptions *arg1 = (floo::BMXRTCSignalService::BMXRoomEditOptions *) 0 ;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  arg1 = (floo::BMXRTCSignalService::BMXRoomEditOptions *)imarg1;
  result = (std::string *) & ((arg1)->mNewDescription);
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXRoomEditOptions_mNewSecret_set(void* imarg1, NSString* imarg2) {
  floo::BMXRTCSignalService::BMXRoomEditOptions *arg1 = (floo::BMXRTCSignalService::BMXRoomEditOptions *) 0 ;
  std::string *arg2 = 0 ;
  
  arg1 = (floo::BMXRTCSignalService::BMXRoomEditOptions *)imarg1;
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str;
  
  if (arg1) (arg1)->mNewSecret = *arg2;
}

NSString* _wrap_BMXRoomEditOptions_mNewSecret_get(void* imarg1) {
  floo::BMXRTCSignalService::BMXRoomEditOptions *arg1 = (floo::BMXRTCSignalService::BMXRoomEditOptions *) 0 ;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  arg1 = (floo::BMXRTCSignalService::BMXRoomEditOptions *)imarg1;
  result = (std::string *) & ((arg1)->mNewSecret);
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXRoomEditOptions_mNewPin_set(void* imarg1, NSString* imarg2) {
  floo::BMXRTCSignalService::BMXRoomEditOptions *arg1 = (floo::BMXRTCSignalService::BMXRoomEditOptions *) 0 ;
  std::string *arg2 = 0 ;
  
  arg1 = (floo::BMXRTCSignalService::BMXRoomEditOptions *)imarg1;
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str;
  
  if (arg1) (arg1)->mNewPin = *arg2;
}

NSString* _wrap_BMXRoomEditOptions_mNewPin_get(void* imarg1) {
  floo::BMXRTCSignalService::BMXRoomEditOptions *arg1 = (floo::BMXRTCSignalService::BMXRoomEditOptions *) 0 ;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  arg1 = (floo::BMXRTCSignalService::BMXRoomEditOptions *)imarg1;
  result = (std::string *) & ((arg1)->mNewPin);
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXRoomEditOptions_mNewIsPermanent_set(void* imarg1, BOOL imarg2) {
  floo::BMXRTCSignalService::BMXRoomEditOptions *arg1 = (floo::BMXRTCSignalService::BMXRoomEditOptions *) 0 ;
  bool arg2 ;
  
  arg1 = (floo::BMXRTCSignalService::BMXRoomEditOptions *)imarg1;
  arg2 = imarg2? true : false;
  if (arg1) (arg1)->mNewIsPermanent = arg2;
}

BOOL _wrap_BMXRoomEditOptions_mNewIsPermanent_get(void* imarg1) {
  floo::BMXRTCSignalService::BMXRoomEditOptions *arg1 = (floo::BMXRTCSignalService::BMXRoomEditOptions *) 0 ;
  BOOL imresult = 0 ;
  bool result;
  
  arg1 = (floo::BMXRTCSignalService::BMXRoomEditOptions *)imarg1;
  result = (bool) ((arg1)->mNewIsPermanent);
  imresult = (result)? YES:NO;
  return imresult;
}

void _wrap_BMXRoomEditOptions_mNewIsPrivate_set(void* imarg1, BOOL imarg2) {
  floo::BMXRTCSignalService::BMXRoomEditOptions *arg1 = (floo::BMXRTCSignalService::BMXRoomEditOptions *) 0 ;
  bool arg2 ;
  
  arg1 = (floo::BMXRTCSignalService::BMXRoomEditOptions *)imarg1;
  arg2 = imarg2? true : false;
  if (arg1) (arg1)->mNewIsPrivate = arg2;
}

BOOL _wrap_BMXRoomEditOptions_mNewIsPrivate_get(void* imarg1) {
  floo::BMXRTCSignalService::BMXRoomEditOptions *arg1 = (floo::BMXRTCSignalService::BMXRoomEditOptions *) 0 ;
  BOOL imresult = 0 ;
  bool result;
  
  arg1 = (floo::BMXRTCSignalService::BMXRoomEditOptions *)imarg1;
  result = (bool) ((arg1)->mNewIsPrivate);
  imresult = (result)? YES:NO;
  return imresult;
}

void _wrap_delete_BMXRoomEditOptions(void* imarg1) {
  floo::BMXRTCSignalService::BMXRoomEditOptions *arg1 = (floo::BMXRTCSignalService::BMXRoomEditOptions *) 0 ;
  
  arg1 = (floo::BMXRTCSignalService::BMXRoomEditOptions *)imarg1;
  delete arg1;
}

void* _wrap_new_BMXRoomAllowdOptions() {
  void* imresult = 0 ;
  floo::BMXRTCSignalService::BMXRoomAllowdOptions *result = 0 ;
  
  result = (floo::BMXRTCSignalService::BMXRoomAllowdOptions *)new floo::BMXRTCSignalService::BMXRoomAllowdOptions();
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_BMXRoomAllowdOptions_action_set(void* imarg1, int imarg2) {
  floo::BMXRTCSignalService::BMXRoomAllowdOptions *arg1 = (floo::BMXRTCSignalService::BMXRoomAllowdOptions *) 0 ;
  floo::BMXRTCSignalService::AllowedAction arg2 ;
  
  arg1 = (floo::BMXRTCSignalService::BMXRoomAllowdOptions *)imarg1;
  arg2 = (floo::BMXRTCSignalService::AllowedAction)imarg2;
  if (arg1) (arg1)->action = arg2;
}

int _wrap_BMXRoomAllowdOptions_action_get(void* imarg1) {
  floo::BMXRTCSignalService::BMXRoomAllowdOptions *arg1 = (floo::BMXRTCSignalService::BMXRoomAllowdOptions *) 0 ;
  int imresult = 0 ;
  floo::BMXRTCSignalService::AllowedAction result;
  
  arg1 = (floo::BMXRTCSignalService::BMXRoomAllowdOptions *)imarg1;
  result = (floo::BMXRTCSignalService::AllowedAction) ((arg1)->action);
  imresult = (int)result;
  return imresult;
}

void _wrap_BMXRoomAllowdOptions_tokens_set(void* imarg1, void* imarg2) {
  floo::BMXRTCSignalService::BMXRoomAllowdOptions *arg1 = (floo::BMXRTCSignalService::BMXRoomAllowdOptions *) 0 ;
  std::vector< std::string > *arg2 = (std::vector< std::string > *) 0 ;
  
  arg1 = (floo::BMXRTCSignalService::BMXRoomAllowdOptions *)imarg1;
  arg2 = (std::vector< std::string > *)imarg2;
  if (arg1) (arg1)->tokens = *arg2;
}

void* _wrap_BMXRoomAllowdOptions_tokens_get(void* imarg1) {
  floo::BMXRTCSignalService::BMXRoomAllowdOptions *arg1 = (floo::BMXRTCSignalService::BMXRoomAllowdOptions *) 0 ;
  void* imresult = 0 ;
  std::vector< std::string > *result = 0 ;
  
  arg1 = (floo::BMXRTCSignalService::BMXRoomAllowdOptions *)imarg1;
  result = (std::vector< std::string > *)& ((arg1)->tokens);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_delete_BMXRoomAllowdOptions(void* imarg1) {
  floo::BMXRTCSignalService::BMXRoomAllowdOptions *arg1 = (floo::BMXRTCSignalService::BMXRoomAllowdOptions *) 0 ;
  
  arg1 = (floo::BMXRTCSignalService::BMXRoomAllowdOptions *)imarg1;
  delete arg1;
}

void* _wrap_new_BMXRoomModerateOptions__SWIG_0() {
  void* imresult = 0 ;
  floo::BMXRTCSignalService::BMXRoomModerateOptions *result = 0 ;
  
  result = (floo::BMXRTCSignalService::BMXRoomModerateOptions *)new floo::BMXRTCSignalService::BMXRoomModerateOptions();
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void* _wrap_new_BMXRoomModerateOptions__SWIG_1(long long imarg1, BOOL imarg2, BOOL imarg3, BOOL imarg4) {
  int64_t arg1 ;
  bool arg2 ;
  bool arg3 ;
  bool arg4 ;
  void* imresult = 0 ;
  floo::BMXRTCSignalService::BMXRoomModerateOptions *result = 0 ;
  
  arg1 = (int64_t)imarg1;
  arg2 = imarg2? true : false;
  arg3 = imarg3? true : false;
  arg4 = imarg4? true : false;
  result = (floo::BMXRTCSignalService::BMXRoomModerateOptions *)new floo::BMXRTCSignalService::BMXRoomModerateOptions(arg1,arg2,arg3,arg4);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void* _wrap_new_BMXRoomModerateOptions__SWIG_2(long long imarg1, BOOL imarg2, BOOL imarg3) {
  int64_t arg1 ;
  bool arg2 ;
  bool arg3 ;
  void* imresult = 0 ;
  floo::BMXRTCSignalService::BMXRoomModerateOptions *result = 0 ;
  
  arg1 = (int64_t)imarg1;
  arg2 = imarg2? true : false;
  arg3 = imarg3? true : false;
  result = (floo::BMXRTCSignalService::BMXRoomModerateOptions *)new floo::BMXRTCSignalService::BMXRoomModerateOptions(arg1,arg2,arg3);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void* _wrap_new_BMXRoomModerateOptions__SWIG_3(long long imarg1, BOOL imarg2) {
  int64_t arg1 ;
  bool arg2 ;
  void* imresult = 0 ;
  floo::BMXRTCSignalService::BMXRoomModerateOptions *result = 0 ;
  
  arg1 = (int64_t)imarg1;
  arg2 = imarg2? true : false;
  result = (floo::BMXRTCSignalService::BMXRoomModerateOptions *)new floo::BMXRTCSignalService::BMXRoomModerateOptions(arg1,arg2);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void* _wrap_new_BMXRoomModerateOptions__SWIG_4(long long imarg1) {
  int64_t arg1 ;
  void* imresult = 0 ;
  floo::BMXRTCSignalService::BMXRoomModerateOptions *result = 0 ;
  
  arg1 = (int64_t)imarg1;
  result = (floo::BMXRTCSignalService::BMXRoomModerateOptions *)new floo::BMXRTCSignalService::BMXRoomModerateOptions(arg1);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_BMXRoomModerateOptions_mUserId_set(void* imarg1, long long imarg2) {
  floo::BMXRTCSignalService::BMXRoomModerateOptions *arg1 = (floo::BMXRTCSignalService::BMXRoomModerateOptions *) 0 ;
  int64_t arg2 ;
  
  arg1 = (floo::BMXRTCSignalService::BMXRoomModerateOptions *)imarg1;
  arg2 = (int64_t)imarg2;
  if (arg1) (arg1)->mUserId = arg2;
}

long long _wrap_BMXRoomModerateOptions_mUserId_get(void* imarg1) {
  floo::BMXRTCSignalService::BMXRoomModerateOptions *arg1 = (floo::BMXRTCSignalService::BMXRoomModerateOptions *) 0 ;
  long long imresult = 0 ;
  int64_t result;
  
  arg1 = (floo::BMXRTCSignalService::BMXRoomModerateOptions *)imarg1;
  result = (int64_t) ((arg1)->mUserId);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_BMXRoomModerateOptions_mMuteAudio_set(void* imarg1, BOOL imarg2) {
  floo::BMXRTCSignalService::BMXRoomModerateOptions *arg1 = (floo::BMXRTCSignalService::BMXRoomModerateOptions *) 0 ;
  bool arg2 ;
  
  arg1 = (floo::BMXRTCSignalService::BMXRoomModerateOptions *)imarg1;
  arg2 = imarg2? true : false;
  if (arg1) (arg1)->mMuteAudio = arg2;
}

BOOL _wrap_BMXRoomModerateOptions_mMuteAudio_get(void* imarg1) {
  floo::BMXRTCSignalService::BMXRoomModerateOptions *arg1 = (floo::BMXRTCSignalService::BMXRoomModerateOptions *) 0 ;
  BOOL imresult = 0 ;
  bool result;
  
  arg1 = (floo::BMXRTCSignalService::BMXRoomModerateOptions *)imarg1;
  result = (bool) ((arg1)->mMuteAudio);
  imresult = (result)? YES:NO;
  return imresult;
}

void _wrap_BMXRoomModerateOptions_mMuteVideo_set(void* imarg1, BOOL imarg2) {
  floo::BMXRTCSignalService::BMXRoomModerateOptions *arg1 = (floo::BMXRTCSignalService::BMXRoomModerateOptions *) 0 ;
  bool arg2 ;
  
  arg1 = (floo::BMXRTCSignalService::BMXRoomModerateOptions *)imarg1;
  arg2 = imarg2? true : false;
  if (arg1) (arg1)->mMuteVideo = arg2;
}

BOOL _wrap_BMXRoomModerateOptions_mMuteVideo_get(void* imarg1) {
  floo::BMXRTCSignalService::BMXRoomModerateOptions *arg1 = (floo::BMXRTCSignalService::BMXRoomModerateOptions *) 0 ;
  BOOL imresult = 0 ;
  bool result;
  
  arg1 = (floo::BMXRTCSignalService::BMXRoomModerateOptions *)imarg1;
  result = (bool) ((arg1)->mMuteVideo);
  imresult = (result)? YES:NO;
  return imresult;
}

void _wrap_BMXRoomModerateOptions_mMuteData_set(void* imarg1, BOOL imarg2) {
  floo::BMXRTCSignalService::BMXRoomModerateOptions *arg1 = (floo::BMXRTCSignalService::BMXRoomModerateOptions *) 0 ;
  bool arg2 ;
  
  arg1 = (floo::BMXRTCSignalService::BMXRoomModerateOptions *)imarg1;
  arg2 = imarg2? true : false;
  if (arg1) (arg1)->mMuteData = arg2;
}

BOOL _wrap_BMXRoomModerateOptions_mMuteData_get(void* imarg1) {
  floo::BMXRTCSignalService::BMXRoomModerateOptions *arg1 = (floo::BMXRTCSignalService::BMXRoomModerateOptions *) 0 ;
  BOOL imresult = 0 ;
  bool result;
  
  arg1 = (floo::BMXRTCSignalService::BMXRoomModerateOptions *)imarg1;
  result = (bool) ((arg1)->mMuteData);
  imresult = (result)? YES:NO;
  return imresult;
}

void _wrap_delete_BMXRoomModerateOptions(void* imarg1) {
  floo::BMXRTCSignalService::BMXRoomModerateOptions *arg1 = (floo::BMXRTCSignalService::BMXRoomModerateOptions *) 0 ;
  
  arg1 = (floo::BMXRTCSignalService::BMXRoomModerateOptions *)imarg1;
  delete arg1;
}

void* _wrap_new_BMXPubRoomJoinOptions__SWIG_0() {
  void* imresult = 0 ;
  floo::BMXRTCSignalService::BMXPubRoomJoinOptions *result = 0 ;
  
  result = (floo::BMXRTCSignalService::BMXPubRoomJoinOptions *)new floo::BMXRTCSignalService::BMXPubRoomJoinOptions();
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void* _wrap_new_BMXPubRoomJoinOptions__SWIG_1(long long imarg1, long long imarg2, NSString* imarg3, NSString* imarg4, NSString* imarg5) {
  int64_t arg1 ;
  int64_t arg2 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  std::string *arg5 = 0 ;
  void* imresult = 0 ;
  floo::BMXRTCSignalService::BMXPubRoomJoinOptions *result = 0 ;
  
  arg1 = (int64_t)imarg1;
  arg2 = (int64_t)imarg2;
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str;
  
  if(!imarg4) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg4_str(getStdString(imarg4));
  arg4 = &arg4_str;
  
  if(!imarg5) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg5_str(getStdString(imarg5));
  arg5 = &arg5_str;
  
  result = (floo::BMXRTCSignalService::BMXPubRoomJoinOptions *)new floo::BMXRTCSignalService::BMXPubRoomJoinOptions(arg1,arg2,(std::string const &)*arg3,(std::string const &)*arg4,(std::string const &)*arg5);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void* _wrap_new_BMXPubRoomJoinOptions__SWIG_2(long long imarg1, long long imarg2, NSString* imarg3, NSString* imarg4) {
  int64_t arg1 ;
  int64_t arg2 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  void* imresult = 0 ;
  floo::BMXRTCSignalService::BMXPubRoomJoinOptions *result = 0 ;
  
  arg1 = (int64_t)imarg1;
  arg2 = (int64_t)imarg2;
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str;
  
  if(!imarg4) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg4_str(getStdString(imarg4));
  arg4 = &arg4_str;
  
  result = (floo::BMXRTCSignalService::BMXPubRoomJoinOptions *)new floo::BMXRTCSignalService::BMXPubRoomJoinOptions(arg1,arg2,(std::string const &)*arg3,(std::string const &)*arg4);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void* _wrap_new_BMXPubRoomJoinOptions__SWIG_3(long long imarg1, long long imarg2, NSString* imarg3) {
  int64_t arg1 ;
  int64_t arg2 ;
  std::string *arg3 = 0 ;
  void* imresult = 0 ;
  floo::BMXRTCSignalService::BMXPubRoomJoinOptions *result = 0 ;
  
  arg1 = (int64_t)imarg1;
  arg2 = (int64_t)imarg2;
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str;
  
  result = (floo::BMXRTCSignalService::BMXPubRoomJoinOptions *)new floo::BMXRTCSignalService::BMXPubRoomJoinOptions(arg1,arg2,(std::string const &)*arg3);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void* _wrap_new_BMXPubRoomJoinOptions__SWIG_4(long long imarg1, long long imarg2) {
  int64_t arg1 ;
  int64_t arg2 ;
  void* imresult = 0 ;
  floo::BMXRTCSignalService::BMXPubRoomJoinOptions *result = 0 ;
  
  arg1 = (int64_t)imarg1;
  arg2 = (int64_t)imarg2;
  result = (floo::BMXRTCSignalService::BMXPubRoomJoinOptions *)new floo::BMXRTCSignalService::BMXPubRoomJoinOptions(arg1,arg2);
  BMXPubRoomJoinOptions2Void(result)
  imresult = (void*)lresult;

  return imresult;
}

void _wrap_BMXPubRoomJoinOptions_mUserId_set(void* imarg1, long long imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXPubRoomJoinOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXPubRoomJoinOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXPubRoomJoinOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int64_t arg2 ;
  
  arg2 = (int64_t)imarg2;
  if (arg1) (arg1)->mUserId = arg2;
}

long long _wrap_BMXPubRoomJoinOptions_mUserId_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXPubRoomJoinOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXPubRoomJoinOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXPubRoomJoinOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  long long imresult = 0 ;
  int64_t result;
  
  result = (int64_t) ((arg1)->mUserId);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_BMXPubRoomJoinOptions_mRoomId_set(void* imarg1, long long imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXPubRoomJoinOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXPubRoomJoinOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXPubRoomJoinOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int64_t arg2 ;
  
  arg2 = (int64_t)imarg2;
  if (arg1) (arg1)->mRoomId = arg2;
}

long long _wrap_BMXPubRoomJoinOptions_mRoomId_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXPubRoomJoinOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXPubRoomJoinOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXPubRoomJoinOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  long long imresult = 0 ;
  int64_t result;
  
  result = (int64_t) ((arg1)->mRoomId);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_BMXPubRoomJoinOptions_mRoomPin_set(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXPubRoomJoinOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXPubRoomJoinOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXPubRoomJoinOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str;
  
  if (arg1) (arg1)->mRoomPin = *arg2;
}

NSString* _wrap_BMXPubRoomJoinOptions_mRoomPin_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXPubRoomJoinOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXPubRoomJoinOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXPubRoomJoinOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) & ((arg1)->mRoomPin);
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXPubRoomJoinOptions_mDescription_set(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXPubRoomJoinOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXPubRoomJoinOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXPubRoomJoinOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str;
  
  if (arg1) (arg1)->mDescription = *arg2;
}

NSString* _wrap_BMXPubRoomJoinOptions_mDescription_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXPubRoomJoinOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXPubRoomJoinOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXPubRoomJoinOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) & ((arg1)->mDescription);
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXPubRoomJoinOptions_mToken_set(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXPubRoomJoinOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXPubRoomJoinOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXPubRoomJoinOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str;
  
  if (arg1) (arg1)->mToken = *arg2;
}

NSString* _wrap_BMXPubRoomJoinOptions_mToken_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXPubRoomJoinOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXPubRoomJoinOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXPubRoomJoinOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) & ((arg1)->mToken);
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_delete_BMXPubRoomJoinOptions(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXPubRoomJoinOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXPubRoomJoinOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXPubRoomJoinOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  
  delete argp1;
}

void* _wrap_new_BMXRoomPubConfigureOptions__SWIG_0(BOOL imarg1, BOOL imarg2, int imarg3, int imarg4, int imarg5, BOOL imarg6, NSString* imarg7) {
  bool arg1 ;
  bool arg2 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  bool arg6 ;
  std::string *arg7 = 0 ;
  void* imresult = 0 ;
  floo::BMXRTCSignalService::BMXRoomPubConfigureOptions *result = 0 ;
  
  arg1 = imarg1? true : false;
  arg2 = imarg2? true : false;
  arg3 = (int)imarg3;
  arg4 = (int)imarg4;
  arg5 = (int)imarg5;
  arg6 = imarg6? true : false;
  if(!imarg7) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg7_str(getStdString(imarg7));
  arg7 = &arg7_str;
  
  result = (floo::BMXRTCSignalService::BMXRoomPubConfigureOptions *)new floo::BMXRTCSignalService::BMXRoomPubConfigureOptions(arg1,arg2,arg3,arg4,arg5,arg6,(std::string const &)*arg7);
  BMXRoomPubConfigureOptions2Void(result)
  imresult = (void*)lresult;
  return imresult;
}

void* _wrap_new_BMXRoomPubConfigureOptions__SWIG_1(BOOL imarg1, BOOL imarg2, int imarg3, int imarg4, int imarg5, BOOL imarg6) {
  bool arg1 ;
  bool arg2 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  bool arg6 ;
  void* imresult = 0 ;
  floo::BMXRTCSignalService::BMXRoomPubConfigureOptions *result = 0 ;
  
  arg1 = imarg1? true : false;
  arg2 = imarg2? true : false;
  arg3 = (int)imarg3;
  arg4 = (int)imarg4;
  arg5 = (int)imarg5;
  arg6 = imarg6? true : false;
  result = (floo::BMXRTCSignalService::BMXRoomPubConfigureOptions *)new floo::BMXRTCSignalService::BMXRoomPubConfigureOptions(arg1,arg2,arg3,arg4,arg5,arg6);
  BMXRoomPubConfigureOptions2Void(result)
  imresult = (void*)lresult;
  return imresult;
}

void* _wrap_new_BMXRoomPubConfigureOptions__SWIG_2(BOOL imarg1, BOOL imarg2, int imarg3, int imarg4, int imarg5) {
  bool arg1 ;
  bool arg2 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  void* imresult = 0 ;
  floo::BMXRTCSignalService::BMXRoomPubConfigureOptions *result = 0 ;
  
  arg1 = imarg1? true : false;
  arg2 = imarg2? true : false;
  arg3 = (int)imarg3;
  arg4 = (int)imarg4;
  arg5 = (int)imarg5;
  result = (floo::BMXRTCSignalService::BMXRoomPubConfigureOptions *)new floo::BMXRTCSignalService::BMXRoomPubConfigureOptions(arg1,arg2,arg3,arg4,arg5);
  BMXRoomPubConfigureOptions2Void(result)
  imresult = (void*)lresult;
  return imresult;
}

void* _wrap_new_BMXRoomPubConfigureOptions__SWIG_3(BOOL imarg1, BOOL imarg2, int imarg3, int imarg4) {
  bool arg1 ;
  bool arg2 ;
  int arg3 ;
  int arg4 ;
  void* imresult = 0 ;
  floo::BMXRTCSignalService::BMXRoomPubConfigureOptions *result = 0 ;
  
  arg1 = imarg1? true : false;
  arg2 = imarg2? true : false;
  arg3 = (int)imarg3;
  arg4 = (int)imarg4;
  result = (floo::BMXRTCSignalService::BMXRoomPubConfigureOptions *)new floo::BMXRTCSignalService::BMXRoomPubConfigureOptions(arg1,arg2,arg3,arg4);
  BMXRoomPubConfigureOptions2Void(result)
  imresult = (void*)lresult;
  return imresult;
}

void* _wrap_new_BMXRoomPubConfigureOptions__SWIG_4(BOOL imarg1, BOOL imarg2, int imarg3) {
  bool arg1 ;
  bool arg2 ;
  int arg3 ;
  void* imresult = 0 ;
  floo::BMXRTCSignalService::BMXRoomPubConfigureOptions *result = 0 ;
  
  arg1 = imarg1? true : false;
  arg2 = imarg2? true : false;
  arg3 = (int)imarg3;
  result = (floo::BMXRTCSignalService::BMXRoomPubConfigureOptions *)new floo::BMXRTCSignalService::BMXRoomPubConfigureOptions(arg1,arg2,arg3);
  BMXRoomPubConfigureOptions2Void(result)
  imresult = (void*)lresult;
  return imresult;
}

void* _wrap_new_BMXRoomPubConfigureOptions__SWIG_5(BOOL imarg1, BOOL imarg2) {
  bool arg1 ;
  bool arg2 ;
  void* imresult = 0 ;
  floo::BMXRTCSignalService::BMXRoomPubConfigureOptions *result = 0 ;
  
  arg1 = imarg1? true : false;
  arg2 = imarg2? true : false;
  result = (floo::BMXRTCSignalService::BMXRoomPubConfigureOptions *)new floo::BMXRTCSignalService::BMXRoomPubConfigureOptions(arg1,arg2);
  BMXRoomPubConfigureOptions2Void(result)
  imresult = (void*)lresult;
  return imresult;
}

void* _wrap_new_BMXRoomPubConfigureOptions__SWIG_6(BOOL imarg1) {
  bool arg1 ;
  void* imresult = 0 ;
  floo::BMXRTCSignalService::BMXRoomPubConfigureOptions *result = 0 ;
  
  arg1 = imarg1? true : false;
  result = (floo::BMXRTCSignalService::BMXRoomPubConfigureOptions *)new floo::BMXRTCSignalService::BMXRoomPubConfigureOptions(arg1);
  BMXRoomPubConfigureOptions2Void(result)
  imresult = (void*)lresult;
  return imresult;
}

void* _wrap_new_BMXRoomPubConfigureOptions__SWIG_7() {
  void* imresult = 0 ;
  floo::BMXRTCSignalService::BMXRoomPubConfigureOptions *result = 0 ;
  
  result = (floo::BMXRTCSignalService::BMXRoomPubConfigureOptions *)new floo::BMXRTCSignalService::BMXRoomPubConfigureOptions();
  BMXRoomPubConfigureOptions2Void(result)
  imresult = (void*)lresult;
  return imresult;
}

void _wrap_BMXRoomPubConfigureOptions_mEnableAudio_set(void* imarg1, BOOL imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXRoomPubConfigureOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXRoomPubConfigureOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXRoomPubConfigureOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  bool arg2 ;
  
  arg2 = imarg2? true : false;
  if (arg1) (arg1)->mEnableAudio = arg2;
}

BOOL _wrap_BMXRoomPubConfigureOptions_mEnableAudio_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXRoomPubConfigureOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXRoomPubConfigureOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXRoomPubConfigureOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BOOL imresult = 0 ;
  bool result;
  
  result = (bool) ((arg1)->mEnableAudio);
  imresult = (result)? YES:NO;
  return imresult;
}

void _wrap_BMXRoomPubConfigureOptions_mEnableVideo_set(void* imarg1, BOOL imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXRoomPubConfigureOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXRoomPubConfigureOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXRoomPubConfigureOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  bool arg2 ;
  
  arg2 = imarg2? true : false;
  if (arg1) (arg1)->mEnableVideo = arg2;
}

BOOL _wrap_BMXRoomPubConfigureOptions_mEnableVideo_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXRoomPubConfigureOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXRoomPubConfigureOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXRoomPubConfigureOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BOOL imresult = 0 ;
  bool result;
  
  result = (bool) ((arg1)->mEnableVideo);
  imresult = (result)? YES:NO;
  return imresult;
}

void _wrap_BMXRoomPubConfigureOptions_mEnableData_set(void* imarg1, BOOL imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXRoomPubConfigureOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXRoomPubConfigureOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXRoomPubConfigureOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  bool arg2 ;
  
  arg2 = imarg2? true : false;
  if (arg1) (arg1)->mEnableData = arg2;
}

BOOL _wrap_BMXRoomPubConfigureOptions_mEnableData_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXRoomPubConfigureOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXRoomPubConfigureOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXRoomPubConfigureOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BOOL imresult = 0 ;
  bool result;
  
  result = (bool) ((arg1)->mEnableData);
  imresult = (result)? YES:NO;
  return imresult;
}

void _wrap_BMXRoomPubConfigureOptions_mDisplay_set(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXRoomPubConfigureOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXRoomPubConfigureOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXRoomPubConfigureOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str;
  
  if (arg1) (arg1)->mDisplay = *arg2;
}

NSString* _wrap_BMXRoomPubConfigureOptions_mDisplay_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXRoomPubConfigureOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXRoomPubConfigureOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXRoomPubConfigureOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) & ((arg1)->mDisplay);
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXRoomPubConfigureOptions_mWidth_set(void* imarg1, int imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXRoomPubConfigureOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXRoomPubConfigureOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXRoomPubConfigureOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int arg2 ;
  
  arg2 = (int)imarg2;
  if (arg1) (arg1)->mWidth = arg2;
}

int _wrap_BMXRoomPubConfigureOptions_mWidth_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXRoomPubConfigureOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXRoomPubConfigureOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXRoomPubConfigureOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  int result;
  
  result = (int) ((arg1)->mWidth);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_BMXRoomPubConfigureOptions_mHeight_set(void* imarg1, int imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXRoomPubConfigureOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXRoomPubConfigureOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXRoomPubConfigureOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int arg2 ;
  
  arg2 = (int)imarg2;
  if (arg1) (arg1)->mHeight = arg2;
}

int _wrap_BMXRoomPubConfigureOptions_mHeight_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXRoomPubConfigureOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXRoomPubConfigureOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXRoomPubConfigureOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  int result;
  
  result = (int) ((arg1)->mHeight);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_BMXRoomPubConfigureOptions_mBitrate_set(void* imarg1, int imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXRoomPubConfigureOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXRoomPubConfigureOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXRoomPubConfigureOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int arg2 ;
  
  arg2 = (int)imarg2;
  if (arg1) (arg1)->mBitrate = arg2;
}

int _wrap_BMXRoomPubConfigureOptions_mBitrate_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXRoomPubConfigureOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXRoomPubConfigureOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXRoomPubConfigureOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  int result;
  
  result = (int) ((arg1)->mBitrate);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_delete_BMXRoomPubConfigureOptions(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXRoomPubConfigureOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXRoomPubConfigureOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXRoomPubConfigureOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  
  delete argp1;
}

void* _wrap_new_BMXRoomSubJoinOptions__SWIG_0() {
  void* imresult = 0 ;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptions *result = 0 ;
  
  result = (floo::BMXRTCSignalService::BMXRoomSubJoinOptions *)new floo::BMXRTCSignalService::BMXRoomSubJoinOptions();
  BMXRoomSubJoinOptions2Void(result)
  imresult = (void*)lresult;
  return imresult;
}

void* _wrap_new_BMXRoomSubJoinOptions__SWIG_1(void* imarg1, long long imarg2, BOOL imarg3, BOOL imarg4, BOOL imarg5, BOOL imarg6) {
  BMXRTCStreams *arg1 = 0 ;
  int64_t arg2 ;
  bool arg3 ;
  bool arg4 ;
  bool arg5 ;
  bool arg6 ;
  void* imresult = 0 ;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptions *result = 0 ;
  
  arg1 = (BMXRTCStreams *)imarg1;
  arg2 = (int64_t)imarg2;
  arg3 = imarg3? true : false;
  arg4 = imarg4? true : false;
  arg5 = imarg5? true : false;
  arg6 = imarg6? true : false;
  result = (floo::BMXRTCSignalService::BMXRoomSubJoinOptions *)new floo::BMXRTCSignalService::BMXRoomSubJoinOptions(*arg1,arg2,arg3,arg4,arg5,arg6);
  BMXRoomSubJoinOptions2Void(result)
  imresult = (void*)lresult;
  return imresult;
}

void* _wrap_new_BMXRoomSubJoinOptions__SWIG_2(void* imarg1, long long imarg2, BOOL imarg3, BOOL imarg4, BOOL imarg5) {
  BMXRTCStreams *arg1 = 0 ;
  int64_t arg2 ;
  bool arg3 ;
  bool arg4 ;
  bool arg5 ;
  void* imresult = 0 ;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptions *result = 0 ;
  
  arg1 = (BMXRTCStreams *)imarg1;
  arg2 = (int64_t)imarg2;
  arg3 = imarg3? true : false;
  arg4 = imarg4? true : false;
  arg5 = imarg5? true : false;
  result = (floo::BMXRTCSignalService::BMXRoomSubJoinOptions *)new floo::BMXRTCSignalService::BMXRoomSubJoinOptions(*arg1,arg2,arg3,arg4,arg5);
  BMXRoomSubJoinOptions2Void(result)
  imresult = (void*)lresult;
  return imresult;
}

void* _wrap_new_BMXRoomSubJoinOptions__SWIG_3(void* imarg1, long long imarg2, BOOL imarg3, BOOL imarg4) {
  BMXRTCStreams *arg1 = 0 ;
  int64_t arg2 ;
  bool arg3 ;
  bool arg4 ;
  void* imresult = 0 ;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptions *result = 0 ;
  
  arg1 = (BMXRTCStreams *)imarg1;
  arg2 = (int64_t)imarg2;
  arg3 = imarg3? true : false;
  arg4 = imarg4? true : false;
  result = (floo::BMXRTCSignalService::BMXRoomSubJoinOptions *)new floo::BMXRTCSignalService::BMXRoomSubJoinOptions(*arg1,arg2,arg3,arg4);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void* _wrap_new_BMXRoomSubJoinOptions__SWIG_4(void* imarg1, long long imarg2, BOOL imarg3) {
  BMXRTCStreams *arg1 = 0 ;
  int64_t arg2 ;
  bool arg3 ;
  void* imresult = 0 ;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptions *result = 0 ;
  
  arg1 = (BMXRTCStreams *)imarg1;
  arg2 = (int64_t)imarg2;
  arg3 = imarg3? true : false;
  result = (floo::BMXRTCSignalService::BMXRoomSubJoinOptions *)new floo::BMXRTCSignalService::BMXRoomSubJoinOptions(*arg1,arg2,arg3);
  BMXRoomSubJoinOptions2Void(result)
  imresult = (void*)lresult;
  return imresult;
}

void* _wrap_new_BMXRoomSubJoinOptions__SWIG_5(void* imarg1, long long imarg2) {
  BMXRTCStreams *arg1 = 0 ;
  int64_t arg2 ;
  void* imresult = 0 ;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptions *result = 0 ;
  
  arg1 = (BMXRTCStreams *)imarg1;
  arg2 = (int64_t)imarg2;
  result = (floo::BMXRTCSignalService::BMXRoomSubJoinOptions *)new floo::BMXRTCSignalService::BMXRoomSubJoinOptions(*arg1,arg2);
  BMXRoomSubJoinOptions2Void(result)
  imresult = (void*)lresult;
  return imresult;
}

void* _wrap_new_BMXRoomSubJoinOptions__SWIG_6(void* imarg1) {
  BMXRTCStreams *arg1 = 0 ;
  void* imresult = 0 ;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptions *result = 0 ;
  
  arg1 = (BMXRTCStreams *)imarg1;
  result = (floo::BMXRTCSignalService::BMXRoomSubJoinOptions *)new floo::BMXRTCSignalService::BMXRoomSubJoinOptions(*arg1);
  BMXRoomSubJoinOptions2Void(result)
  imresult = (void*)lresult;
  return imresult;
}

void _wrap_BMXRoomSubJoinOptions_mUserId_set(void* imarg1, long long imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int64_t arg2 ;
  
  arg2 = (int64_t)imarg2;
  if (arg1) (arg1)->mUserId = arg2;
}

long long _wrap_BMXRoomSubJoinOptions_mUserId_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  long long imresult = 0 ;
  int64_t result;
  
  result = (int64_t) ((arg1)->mUserId);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_BMXRoomSubJoinOptions_mRoomId_set(void* imarg1, long long imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int64_t arg2 ;
  
  arg2 = (int64_t)imarg2;
  if (arg1) (arg1)->mRoomId = arg2;
}

long long _wrap_BMXRoomSubJoinOptions_mRoomId_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  long long imresult = 0 ;
  int64_t result;
  
  result = (int64_t) ((arg1)->mRoomId);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_BMXRoomSubJoinOptions_mRoomPin_set(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str;
  
  if (arg1) (arg1)->mRoomPin = *arg2;
}

NSString* _wrap_BMXRoomSubJoinOptions_mRoomPin_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) & ((arg1)->mRoomPin);
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXRoomSubJoinOptions_mDescription_set(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str;
  
  if (arg1) (arg1)->mDescription = *arg2;
}

NSString* _wrap_BMXRoomSubJoinOptions_mDescription_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) & ((arg1)->mDescription);
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXRoomSubJoinOptions_mToken_set(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str;
  
  if (arg1) (arg1)->mToken = *arg2;
}

NSString* _wrap_BMXRoomSubJoinOptions_mToken_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) & ((arg1)->mToken);
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXRoomSubJoinOptions_mPrivateId_set(void* imarg1, long long imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int64_t arg2 ;
  
  arg2 = (int64_t)imarg2;
  if (arg1) (arg1)->mPrivateId = arg2;
}

long long _wrap_BMXRoomSubJoinOptions_mPrivateId_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  long long imresult = 0 ;
  int64_t result;
  
  result = (int64_t) ((arg1)->mPrivateId);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_BMXRoomSubJoinOptions_mEnableAudio_set(void* imarg1, BOOL imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  bool arg2 ;
  
  arg2 = imarg2? true : false;
  if (arg1) (arg1)->mEnableAudio = arg2;
}

BOOL _wrap_BMXRoomSubJoinOptions_mEnableAudio_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BOOL imresult = 0 ;
  bool result;
  
  result = (bool) ((arg1)->mEnableAudio);
  imresult = (result)? YES:NO;
  return imresult;
}

void _wrap_BMXRoomSubJoinOptions_mEnableVideo_set(void* imarg1, BOOL imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  bool arg2 ;
  
  arg2 = imarg2? true : false;
  if (arg1) (arg1)->mEnableVideo = arg2;
}

BOOL _wrap_BMXRoomSubJoinOptions_mEnableVideo_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BOOL imresult = 0 ;
  bool result;
  
  result = (bool) ((arg1)->mEnableVideo);
  imresult = (result)? YES:NO;
  return imresult;
}

void _wrap_BMXRoomSubJoinOptions_mEnableData_set(void* imarg1, BOOL imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  bool arg2 ;
  
  arg2 = imarg2? true : false;
  if (arg1) (arg1)->mEnableData = arg2;
}

BOOL _wrap_BMXRoomSubJoinOptions_mEnableData_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BOOL imresult = 0 ;
  bool result;
  
  result = (bool) ((arg1)->mEnableData);
  imresult = (result)? YES:NO;
  return imresult;
}

void _wrap_BMXRoomSubJoinOptions_mAutoClosePc_set(void* imarg1, BOOL imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  bool arg2 ;
  
  arg2 = imarg2? true : false;
  if (arg1) (arg1)->mAutoClosePc = arg2;
}

BOOL _wrap_BMXRoomSubJoinOptions_mAutoClosePc_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BOOL imresult = 0 ;
  bool result;
  
  result = (bool) ((arg1)->mAutoClosePc);
  imresult = (result)? YES:NO;
  return imresult;
}

void _wrap_BMXRoomSubJoinOptions_streams_set(void* imarg1, void* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BMXRTCStreams arg2 ;
  BMXRTCStreams *argp2 ;
  
  
  argp2 = (BMXRTCStreams *)imarg2;
  arg2 = *argp2;
  
  if (arg1) (arg1)->streams = arg2;
}

void* _wrap_BMXRoomSubJoinOptions_streams_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  void* imresult = 0 ;
  BMXRTCStreams *temp ;
  BMXRTCStreams result;
  
  result =  ((arg1)->streams);
  
  temp = new BMXRTCStreams((const BMXRTCStreams &)result);
  imresult = *(typeof(imresult)*)&temp;
  
  return imresult;
}

void _wrap_delete_BMXRoomSubJoinOptions(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr arg1 ;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr *argp1 = *(floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  
  delete argp1;
}

void* _wrap_new_BMXRoomSubConfigureOptions__SWIG_0(BOOL imarg1, BOOL imarg2, BOOL imarg3) {
  bool arg1 ;
  bool arg2 ;
  bool arg3 ;
  void* imresult = 0 ;
  floo::BMXRTCSignalService::BMXRoomSubConfigureOptions *result = 0 ;
  
  arg1 = imarg1? true : false;
  arg2 = imarg2? true : false;
  arg3 = imarg3? true : false;
  result = (floo::BMXRTCSignalService::BMXRoomSubConfigureOptions *)new floo::BMXRTCSignalService::BMXRoomSubConfigureOptions(arg1,arg2,arg3);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void* _wrap_new_BMXRoomSubConfigureOptions__SWIG_1(BOOL imarg1, BOOL imarg2) {
  bool arg1 ;
  bool arg2 ;
  void* imresult = 0 ;
  floo::BMXRTCSignalService::BMXRoomSubConfigureOptions *result = 0 ;
  
  arg1 = imarg1? true : false;
  arg2 = imarg2? true : false;
  result = (floo::BMXRTCSignalService::BMXRoomSubConfigureOptions *)new floo::BMXRTCSignalService::BMXRoomSubConfigureOptions(arg1,arg2);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void* _wrap_new_BMXRoomSubConfigureOptions__SWIG_2(BOOL imarg1) {
  bool arg1 ;
  void* imresult = 0 ;
  floo::BMXRTCSignalService::BMXRoomSubConfigureOptions *result = 0 ;
  
  arg1 = imarg1? true : false;
  result = (floo::BMXRTCSignalService::BMXRoomSubConfigureOptions *)new floo::BMXRTCSignalService::BMXRoomSubConfigureOptions(arg1);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void* _wrap_new_BMXRoomSubConfigureOptions__SWIG_3() {
  void* imresult = 0 ;
  floo::BMXRTCSignalService::BMXRoomSubConfigureOptions *result = 0 ;
  
  result = (floo::BMXRTCSignalService::BMXRoomSubConfigureOptions *)new floo::BMXRTCSignalService::BMXRoomSubConfigureOptions();
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_BMXRoomSubConfigureOptions_mEnableAudio_set(void* imarg1, BOOL imarg2) {
  floo::BMXRTCSignalService::BMXRoomSubConfigureOptions *arg1 = (floo::BMXRTCSignalService::BMXRoomSubConfigureOptions *) 0 ;
  bool arg2 ;
  
  arg1 = (floo::BMXRTCSignalService::BMXRoomSubConfigureOptions *)imarg1;
  arg2 = imarg2? true : false;
  if (arg1) (arg1)->mEnableAudio = arg2;
}

BOOL _wrap_BMXRoomSubConfigureOptions_mEnableAudio_get(void* imarg1) {
  floo::BMXRTCSignalService::BMXRoomSubConfigureOptions *arg1 = (floo::BMXRTCSignalService::BMXRoomSubConfigureOptions *) 0 ;
  BOOL imresult = 0 ;
  bool result;
  
  arg1 = (floo::BMXRTCSignalService::BMXRoomSubConfigureOptions *)imarg1;
  result = (bool) ((arg1)->mEnableAudio);
  imresult = (result)? YES:NO;
  return imresult;
}

void _wrap_BMXRoomSubConfigureOptions_mEnableVideo_set(void* imarg1, BOOL imarg2) {
  floo::BMXRTCSignalService::BMXRoomSubConfigureOptions *arg1 = (floo::BMXRTCSignalService::BMXRoomSubConfigureOptions *) 0 ;
  bool arg2 ;
  
  arg1 = (floo::BMXRTCSignalService::BMXRoomSubConfigureOptions *)imarg1;
  arg2 = imarg2? true : false;
  if (arg1) (arg1)->mEnableVideo = arg2;
}

BOOL _wrap_BMXRoomSubConfigureOptions_mEnableVideo_get(void* imarg1) {
  floo::BMXRTCSignalService::BMXRoomSubConfigureOptions *arg1 = (floo::BMXRTCSignalService::BMXRoomSubConfigureOptions *) 0 ;
  BOOL imresult = 0 ;
  bool result;
  
  arg1 = (floo::BMXRTCSignalService::BMXRoomSubConfigureOptions *)imarg1;
  result = (bool) ((arg1)->mEnableVideo);
  imresult = (result)? YES:NO;
  return imresult;
}

void _wrap_BMXRoomSubConfigureOptions_mEnableData_set(void* imarg1, BOOL imarg2) {
  floo::BMXRTCSignalService::BMXRoomSubConfigureOptions *arg1 = (floo::BMXRTCSignalService::BMXRoomSubConfigureOptions *) 0 ;
  bool arg2 ;
  
  arg1 = (floo::BMXRTCSignalService::BMXRoomSubConfigureOptions *)imarg1;
  arg2 = imarg2? true : false;
  if (arg1) (arg1)->mEnableData = arg2;
}

BOOL _wrap_BMXRoomSubConfigureOptions_mEnableData_get(void* imarg1) {
  floo::BMXRTCSignalService::BMXRoomSubConfigureOptions *arg1 = (floo::BMXRTCSignalService::BMXRoomSubConfigureOptions *) 0 ;
  BOOL imresult = 0 ;
  bool result;
  
  arg1 = (floo::BMXRTCSignalService::BMXRoomSubConfigureOptions *)imarg1;
  result = (bool) ((arg1)->mEnableData);
  imresult = (result)? YES:NO;
  return imresult;
}

void _wrap_delete_BMXRoomSubConfigureOptions(void* imarg1) {
  floo::BMXRTCSignalService::BMXRoomSubConfigureOptions *arg1 = (floo::BMXRTCSignalService::BMXRoomSubConfigureOptions *) 0 ;
  
  arg1 = (floo::BMXRTCSignalService::BMXRoomSubConfigureOptions *)imarg1;
  delete arg1;
}

void* _wrap_new_BMXRoomSubSwitchOptions__SWIG_0() {
  void* imresult = 0 ;
  floo::BMXRTCSignalService::BMXRoomSubSwitchOptions *result = 0 ;
  
  result = (floo::BMXRTCSignalService::BMXRoomSubSwitchOptions *)new floo::BMXRTCSignalService::BMXRoomSubSwitchOptions();
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void* _wrap_new_BMXRoomSubSwitchOptions__SWIG_1(long long imarg1, BOOL imarg2, BOOL imarg3, BOOL imarg4) {
  int64_t arg1 ;
  bool arg2 ;
  bool arg3 ;
  bool arg4 ;
  void* imresult = 0 ;
  floo::BMXRTCSignalService::BMXRoomSubSwitchOptions *result = 0 ;
  
  arg1 = (int64_t)imarg1;
  arg2 = imarg2? true : false;
  arg3 = imarg3? true : false;
  arg4 = imarg4? true : false;
  result = (floo::BMXRTCSignalService::BMXRoomSubSwitchOptions *)new floo::BMXRTCSignalService::BMXRoomSubSwitchOptions(arg1,arg2,arg3,arg4);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void* _wrap_new_BMXRoomSubSwitchOptions__SWIG_2(long long imarg1, BOOL imarg2, BOOL imarg3) {
  int64_t arg1 ;
  bool arg2 ;
  bool arg3 ;
  void* imresult = 0 ;
  floo::BMXRTCSignalService::BMXRoomSubSwitchOptions *result = 0 ;
  
  arg1 = (int64_t)imarg1;
  arg2 = imarg2? true : false;
  arg3 = imarg3? true : false;
  result = (floo::BMXRTCSignalService::BMXRoomSubSwitchOptions *)new floo::BMXRTCSignalService::BMXRoomSubSwitchOptions(arg1,arg2,arg3);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void* _wrap_new_BMXRoomSubSwitchOptions__SWIG_3(long long imarg1, BOOL imarg2) {
  int64_t arg1 ;
  bool arg2 ;
  void* imresult = 0 ;
  floo::BMXRTCSignalService::BMXRoomSubSwitchOptions *result = 0 ;
  
  arg1 = (int64_t)imarg1;
  arg2 = imarg2? true : false;
  result = (floo::BMXRTCSignalService::BMXRoomSubSwitchOptions *)new floo::BMXRTCSignalService::BMXRoomSubSwitchOptions(arg1,arg2);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void* _wrap_new_BMXRoomSubSwitchOptions__SWIG_4(long long imarg1) {
  int64_t arg1 ;
  void* imresult = 0 ;
  floo::BMXRTCSignalService::BMXRoomSubSwitchOptions *result = 0 ;
  
  arg1 = (int64_t)imarg1;
  result = (floo::BMXRTCSignalService::BMXRoomSubSwitchOptions *)new floo::BMXRTCSignalService::BMXRoomSubSwitchOptions(arg1);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_BMXRoomSubSwitchOptions_mFeedId_set(void* imarg1, long long imarg2) {
  floo::BMXRTCSignalService::BMXRoomSubSwitchOptions *arg1 = (floo::BMXRTCSignalService::BMXRoomSubSwitchOptions *) 0 ;
  int64_t arg2 ;
  
  arg1 = (floo::BMXRTCSignalService::BMXRoomSubSwitchOptions *)imarg1;
  arg2 = (int64_t)imarg2;
  if (arg1) (arg1)->mFeedId = arg2;
}

long long _wrap_BMXRoomSubSwitchOptions_mFeedId_get(void* imarg1) {
  floo::BMXRTCSignalService::BMXRoomSubSwitchOptions *arg1 = (floo::BMXRTCSignalService::BMXRoomSubSwitchOptions *) 0 ;
  long long imresult = 0 ;
  int64_t result;
  
  arg1 = (floo::BMXRTCSignalService::BMXRoomSubSwitchOptions *)imarg1;
  result = (int64_t) ((arg1)->mFeedId);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_BMXRoomSubSwitchOptions_mEnableAudio_set(void* imarg1, BOOL imarg2) {
  floo::BMXRTCSignalService::BMXRoomSubSwitchOptions *arg1 = (floo::BMXRTCSignalService::BMXRoomSubSwitchOptions *) 0 ;
  bool arg2 ;
  
  arg1 = (floo::BMXRTCSignalService::BMXRoomSubSwitchOptions *)imarg1;
  arg2 = imarg2? true : false;
  if (arg1) (arg1)->mEnableAudio = arg2;
}

BOOL _wrap_BMXRoomSubSwitchOptions_mEnableAudio_get(void* imarg1) {
  floo::BMXRTCSignalService::BMXRoomSubSwitchOptions *arg1 = (floo::BMXRTCSignalService::BMXRoomSubSwitchOptions *) 0 ;
  BOOL imresult = 0 ;
  bool result;
  
  arg1 = (floo::BMXRTCSignalService::BMXRoomSubSwitchOptions *)imarg1;
  result = (bool) ((arg1)->mEnableAudio);
  imresult = (result)? YES:NO;
  return imresult;
}

void _wrap_BMXRoomSubSwitchOptions_mEnableVideo_set(void* imarg1, BOOL imarg2) {
  floo::BMXRTCSignalService::BMXRoomSubSwitchOptions *arg1 = (floo::BMXRTCSignalService::BMXRoomSubSwitchOptions *) 0 ;
  bool arg2 ;
  
  arg1 = (floo::BMXRTCSignalService::BMXRoomSubSwitchOptions *)imarg1;
  arg2 = imarg2? true : false;
  if (arg1) (arg1)->mEnableVideo = arg2;
}

BOOL _wrap_BMXRoomSubSwitchOptions_mEnableVideo_get(void* imarg1) {
  floo::BMXRTCSignalService::BMXRoomSubSwitchOptions *arg1 = (floo::BMXRTCSignalService::BMXRoomSubSwitchOptions *) 0 ;
  BOOL imresult = 0 ;
  bool result;
  
  arg1 = (floo::BMXRTCSignalService::BMXRoomSubSwitchOptions *)imarg1;
  result = (bool) ((arg1)->mEnableVideo);
  imresult = (result)? YES:NO;
  return imresult;
}

void _wrap_BMXRoomSubSwitchOptions_mEnableData_set(void* imarg1, BOOL imarg2) {
  floo::BMXRTCSignalService::BMXRoomSubSwitchOptions *arg1 = (floo::BMXRTCSignalService::BMXRoomSubSwitchOptions *) 0 ;
  bool arg2 ;
  
  arg1 = (floo::BMXRTCSignalService::BMXRoomSubSwitchOptions *)imarg1;
  arg2 = imarg2? true : false;
  if (arg1) (arg1)->mEnableData = arg2;
}

BOOL _wrap_BMXRoomSubSwitchOptions_mEnableData_get(void* imarg1) {
  floo::BMXRTCSignalService::BMXRoomSubSwitchOptions *arg1 = (floo::BMXRTCSignalService::BMXRoomSubSwitchOptions *) 0 ;
  BOOL imresult = 0 ;
  bool result;
  
  arg1 = (floo::BMXRTCSignalService::BMXRoomSubSwitchOptions *)imarg1;
  result = (bool) ((arg1)->mEnableData);
  imresult = (result)? YES:NO;
  return imresult;
}

void _wrap_delete_BMXRoomSubSwitchOptions(void* imarg1) {
  floo::BMXRTCSignalService::BMXRoomSubSwitchOptions *arg1 = (floo::BMXRTCSignalService::BMXRoomSubSwitchOptions *) 0 ;
  
  arg1 = (floo::BMXRTCSignalService::BMXRoomSubSwitchOptions *)imarg1;
  delete arg1;
}

void _wrap_delete_BMXMessageAttachment(void* imarg1) {
  floo::BMXMessageAttachment *arg1 = (floo::BMXMessageAttachment *) 0 ;
  
  arg1 = (floo::BMXMessageAttachment *)imarg1; 
  delete arg1;
}

int _wrap_BMXMessageAttachment_type(void* imarg1) {
  floo::BMXMessageAttachment *arg1 = (floo::BMXMessageAttachment *) 0 ;
  int imresult = 0 ;
  floo::BMXMessageAttachment::Type result;
  
  arg1 = (floo::BMXMessageAttachment *)imarg1; 
  result = (floo::BMXMessageAttachment::Type)((floo::BMXMessageAttachment const *)arg1)->type();
  imresult = (int)result; 
  return imresult;
}

void* _wrap_BMXMessageAttachment_clone(void* imarg1) {
  floo::BMXMessageAttachment *arg1 = (floo::BMXMessageAttachment *) 0 ;
  void* imresult = 0 ;
  std::shared_ptr< floo::BMXMessageAttachment > *temp ;
  std::shared_ptr< floo::BMXMessageAttachment > result;
  
  arg1 = (floo::BMXMessageAttachment *)imarg1; 
  result = ((floo::BMXMessageAttachment const *)arg1)->clone();
  
  temp = new std::shared_ptr< floo::BMXMessageAttachment >((const std::shared_ptr< floo::BMXMessageAttachment > &)result); 
  
  return imresult;
}

NSString* _wrap_kMentionAll_get() {
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &floo::kMentionAll;
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_kMentionList_get() {
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &floo::kMentionList;
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_kMentionedMessage_get() {
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &floo::kMentionedMessage;
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_kPushMessage_get() {
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &floo::kPushMessage;
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_kSenderNickname_get() {
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &floo::kSenderNickname;
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_kGroupAck_get() {
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &floo::kGroupAck;
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_kGroupMemberList_get() {
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &floo::kGroupMemberList;
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_kIOSConfig_get() {
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &floo::kIOSConfig;
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_kAndroidConfig_get() {
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &floo::kAndroidConfig;
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_kPushShowBeginTime_get() {
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &floo::kPushShowBeginTime;
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_kPushShowEndTime_get() {
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &floo::kPushShowEndTime;
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_kPushTitle_get() {
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &floo::kPushTitle;
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_kSilence_get() {
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &floo::kSilence;
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_kBadge_get() {
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &floo::kBadge;
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_kUsername_get() {
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &floo::kUsername;
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_kRTCAction_get() {
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &floo::kRTCAction;
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_kRTCCallType_get() {
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &floo::kRTCCallType;
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_kRTCRoomId_get() {
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &floo::kRTCRoomId;
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_kRTCInitiator_get() {
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &floo::kRTCInitiator;
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_kRTCCallId_get() {
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &floo::kRTCCallId;
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_kRTCRoomType_get() {
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &floo::kRTCRoomType;
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_kRTCPin_get() {
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &floo::kRTCPin;
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_delete_BMXMessageConfig(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessageConfigPtr arg1 ;
  floo::BMXMessageConfigPtr *argp1 = *(floo::BMXMessageConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  
  delete argp1;
}

void _wrap_BMXMessageConfig_setMentionAll(void* imarg1, BOOL imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessageConfigPtr arg1 ;
  floo::BMXMessageConfigPtr *argp1 = *(floo::BMXMessageConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  bool arg2 ;
  
  arg2 = imarg2? true : false; 
  (arg1)->setMentionAll(arg2);
}

BOOL _wrap_BMXMessageConfig_getMentionAll(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessageConfigPtr arg1 ;
  floo::BMXMessageConfigPtr *argp1 = *(floo::BMXMessageConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BOOL imresult = 0 ;
  bool result;
  
  result = (bool)(arg1)->getMentionAll();
  imresult = (result)? YES:NO; 
  return imresult;
}

void _wrap_BMXMessageConfig_setMentionList(void* imarg1, void* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessageConfigPtr arg1 ;
  floo::BMXMessageConfigPtr *argp1 = *(floo::BMXMessageConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::vector< int64_t > *arg2 = 0 ;
  
  arg2 = (std::vector< int64_t > *)imarg2; 
  (arg1)->setMentionList((std::vector< int64_t > const &)*arg2);
}

void* _wrap_BMXMessageConfig_getMentionList(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessageConfigPtr arg1 ;
  floo::BMXMessageConfigPtr *argp1 = *(floo::BMXMessageConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  void* imresult = 0 ;
  std::vector< int64_t > *temp ;
  std::vector< int64_t > result;
  
  result = (arg1)->getMentionList();
  
  temp = new std::vector< int64_t >((const std::vector< int64_t > &)result); 
  
  return imresult;
}

void _wrap_BMXMessageConfig_setMentionedMessage(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessageConfigPtr arg1 ;
  floo::BMXMessageConfigPtr *argp1 = *(floo::BMXMessageConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  (arg1)->setMentionedMessage((std::string const &)*arg2);
}

NSString* _wrap_BMXMessageConfig_getMentionedMessage(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessageConfigPtr arg1 ;
  floo::BMXMessageConfigPtr *argp1 = *(floo::BMXMessageConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string result;
  
  result = (arg1)->getMentionedMessage();
  imresult = [NSString stringWithUTF8String: (&result)->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXMessageConfig_setPushMessage(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessageConfigPtr arg1 ;
  floo::BMXMessageConfigPtr *argp1 = *(floo::BMXMessageConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  (arg1)->setPushMessage((std::string const &)*arg2);
}

NSString* _wrap_BMXMessageConfig_getPushMessage(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessageConfigPtr arg1 ;
  floo::BMXMessageConfigPtr *argp1 = *(floo::BMXMessageConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string result;
  
  result = (arg1)->getPushMessage();
  imresult = [NSString stringWithUTF8String: (&result)->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXMessageConfig_setSenderNickname(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessageConfigPtr arg1 ;
  floo::BMXMessageConfigPtr *argp1 = *(floo::BMXMessageConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  (arg1)->setSenderNickname((std::string const &)*arg2);
}

NSString* _wrap_BMXMessageConfig_getSenderNickname(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessageConfigPtr arg1 ;
  floo::BMXMessageConfigPtr *argp1 = *(floo::BMXMessageConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string result;
  
  result = (arg1)->getSenderNickname();
  imresult = [NSString stringWithUTF8String: (&result)->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXMessageConfig_setGroupMemberList(void* imarg1, void* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessageConfigPtr arg1 ;
  floo::BMXMessageConfigPtr *argp1 = *(floo::BMXMessageConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::vector< int64_t > *arg2 = 0 ;
  
  arg2 = (std::vector< int64_t > *)imarg2; 
  (arg1)->setGroupMemberList((std::vector< int64_t > const &)*arg2);
}

void* _wrap_BMXMessageConfig_getGroupMemberList(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessageConfigPtr arg1 ;
  floo::BMXMessageConfigPtr *argp1 = *(floo::BMXMessageConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  void* imresult = 0 ;
  std::vector< int64_t > *temp ;
  std::vector< int64_t > result;
  
  result = (arg1)->getGroupMemberList();
  
  temp = new std::vector< int64_t >((const std::vector< int64_t > &)result); 
  
  return imresult;
}

void _wrap_BMXMessageConfig_addGroupMember(void* imarg1, long long imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessageConfigPtr arg1 ;
  floo::BMXMessageConfigPtr *argp1 = *(floo::BMXMessageConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int64_t arg2 ;
  
  arg2 = (int64_t)imarg2; 
  (arg1)->addGroupMember(arg2);
}

void _wrap_BMXMessageConfig_removeGroupMember(void* imarg1, long long imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessageConfigPtr arg1 ;
  floo::BMXMessageConfigPtr *argp1 = *(floo::BMXMessageConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int64_t arg2 ;
  
  arg2 = (int64_t)imarg2; 
  (arg1)->removeGroupMember(arg2);
}

void _wrap_BMXMessageConfig_clearGroupMemberList(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessageConfigPtr arg1 ;
  floo::BMXMessageConfigPtr *argp1 = *(floo::BMXMessageConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  
  (arg1)->clearGroupMemberList();
}

void _wrap_BMXMessageConfig_setIOSConfig(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessageConfigPtr arg1 ;
  floo::BMXMessageConfigPtr *argp1 = *(floo::BMXMessageConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  (arg1)->setIOSConfig((std::string const &)*arg2);
}

NSString* _wrap_BMXMessageConfig_getIOSConfig(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessageConfigPtr arg1 ;
  floo::BMXMessageConfigPtr *argp1 = *(floo::BMXMessageConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string result;
  
  result = (arg1)->getIOSConfig();
  imresult = [NSString stringWithUTF8String: (&result)->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXMessageConfig_setAndroidConfig(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessageConfigPtr arg1 ;
  floo::BMXMessageConfigPtr *argp1 = *(floo::BMXMessageConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  (arg1)->setAndroidConfig((std::string const &)*arg2);
}

NSString* _wrap_BMXMessageConfig_getAndroidConfig(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessageConfigPtr arg1 ;
  floo::BMXMessageConfigPtr *argp1 = *(floo::BMXMessageConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string result;
  
  result = (arg1)->getAndroidConfig();
  imresult = [NSString stringWithUTF8String: (&result)->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXMessageConfig_setPushShowBeginTime(void* imarg1, int imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessageConfigPtr arg1 ;
  floo::BMXMessageConfigPtr *argp1 = *(floo::BMXMessageConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int arg2 ;
  
  arg2 = (int)imarg2; 
  (arg1)->setPushShowBeginTime(arg2);
}

int _wrap_BMXMessageConfig_getPushShowBeginTime(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessageConfigPtr arg1 ;
  floo::BMXMessageConfigPtr *argp1 = *(floo::BMXMessageConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  int result;
  
  result = (int)(arg1)->getPushShowBeginTime();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXMessageConfig_setPushShowEndTime(void* imarg1, int imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessageConfigPtr arg1 ;
  floo::BMXMessageConfigPtr *argp1 = *(floo::BMXMessageConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int arg2 ;
  
  arg2 = (int)imarg2; 
  (arg1)->setPushShowEndTime(arg2);
}

int _wrap_BMXMessageConfig_getPushShowEndTime(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessageConfigPtr arg1 ;
  floo::BMXMessageConfigPtr *argp1 = *(floo::BMXMessageConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  int result;
  
  result = (int)(arg1)->getPushShowEndTime();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXMessageConfig_setPushTitle(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessageConfigPtr arg1 ;
  floo::BMXMessageConfigPtr *argp1 = *(floo::BMXMessageConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  (arg1)->setPushTitle((std::string const &)*arg2);
}

NSString* _wrap_BMXMessageConfig_getPushTitle(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessageConfigPtr arg1 ;
  floo::BMXMessageConfigPtr *argp1 = *(floo::BMXMessageConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string result;
  
  result = (arg1)->getPushTitle();
  imresult = [NSString stringWithUTF8String: (&result)->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXMessageConfig_setPushTitleLocKey(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessageConfigPtr arg1 ;
  floo::BMXMessageConfigPtr *argp1 = *(floo::BMXMessageConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str;
  
  (arg1)->setPushTitleLocKey((std::string const &)*arg2);
}

NSString* _wrap_BMXMessageConfig_getPushTitleLocKey(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessageConfigPtr arg1 ;
  floo::BMXMessageConfigPtr *argp1 = *(floo::BMXMessageConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string result;
  
  result = (arg1)->getPushTitleLocKey();
  imresult = [NSString stringWithUTF8String: (&result)->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXMessageConfig_setPushTitleLocArgs(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessageConfigPtr arg1 ;
  floo::BMXMessageConfigPtr *argp1 = *(floo::BMXMessageConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str;
  
  (arg1)->setPushTitleLocArgs((std::string const &)*arg2);
}

NSString* _wrap_BMXMessageConfig_getPushTitleLocArgs(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessageConfigPtr arg1 ;
  floo::BMXMessageConfigPtr *argp1 = *(floo::BMXMessageConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string result;
  
  result = (arg1)->getPushTitleLocArgs();
  imresult = [NSString stringWithUTF8String: (&result)->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXMessageConfig_setPushMessageLocKey(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessageConfigPtr arg1 ;
  floo::BMXMessageConfigPtr *argp1 = *(floo::BMXMessageConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str;
  
  (arg1)->setPushMessageLocKey((std::string const &)*arg2);
}

NSString* _wrap_BMXMessageConfig_getPushMessageLocKey(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessageConfigPtr arg1 ;
  floo::BMXMessageConfigPtr *argp1 = *(floo::BMXMessageConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string result;
  
  result = (arg1)->getPushMessageLocKey();
  imresult = [NSString stringWithUTF8String: (&result)->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXMessageConfig_setPushMessageLocArgs(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessageConfigPtr arg1 ;
  floo::BMXMessageConfigPtr *argp1 = *(floo::BMXMessageConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str;
  
  (arg1)->setPushMessageLocArgs((std::string const &)*arg2);
}

NSString* _wrap_BMXMessageConfig_getPushMessageLocArgs(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessageConfigPtr arg1 ;
  floo::BMXMessageConfigPtr *argp1 = *(floo::BMXMessageConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string result;
  
  result = (arg1)->getPushMessageLocArgs();
  imresult = [NSString stringWithUTF8String: (&result)->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

BOOL _wrap_BMXMessageConfig_isSilence(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessageConfigPtr arg1 ;
  floo::BMXMessageConfigPtr *argp1 = *(floo::BMXMessageConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BOOL imresult = 0 ;
  bool result;
  
  result = (bool)(arg1)->isSilence();
  imresult = (result)? YES:NO; 
  return imresult;
}

BOOL _wrap_BMXMessageConfig_isPeerDrop(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessageConfigPtr arg1 ;
  floo::BMXMessageConfigPtr *argp1 = *(floo::BMXMessageConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BOOL imresult = 0 ;
  bool result;
  
  result = (bool)(arg1)->getPeerDrop();
  imresult = (result)? YES:NO;
  return imresult;
}

int _wrap_BMXMessageConfig_getBadgeCountType(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessageConfigPtr arg1 ;
  floo::BMXMessageConfigPtr *argp1 = *(floo::BMXMessageConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  floo::BMXMessageConfig::BadgeCountType result;
  
  result = (floo::BMXMessageConfig::BadgeCountType)(arg1)->getBadgeCountType();
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXMessageConfig_getBadgeCount(void* imarg1, int imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessageConfigPtr arg1 ;
  floo::BMXMessageConfigPtr *argp1 = *(floo::BMXMessageConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int arg2 ;
  int imresult = 0 ;
  int result;
  
  arg2 = (int)imarg2; 
  result = (int)(arg1)->getBadgeCount(arg2);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXMessageConfig_setUsername(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessageConfigPtr arg1 ;
  floo::BMXMessageConfigPtr *argp1 = *(floo::BMXMessageConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  (arg1)->setUsername((std::string const &)*arg2);
}

NSString* _wrap_BMXMessageConfig_getUsername(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessageConfigPtr arg1 ;
  floo::BMXMessageConfigPtr *argp1 = *(floo::BMXMessageConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string result;
  
  result = (arg1)->getUsername();
  imresult = [NSString stringWithUTF8String: (&result)->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXMessageConfig_setRTCCallInfo(void* imarg1, int imarg2, long long imarg3, long long imarg4, int imarg5, NSString* imarg6) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessageConfigPtr arg1 ;
  floo::BMXMessageConfigPtr *argp1 = *(floo::BMXMessageConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  floo::BMXMessageConfig::RTCCallType arg2 ;
  int64_t arg3 ;
  int64_t arg4 ;
  floo::BMXMessageConfig::RTCRoomType arg5 ;
  std::string *arg6 = 0 ;
  
  arg2 = (floo::BMXMessageConfig::RTCCallType)imarg2; 
  arg3 = (int64_t)imarg3; 
  arg4 = (int64_t)imarg4; 
  arg5 = (floo::BMXMessageConfig::RTCRoomType)imarg5; 
  if(!imarg6) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg6_str(getStdString(imarg6));
  arg6 = &arg6_str;
  
  (arg1)->setRTCCallInfo(arg2,arg3,arg4,arg5,(std::string const &)*arg6);
}

void _wrap_BMXMessageConfig_setRTCPickupInfo(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessageConfigPtr arg1 ;
  floo::BMXMessageConfigPtr *argp1 = *(floo::BMXMessageConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
   arg2 = &arg2_str; 
  
  (arg1)->setRTCPickupInfo((std::string const &)*arg2);
}

void _wrap_BMXMessageConfig_setRTCHangupInfo(void* imarg1, NSString* imarg2, BOOL imarg3) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessageConfigPtr arg1 ;
  floo::BMXMessageConfigPtr *argp1 = *(floo::BMXMessageConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
   arg2 = &arg2_str; 
  
  bool arg3 = imarg3? true : false;
  (arg1)->setRTCHangupInfo((std::string const &)*arg2, arg3);
}

NSString* _wrap_BMXMessageConfig_getRTCAction(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessageConfigPtr arg1 ;
  floo::BMXMessageConfigPtr *argp1 = *(floo::BMXMessageConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string result;
  
  result = (arg1)->getRTCAction();
  imresult = [NSString stringWithUTF8String: (&result)->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

int _wrap_BMXMessageConfig_getRTCCallType(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessageConfigPtr arg1 ;
  floo::BMXMessageConfigPtr *argp1 = *(floo::BMXMessageConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  floo::BMXMessageConfig::RTCCallType result;
  
  result = (floo::BMXMessageConfig::RTCCallType)(arg1)->getRTCCallType();
  imresult = (int)result; 
  return imresult;
}

long long _wrap_BMXMessageConfig_getRTCRoomId(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessageConfigPtr arg1 ;
  floo::BMXMessageConfigPtr *argp1 = *(floo::BMXMessageConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  long long imresult = 0 ;
  int64_t result;
  
  result = (int64_t)(arg1)->getRTCRoomId();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

long long _wrap_BMXMessageConfig_getRTCInitiator(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessageConfigPtr arg1 ;
  floo::BMXMessageConfigPtr *argp1 = *(floo::BMXMessageConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  long long imresult = 0 ;
  int64_t result;
  
  result = (int64_t)(arg1)->getRTCInitiator();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

NSString* _wrap_BMXMessageConfig_getRTCCallId(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessageConfigPtr arg1 ;
  floo::BMXMessageConfigPtr *argp1 = *(floo::BMXMessageConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string result;
  
  result = (arg1)->getRTCCallId();
  imresult = [NSString stringWithUTF8String: (&result)->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

int _wrap_BMXMessageConfig_getRTCRoomType(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessageConfigPtr arg1 ;
  floo::BMXMessageConfigPtr *argp1 = *(floo::BMXMessageConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  floo::BMXMessageConfig::RTCRoomType result;
  
  result = (floo::BMXMessageConfig::RTCRoomType)(arg1)->getRTCRoomType();
  imresult = (int)result; 
  return imresult;
}

NSString* _wrap_BMXMessageConfig_getRTCPin(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessageConfigPtr arg1 ;
  floo::BMXMessageConfigPtr *argp1 = *(floo::BMXMessageConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string result;
  
  result = (arg1)->getRTCPin();
  imresult = [NSString stringWithUTF8String: (&result)->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}


void* _wrap_BMXMessageConfig_createMessageConfig(BOOL imarg1) {
  bool arg1 ;
  void* imresult = 0 ;
  floo::BMXMessageConfigPtr *temp ;
  std::shared_ptr< floo::BMXMessageConfig > result;
  
  arg1 = imarg1? true : false; 
  result = floo::BMXMessageConfig::createMessageConfig(arg1);
  
  BMXMessageConfig2Void(result)
  imresult = (void*)lresult; 
  
  return imresult;
}

NSString* _wrap_encodeBMXMessageConfig(void* imarg1) {
  SwigValueWrapper< std::shared_ptr< floo::BMXMessageConfig > > arg1 ;
  floo::BMXMessageConfigPtr *argp1 ;
  NSString* imresult = 0 ;
  std::string result;
  
  
  argp1 = (floo::BMXMessageConfigPtr *)imarg1;
  arg1 = *argp1; 
  
  result = floo::encodeBMXMessageConfig(arg1);
  imresult = [NSString stringWithUTF8String: (&result)->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void* _wrap_decodeBMXMessageConfig(NSString* imarg1) {
  std::string *arg1 = 0 ;
  void* imresult = 0 ;
  floo::BMXMessageConfigPtr *temp ;
  std::shared_ptr< floo::BMXMessageConfig > result;
  
  if(!imarg1) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg1_str(getStdString(imarg1));
  arg1 = &arg1_str; 
  
  result = floo::decodeBMXMessageConfig((std::string const &)*arg1);
  
  BMXMessageConfig2Void(result)
  imresult = (void*)lresult; 
  
  return imresult;
}

void _wrap_delete_BMXMessage(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  delete argp1;
}

long long _wrap_BMXMessage_msgId(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  long long imresult = 0 ;
  int64_t result;
  
  result = (int64_t)(arg1)->msgId();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

long long _wrap_BMXMessage_clientMsgId(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  long long imresult = 0 ;
  int64_t result;
  
  result = (int64_t)(arg1)->clientMsgId();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

long long _wrap_BMXMessage_fromId(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  long long imresult = 0 ;
  int64_t result;
  
  result = (int64_t)(arg1)->fromId();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

long long _wrap_BMXMessage_toId(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  long long imresult = 0 ;
  int64_t result;
  
  result = (int64_t)(arg1)->toId();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

int _wrap_BMXMessage_type(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  floo::BMXMessage::MessageType result;
  
  result = (floo::BMXMessage::MessageType)(arg1)->type();
  imresult = (int)result; 
  return imresult;
}

long long _wrap_BMXMessage_conversationId(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  long long imresult = 0 ;
  int64_t result;
  
  result = (int64_t)(arg1)->conversationId();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

int _wrap_BMXMessage_deliveryStatus(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  floo::BMXMessage::DeliveryStatus result;
  
  result = (floo::BMXMessage::DeliveryStatus)(arg1)->deliveryStatus();
  imresult = (int)result; 
  return imresult;
}

void _wrap_BMXMessage_setDeliveryStatus(void* imarg1, int imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  floo::BMXMessage::DeliveryStatus arg2 ;
  
  arg2 = (floo::BMXMessage::DeliveryStatus)imarg2; 
  (arg1)->setDeliveryStatus(arg2);
}

long long _wrap_BMXMessage_serverTimestamp(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  long long imresult = 0 ;
  int64_t result;
  
  result = (int64_t)(arg1)->serverTimestamp();
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_BMXMessage_setServerTimestamp(void* imarg1, long long imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int64_t arg2 ;
  
  arg2 = (int64_t)imarg2;
  (arg1)->setServerTimestamp(arg2);
}

long long _wrap_BMXMessage_editTimestamp(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  long long imresult = 0 ;
  int64_t result;
  
  result = (int64_t)(arg1)->editTimestamp();
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_BMXMessage_setEditTimestamp(void* imarg1, long long imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int64_t arg2 ;
  
  arg2 = (int64_t)imarg2;
  (arg1)->setEditTimestamp(arg2);
}

long long _wrap_BMXMessage_clientTimestamp(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  long long imresult = 0 ;
  int64_t result;
  
  result = (int64_t)(arg1)->clientTimestamp();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXMessage_setClientTimestamp(void* imarg1, long long imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int64_t arg2 ;
  
  arg2 = (int64_t)imarg2; 
  (arg1)->setClientTimestamp(arg2);
}

BOOL _wrap_BMXMessage_isPlayed(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BOOL imresult = 0 ;
  bool result;
  
  result = (bool)(arg1)->isPlayed();
  imresult = (result)? YES:NO; 
  return imresult;
}

void _wrap_BMXMessage_setIsPlayed(void* imarg1, BOOL imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  bool arg2 ;
  
  arg2 = imarg2? true : false; 
  (arg1)->setIsPlayed(arg2);
}

BOOL _wrap_BMXMessage_isPlayAcked(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BOOL imresult = 0 ;
  bool result;
  
  result = (bool)(arg1)->isPlayAcked();
  imresult = (result)? YES:NO; 
  return imresult;
}

void _wrap_BMXMessage_setIsPlayAcked(void* imarg1, BOOL imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  bool arg2 ;
  
  arg2 = imarg2? true : false; 
  (arg1)->setIsPlayAcked(arg2);
}

BOOL _wrap_BMXMessage_isReceiveMsg(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BOOL imresult = 0 ;
  bool result;
  
  result = (bool)(arg1)->isReceiveMsg();
  imresult = (result)? YES:NO; 
  return imresult;
}

void _wrap_BMXMessage_setIsReceiveMsg(void* imarg1, BOOL imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  bool arg2 ;
  
  arg2 = imarg2? true : false; 
  (arg1)->setIsReceiveMsg(arg2);
}

BOOL _wrap_BMXMessage_isRead(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BOOL imresult = 0 ;
  bool result;
  
  result = (bool)(arg1)->isRead();
  imresult = (result)? YES:NO; 
  return imresult;
}

void _wrap_BMXMessage_setIsRead(void* imarg1, BOOL imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  bool arg2 ;
  
  arg2 = imarg2? true : false; 
  (arg1)->setIsRead(arg2);
}

BOOL _wrap_BMXMessage_isReadAcked(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BOOL imresult = 0 ;
  bool result;
  
  result = (bool)(arg1)->isReadAcked();
  imresult = (result)? YES:NO; 
  return imresult;
}

void _wrap_BMXMessage_setIsReadAcked(void* imarg1, BOOL imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  bool arg2 ;
  
  arg2 = imarg2? true : false; 
  (arg1)->setIsReadAcked(arg2);
}

BOOL _wrap_BMXMessage_isDeliveryAcked(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BOOL imresult = 0 ;
  bool result;
  
  result = (bool)(arg1)->isDeliveryAcked();
  imresult = (result)? YES:NO; 
  return imresult;
}

void _wrap_BMXMessage_setIsDeliveryAcked(void* imarg1, BOOL imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  bool arg2 ;
  
  arg2 = imarg2? true : false; 
  (arg1)->setIsDeliveryAcked(arg2);
}

NSString* _wrap_BMXMessage_content(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &(arg1)->content();
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXMessage_setContent(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  (arg1)->setContent((std::string const &)*arg2);
}

NSString* _wrap_BMXMessage_appendedContent(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &(arg1)->appendedContent();
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXMessage_setAppendedContent(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str;
  
  (arg1)->setAppendedContent((std::string const &)*arg2);
}

NSString* _wrap_BMXMessage_replaceContent(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &(arg1)->replaceContent();
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXMessage_setReplaceContent(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str;
  
  (arg1)->setReplaceContent((std::string const &)*arg2);
}

int _wrap_BMXMessage_contentType(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  floo::BMXMessage::ContentType result;
  
  result = (floo::BMXMessage::ContentType)(arg1)->contentType();
  imresult = (int)result; 
  return imresult;
}

void* _wrap_BMXMessage_attachment(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  void* imresult = 0 ;
  floo::BMXMessageAttachmentPtr *temp ;
  std::shared_ptr< floo::BMXMessageAttachment > result;
  
  result = (arg1)->attachment();
  
  BMXMessageAttachment2Void(result)
  imresult = (void*)lresult; 
  
  return imresult;
}

void* _wrap_BMXMessage_config(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  void* imresult = 0 ;
  floo::BMXMessageConfigPtr *temp ;
  std::shared_ptr< floo::BMXMessageConfig > result;
  
  result = (arg1)->config();
  
  BMXMessageConfig2Void(result)
  imresult = (void*)lresult; 
  
  return imresult;
}

void _wrap_BMXMessage_setConfig(void* imarg1, void* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  SwigValueWrapper< std::shared_ptr< floo::BMXMessageConfig > > arg2 ;
  floo::BMXMessageConfigPtr *argp2 ;
  
  
  argp2 = (floo::BMXMessageConfigPtr *)imarg2;
  arg2 = *argp2; 
  
  (arg1)->setConfig(arg2);
}

void* _wrap_BMXMessage_replaceConfig(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  void* imresult = 0 ;
  floo::BMXMessageConfigPtr *temp ;
  std::shared_ptr< floo::BMXMessageConfig > result;
  
  result = (arg1)->replaceConfig();
  
  BMXMessageConfig2Void(result)
  imresult = (void*)lresult;
  
  return imresult;
}

void _wrap_BMXMessage_setReplaceConfig(void* imarg1, void* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  SwigValueWrapper< std::shared_ptr< floo::BMXMessageConfig > > arg2 ;
  floo::BMXMessageConfigPtr *argp2 ;
  
  
  argp2 = (floo::BMXMessageConfigPtr *)imarg2;
  arg2 = *argp2;
  
  (arg1)->setReplaceConfig(arg2);
}

NSString* _wrap_BMXMessage_replaceExtension(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &(arg1)->replaceExtension();
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXMessage_setReplaceExtension(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str;
  
  (arg1)->setReplaceExtension((std::string const &)*arg2);
}

NSString* _wrap_BMXMessage_extension(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  floo::JSON *result = 0 ;
  
  result = (floo::JSON *) &(arg1)->extension();
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXMessage_setExtension(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  floo::JSON *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  (arg1)->setExtension((floo::JSON const &)*arg2);
}

int _wrap_BMXMessage_deliveryQos(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  floo::BMXMessage::DeliveryQos result;
  
  result = (floo::BMXMessage::DeliveryQos)(arg1)->deliveryQos();
  imresult = (int)result; 
  return imresult;
}

void _wrap_BMXMessage_setDeliveryQos(void* imarg1, int imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  floo::BMXMessage::DeliveryQos arg2 ;
  
  arg2 = (floo::BMXMessage::DeliveryQos)imarg2; 
  (arg1)->setDeliveryQos(arg2);
}

NSString* _wrap_BMXMessage_senderName(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &(arg1)->senderName();
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXMessage_setSenderName(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  (arg1)->setSenderName((std::string const &)*arg2);
}

int _wrap_BMXMessage_groupAckCount(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  int result;
  
  result = (int)(arg1)->groupAckCount();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXMessage_setGroupAckCount(void* imarg1, int imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int arg2 ;
  
  arg2 = (int)imarg2; 
  (arg1)->setGroupAckCount(arg2);
}

int _wrap_BMXMessage_groupAckUnreadCount(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  int result;
  
  result = (int)(arg1)->groupAckUnreadCount();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXMessage_setGroupAckUnreadCount(void* imarg1, int imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int arg2 ;
  
  arg2 = (int)imarg2; 
  (arg1)->setGroupAckUnreadCount(arg2);
}

BOOL _wrap_BMXMessage_groupAckReadAll(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BOOL imresult = 0 ;
  bool result;
  
  result = (bool)(arg1)->groupAckReadAll();
  imresult = (result)? YES:NO; 
  return imresult;
}

int _wrap_BMXMessage_groupPlayAckCount(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  int result;
  
  result = (int)(arg1)->groupPlayAckCount();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXMessage_setGroupPlayAckCount(void* imarg1, int imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int arg2 ;
  
  arg2 = (int)imarg2; 
  (arg1)->setGroupPlayAckCount(arg2);
}

int _wrap_BMXMessage_groupPlayAckUnreadCount(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  int result;
  
  result = (int)(arg1)->groupPlayAckUnreadCount();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXMessage_setGroupPlayAckUnreadCount(void* imarg1, int imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int arg2 ;
  
  arg2 = (int)imarg2; 
  (arg1)->setGroupPlayAckUnreadCount(arg2);
}

BOOL _wrap_BMXMessage_groupPlayAckReadAll(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BOOL imresult = 0 ;
  bool result;
  
  result = (bool)(arg1)->groupPlayAckReadAll();
  imresult = (result)? YES:NO; 
  return imresult;
}

void _wrap_BMXMessage_setPriority(void* imarg1, int imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int arg2 ;
  
  arg2 = (int)imarg2; 
  (arg1)->setPriority(arg2);
}

int _wrap_BMXMessage_priority(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  int result;
  
  result = (int)(arg1)->priority();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXMessage_setPushMessageMode(void* imarg1, BOOL imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  bool arg2 ;
  
  arg2 = imarg2? true : false; 
  (arg1)->setPushMessageMode(arg2);
}

BOOL _wrap_BMXMessage_isPushMessage(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXMessagePtr arg1 ;
  floo::BMXMessagePtr *argp1 = *(floo::BMXMessagePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BOOL imresult = 0 ;
  bool result;
  
  result = (bool)(arg1)->isPushMessage();
  imresult = (result)? YES:NO; 
  return imresult;
}

void* _wrap_BMXMessage_createMessage__SWIG_0(long long imarg1, long long imarg2, int imarg3, long long imarg4, NSString* imarg5) {
  int64_t arg1 ;
  int64_t arg2 ;
  floo::BMXMessage::MessageType arg3 ;
  int64_t arg4 ;
  std::string *arg5 = 0 ;
  void* imresult = 0 ;
  floo::BMXMessagePtr *temp ;
  std::shared_ptr< floo::BMXMessage > result;
  
  arg1 = (int64_t)imarg1; 
  arg2 = (int64_t)imarg2; 
  arg3 = (floo::BMXMessage::MessageType)imarg3; 
  arg4 = (int64_t)imarg4; 
  if(!imarg5) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg5_str(getStdString(imarg5));
  arg5 = &arg5_str;
  
  result = floo::BMXMessage::createMessage(arg1,arg2,arg3,arg4,(std::string const &)*arg5);
  
  BMXMessage2Void(result)
  imresult = (void*)lresult;

  return imresult;
}

void* _wrap_BMXMessage_createMessage__SWIG_1(long long imarg1, long long imarg2, int imarg3, long long imarg4, void* imarg5, int type) {
  int64_t arg1 ;
  int64_t arg2 ;
  floo::BMXMessage::MessageType arg3 ;
  int64_t arg4 ;
  void* imresult = 0 ;
  std::shared_ptr< floo::BMXMessage > result;
  
  arg1 = (int64_t)imarg1; 
  arg2 = (int64_t)imarg2; 
  arg3 = (floo::BMXMessage::MessageType)imarg3; 
  arg4 = (int64_t)imarg4; 
  
    long long lPtr = (long long)(imarg5);
    switch ((floo::BMXMessageAttachment::Type)type) {
        case floo::BMXMessageAttachment::Type::File :
        {
            floo::BMXFileAttachmentPtr file ;
            floo::BMXFileAttachmentPtr *pFile = *(floo::BMXFileAttachmentPtr **)&lPtr;
            if (pFile) file = *pFile;
            result = floo::BMXMessage::createMessage(arg1,arg2,arg3,arg4,file);
            break;
        }
        case floo::BMXMessageAttachment::Type::Image :
        {
            floo::BMXImageAttachmentPtr image ;
            floo::BMXImageAttachmentPtr *pImage = *(floo::BMXImageAttachmentPtr **)&lPtr;
            if (pImage) image = *pImage;
            result = floo::BMXMessage::createMessage(arg1,arg2,arg3,arg4,image);
            break;
        }
        case floo::BMXMessageAttachment::Type::Video :
        {
            floo::BMXVideoAttachmentPtr video ;
            floo::BMXVideoAttachmentPtr *pVideo = *(floo::BMXVideoAttachmentPtr **)&lPtr;
            if (pVideo) video = *pVideo;
            result = floo::BMXMessage::createMessage(arg1,arg2,arg3,arg4,video);
            break;
        }
        case floo::BMXMessageAttachment::Type::Voice :
        {
            floo::BMXVoiceAttachmentPtr voice ;
            floo::BMXVoiceAttachmentPtr *pVoice = *(floo::BMXVoiceAttachmentPtr **)&lPtr;
            if (pVoice) voice = *pVoice;
            result = floo::BMXMessage::createMessage(arg1,arg2,arg3,arg4,voice);
            break;
        }
        case floo::BMXMessageAttachment::Type::Location :
        {
            floo::BMXLocationAttachmentPtr loc ;
            floo::BMXLocationAttachmentPtr *pLoc = *(floo::BMXLocationAttachmentPtr **)&lPtr;
            if (pLoc) loc = *pLoc;
            result = floo::BMXMessage::createMessage(arg1,arg2,arg3,arg4,loc);
            break;
        }
        default:
        {
            break;
        }
    }
     
      
  BMXMessage2Void(result)
  imresult = (void*)lresult;

  return imresult;
}

void* _wrap_BMXMessage_createCommandMessage__SWIG_0(long long imarg1, long long imarg2, int imarg3, long long imarg4, NSString* imarg5) {
  int64_t arg1 ;
  int64_t arg2 ;
  floo::BMXMessage::MessageType arg3 ;
  int64_t arg4 ;
  std::string *arg5 = 0 ;
  void* imresult = 0 ;
  floo::BMXMessagePtr *temp ;
  std::shared_ptr< floo::BMXMessage > result;
  
  arg1 = (int64_t)imarg1; 
  arg2 = (int64_t)imarg2; 
  arg3 = (floo::BMXMessage::MessageType)imarg3; 
  arg4 = (int64_t)imarg4; 
  if(!imarg5) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg5_str(getStdString(imarg5));
  arg5 = &arg5_str;

  result = floo::BMXMessage::createCommandMessage(arg1,arg2,arg3,arg4,(std::string const &)*arg5);
  
  BMXMessage2Void(result)
  imresult = (void*)lresult;

  return imresult;
}

void* _wrap_BMXMessage_createRTCMessage__SWIG_0(long long imarg1, long long imarg2, int imarg3, long long imarg4, NSString* imarg5) {
  int64_t arg1 ;
  int64_t arg2 ;
  floo::BMXMessage::MessageType arg3 ;
  int64_t arg4 ;
  std::string *arg5 = 0 ;
  void* imresult = 0 ;
  floo::BMXMessagePtr *temp ;
  std::shared_ptr< floo::BMXMessage > result;
  
  arg1 = (int64_t)imarg1; 
  arg2 = (int64_t)imarg2; 
  arg3 = (floo::BMXMessage::MessageType)imarg3; 
  arg4 = (int64_t)imarg4; 
  if(!imarg5) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg5_str(getStdString(imarg5));
   arg5 = &arg5_str; 
  
  result = floo::BMXMessage::createRTCMessage(arg1,arg2,arg3,arg4,(std::string const &)*arg5);
  
  BMXMessage2Void(result)
  imresult = (void*)lresult; 
  
  return imresult;
}

void* _wrap_BMXMessage_createMessage__SWIG_2(long long imarg1, long long imarg2, long long imarg3, int imarg4, long long imarg5, NSString* imarg6, long long imarg7) {
  int64_t arg1 ;
  int64_t arg2 ;
  int64_t arg3 ;
  floo::BMXMessage::MessageType arg4 ;
  int64_t arg5 ;
  std::string *arg6 = 0 ;
  int64_t arg7 ;
  void* imresult = 0 ;
  floo::BMXMessagePtr *temp ;
  std::shared_ptr< floo::BMXMessage > result;
  
  arg1 = (int64_t)imarg1; 
  arg2 = (int64_t)imarg2; 
  arg3 = (int64_t)imarg3; 
  arg4 = (floo::BMXMessage::MessageType)imarg4; 
  arg5 = (int64_t)imarg5; 
  if(!imarg6) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg6_str(getStdString(imarg6));
  arg6 = &arg6_str;

  arg7 = (int64_t)imarg7; 
  result = floo::BMXMessage::createMessage(arg1,arg2,arg3,arg4,arg5,(std::string const &)*arg6,arg7);
  
  BMXMessage2Void(result)
  imresult = (void*)lresult;

  return imresult;
}

void* _wrap_BMXMessage_createMessage__SWIG_3(long long imarg1, long long imarg2, long long imarg3, int imarg4, long long imarg5, void* imarg6, long long imarg7, int type) {
  int64_t arg1 ;
  int64_t arg2 ;
  int64_t arg3 ;
  floo::BMXMessage::MessageType arg4 ;
  int64_t arg5 ;
  int64_t arg7 ;
  void* imresult = 0 ;
  std::shared_ptr< floo::BMXMessage > result;
  
  arg1 = (int64_t)imarg1; 
  arg2 = (int64_t)imarg2; 
  arg3 = (int64_t)imarg3; 
  arg4 = (floo::BMXMessage::MessageType)imarg4; 
  arg5 = (int64_t)imarg5; 
  
  
  arg7 = (int64_t)imarg7;
    
    long long lPtr = (long long)(imarg5);
    switch ((floo::BMXMessageAttachment::Type)type) {
        case floo::BMXMessageAttachment::Type::File :
        {
            floo::BMXFileAttachmentPtr file ;
            floo::BMXFileAttachmentPtr *pFile = *(floo::BMXFileAttachmentPtr **)&lPtr;
            if (pFile) file = *pFile;
            result = floo::BMXMessage::createMessage(arg1,arg2,arg3,arg4,arg5,file,arg7);
            break;
        }
        case floo::BMXMessageAttachment::Type::Image :
        {
            floo::BMXImageAttachmentPtr image ;
            floo::BMXImageAttachmentPtr *pImage = *(floo::BMXImageAttachmentPtr **)&lPtr;
            if (pImage) image = *pImage;
            result = floo::BMXMessage::createMessage(arg1,arg2,arg3,arg4,arg5,image,arg7);
            break;
        }
        case floo::BMXMessageAttachment::Type::Video :
        {
            floo::BMXVideoAttachmentPtr video ;
            floo::BMXVideoAttachmentPtr *pVideo = *(floo::BMXVideoAttachmentPtr **)&lPtr;
            if (pVideo) video = *pVideo;
            result = floo::BMXMessage::createMessage(arg1,arg2,arg3,arg4,arg5,video,arg7);
            break;
        }
        case floo::BMXMessageAttachment::Type::Voice :
        {
            floo::BMXVoiceAttachmentPtr voice ;
            floo::BMXVoiceAttachmentPtr *pVoice = *(floo::BMXVoiceAttachmentPtr **)&lPtr;
            if (pVoice) voice = *pVoice;
            result = floo::BMXMessage::createMessage(arg1,arg2,arg3,arg4,arg5,voice,arg7);
            break;
        }
        default:
        {
            break;
        }
    }

  
  BMXMessage2Void(result)
  imresult = (void*)lresult;

  return imresult;
}

void* _wrap_BMXMessage_createCommandMessage__SWIG_1(long long imarg1, long long imarg2, long long imarg3, int imarg4, long long imarg5, NSString* imarg6, long long imarg7) {
  int64_t arg1 ;
  int64_t arg2 ;
  int64_t arg3 ;
  floo::BMXMessage::MessageType arg4 ;
  int64_t arg5 ;
  std::string *arg6 = 0 ;
  int64_t arg7 ;
  void* imresult = 0 ;
  floo::BMXMessagePtr *temp ;
  std::shared_ptr< floo::BMXMessage > result;
  
  arg1 = (int64_t)imarg1; 
  arg2 = (int64_t)imarg2; 
  arg3 = (int64_t)imarg3; 
  arg4 = (floo::BMXMessage::MessageType)imarg4; 
  arg5 = (int64_t)imarg5; 
  if(!imarg6) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg6_str(getStdString(imarg6));
  arg6 = &arg6_str;

  arg7 = (int64_t)imarg7; 
  result = floo::BMXMessage::createCommandMessage(arg1,arg2,arg3,arg4,arg5,(std::string const &)*arg6,arg7);
  
  BMXMessage2Void(result)
  imresult = (void*)lresult;

  return imresult;
}

void* _wrap_BMXMessage_createRTCMessage__SWIG_1(long long imarg1, long long imarg2, long long imarg3, int imarg4, long long imarg5, NSString* imarg6, long long imarg7) {
  int64_t arg1 ;
  int64_t arg2 ;
  int64_t arg3 ;
  floo::BMXMessage::MessageType arg4 ;
  int64_t arg5 ;
  std::string *arg6 = 0 ;
  int64_t arg7 ;
  void* imresult = 0 ;
  floo::BMXMessagePtr *temp ;
  std::shared_ptr< floo::BMXMessage > result;
  
  arg1 = (int64_t)imarg1; 
  arg2 = (int64_t)imarg2; 
  arg3 = (int64_t)imarg3; 
  arg4 = (floo::BMXMessage::MessageType)imarg4; 
  arg5 = (int64_t)imarg5; 
  if(!imarg6) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg6_str(getStdString(imarg6));
   arg6 = &arg6_str; 
  
  arg7 = (int64_t)imarg7; 
  result = floo::BMXMessage::createRTCMessage(arg1,arg2,arg3,arg4,arg5,(std::string const &)*arg6,arg7);
  
  BMXMessage2Void(result)
  imresult = (void*)lresult; 
  
  return imresult;
}

void* _wrap_BMXMessage_createForwardMessage(void* imarg1, long long imarg2, long long imarg3, int imarg4, long long imarg5) {
  SwigValueWrapper< std::shared_ptr< floo::BMXMessage > > arg1 ;
  int64_t arg2 ;
  int64_t arg3 ;
  floo::BMXMessage::MessageType arg4 ;
  int64_t arg5 ;
  floo::BMXMessagePtr *argp1 ;
  void* imresult = 0 ;
  floo::BMXMessagePtr *temp ;
  std::shared_ptr< floo::BMXMessage > result;
  
  
  argp1 = (floo::BMXMessagePtr *)imarg1;
  arg1 = *argp1; 
  
  arg2 = (int64_t)imarg2; 
  arg3 = (int64_t)imarg3; 
  arg4 = (floo::BMXMessage::MessageType)imarg4; 
  arg5 = (int64_t)imarg5; 
  result = floo::BMXMessage::createForwardMessage(arg1,arg2,arg3,arg4,arg5);
  
  BMXMessage2Void(result)
  imresult = (void*)lresult;

  return imresult;
}

void _wrap_delete_BMXConversation(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXConversationPtr arg1 ;
  floo::BMXConversationPtr *argp1 = *(floo::BMXConversationPtr **)&larg1;
  delete argp1;
}

long long _wrap_BMXConversation_conversationId(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXConversationPtr arg1 ;
  floo::BMXConversationPtr *argp1 = *(floo::BMXConversationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  long long imresult = 0 ;
  int64_t result;
  
  result = (int64_t)(arg1)->conversationId();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

int _wrap_BMXConversation_type(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXConversationPtr arg1 ;
  floo::BMXConversationPtr *argp1 = *(floo::BMXConversationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  floo::BMXConversation::Type result;
  
  result = (floo::BMXConversation::Type)(arg1)->type();
  imresult = (int)result; 
  return imresult;
}

void* _wrap_BMXConversation_lastMsg(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXConversationPtr arg1 ;
  floo::BMXConversationPtr *argp1 = *(floo::BMXConversationPtr **)&larg1;
  if (argp1) arg1 = *argp1;

  void* imresult = 0 ;
  floo::BMXMessagePtr *temp ;
  std::shared_ptr< floo::BMXMessage > result;
  
  result = (arg1)->lastMsg();
  
  BMXMessage2Void(result)
  imresult = (void*)lresult; 
  
  return imresult;
}

int _wrap_BMXConversation_unreadNumber(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXConversationPtr arg1 ;
  floo::BMXConversationPtr *argp1 = *(floo::BMXConversationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  int32_t result;
  
  result = (int32_t)(arg1)->unreadNumber();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

int _wrap_BMXConversation_messageCount(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXConversationPtr arg1 ;
  floo::BMXConversationPtr *argp1 = *(floo::BMXConversationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  int32_t result;
  
  result = (int32_t)(arg1)->messageCount();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

BOOL _wrap_BMXConversation_isMuteNotification(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXConversationPtr arg1 ;
  floo::BMXConversationPtr *argp1 = *(floo::BMXConversationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BOOL imresult = 0 ;
  bool result;
  
  result = (bool)(arg1)->isMuteNotification();
  imresult = (result)? YES:NO; 
  return imresult;
}

NSString* _wrap_BMXConversation_extension(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXConversationPtr arg1 ;
  floo::BMXConversationPtr *argp1 = *(floo::BMXConversationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  floo::JSON *result = 0 ;
  
  result = (floo::JSON *) &(arg1)->extension();
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

int _wrap_BMXConversation_setExtension(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXConversationPtr arg1 ;
  floo::BMXConversationPtr *argp1 = *(floo::BMXConversationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  result = (floo::BMXErrorCode)(arg1)->setExtension((std::string const &)*arg2);
  imresult = (int)result; 
  return imresult;
}

NSString* _wrap_BMXConversation_editMessage(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXConversationPtr arg1 ;
  floo::BMXConversationPtr *argp1 = *(floo::BMXConversationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &(arg1)->editMessage();
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

int _wrap_BMXConversation_setEditMessage(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXConversationPtr arg1 ;
  floo::BMXConversationPtr *argp1 = *(floo::BMXConversationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  result = (floo::BMXErrorCode)(arg1)->setEditMessage((std::string const &)*arg2);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXConversation_setMessagePlayedStatus(void* imarg1, void* imarg2, BOOL imarg3) {
  long long larg1 = (long long)imarg1;
  floo::BMXConversationPtr arg1 ;
  floo::BMXConversationPtr *argp1 = *(floo::BMXConversationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  SwigValueWrapper< std::shared_ptr< floo::BMXMessage > > arg2 ;
  bool arg3 ;
  floo::BMXMessagePtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  
  argp2 = (floo::BMXMessagePtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = imarg3? true : false; 
  result = (floo::BMXErrorCode)(arg1)->setMessagePlayedStatus(arg2,arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXConversation_setMessageReadStatus(void* imarg1, void* imarg2, BOOL imarg3) {
  long long larg1 = (long long)imarg1;
  floo::BMXConversationPtr arg1 ;
  floo::BMXConversationPtr *argp1 = *(floo::BMXConversationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  SwigValueWrapper< std::shared_ptr< floo::BMXMessage > > arg2 ;
  bool arg3 ;
  floo::BMXMessagePtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  
  argp2 = (floo::BMXMessagePtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = imarg3? true : false; 
  result = (floo::BMXErrorCode)(arg1)->setMessageReadStatus(arg2,arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXConversation_setAllMessagesRead(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXConversationPtr arg1 ;
  floo::BMXConversationPtr *argp1 = *(floo::BMXConversationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  result = (floo::BMXErrorCode)(arg1)->setAllMessagesRead();
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXConversation_updateMessageExtension(void* imarg1, void* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXConversationPtr arg1 ;
  floo::BMXConversationPtr *argp1 = *(floo::BMXConversationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  SwigValueWrapper< std::shared_ptr< floo::BMXMessage > > arg2 ;
  floo::BMXMessagePtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  
  argp2 = (floo::BMXMessagePtr *)imarg2;
  arg2 = *argp2; 
  
  result = (floo::BMXErrorCode)(arg1)->updateMessageExtension(arg2);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXConversation_insertMessage(void* imarg1, void* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXConversationPtr arg1 ;
  floo::BMXConversationPtr *argp1 = *(floo::BMXConversationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  SwigValueWrapper< std::shared_ptr< floo::BMXMessage > > arg2 ;
  floo::BMXMessagePtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  
  argp2 = (floo::BMXMessagePtr *)imarg2;
  arg2 = *argp2; 
  
  result = (floo::BMXErrorCode)(arg1)->insertMessage(arg2);
  imresult = (int)result; 
  return imresult;
}

void* _wrap_BMXConversation_loadMessage(void* imarg1, long long imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXConversationPtr arg1 ;
  floo::BMXConversationPtr *argp1 = *(floo::BMXConversationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int64_t arg2 ;
  void* imresult = 0 ;
  floo::BMXMessagePtr *temp ;
  std::shared_ptr< floo::BMXMessage > result;
  
  arg2 = (int64_t)imarg2; 
  result = (arg1)->loadMessage(arg2);
  
  BMXMessage2Void(result)
  imresult = (void*)lresult; 
  
  return imresult;
}

int _wrap_BMXConversation_removeAllMessages(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXConversationPtr arg1 ;
  floo::BMXConversationPtr *argp1 = *(floo::BMXConversationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  result = (floo::BMXErrorCode)(arg1)->removeAllMessages();
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXConversation_loadMessages__SWIG_0(void* imarg1, long long imarg2, unsigned long imarg3, void* imarg4, int imarg5) {
  long long larg1 = (long long)imarg1;
  floo::BMXConversationPtr arg1 ;
  floo::BMXConversationPtr *argp1 = *(floo::BMXConversationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int64_t arg2 ;
  size_t arg3 ;
  floo::BMXMessageList *arg4 = 0 ;
  floo::BMXConversation::Direction arg5 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg2 = (int64_t)imarg2; 
  arg3 = (size_t)imarg3; 
  arg4 = (floo::BMXMessageList *)imarg4; 
  arg5 = (floo::BMXConversation::Direction)imarg5; 
  result = (floo::BMXErrorCode)(arg1)->loadMessages(arg2,arg3,*arg4,arg5);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXConversation_loadMessages__SWIG_1(void* imarg1, long long imarg2, unsigned long imarg3, void* imarg4) {
  long long larg1 = (long long)imarg1;
  floo::BMXConversationPtr arg1 ;
  floo::BMXConversationPtr *argp1 = *(floo::BMXConversationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int64_t arg2 ;
  size_t arg3 ;
  floo::BMXMessageList *arg4 = 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg2 = (int64_t)imarg2; 
  arg3 = (size_t)imarg3; 
  arg4 = (floo::BMXMessageList *)imarg4; 
  result = (floo::BMXErrorCode)(arg1)->loadMessages(arg2,arg3,*arg4);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXConversation_searchMessagesByKeyWords__SWIG_0(void* imarg1, NSString* imarg2, long long imarg3, unsigned long imarg4, void* imarg5, int imarg6) {
  long long larg1 = (long long)imarg1;
  floo::BMXConversationPtr arg1 ;
  floo::BMXConversationPtr *argp1 = *(floo::BMXConversationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  int64_t arg3 ;
  size_t arg4 ;
  floo::BMXMessageList *arg5 = 0 ;
  floo::BMXConversation::Direction arg6 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  arg3 = (int64_t)imarg3; 
  arg4 = (size_t)imarg4; 
  arg5 = (floo::BMXMessageList *)imarg5; 
  arg6 = (floo::BMXConversation::Direction)imarg6; 
  result = (floo::BMXErrorCode)(arg1)->searchMessagesByKeyWords((std::string const &)*arg2,arg3,arg4,*arg5,arg6);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXConversation_searchMessagesByKeyWords__SWIG_1(void* imarg1, NSString* imarg2, long long imarg3, unsigned long imarg4, void* imarg5) {
  long long larg1 = (long long)imarg1;
  floo::BMXConversationPtr arg1 ;
  floo::BMXConversationPtr *argp1 = *(floo::BMXConversationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  int64_t arg3 ;
  size_t arg4 ;
  floo::BMXMessageList *arg5 = 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  arg3 = (int64_t)imarg3; 
  arg4 = (size_t)imarg4; 
  arg5 = (floo::BMXMessageList *)imarg5; 
  result = (floo::BMXErrorCode)(arg1)->searchMessagesByKeyWords((std::string const &)*arg2,arg3,arg4,*arg5);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXConversation_searchMessages__SWIG_0(void* imarg1, NSString* imarg2, long long imarg3, unsigned long imarg4, void* imarg5, int imarg6) {
  long long larg1 = (long long)imarg1;
  floo::BMXConversationPtr arg1 ;
  floo::BMXConversationPtr *argp1 = *(floo::BMXConversationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  int64_t arg3 ;
  size_t arg4 ;
  floo::BMXMessageList *arg5 = 0 ;
  floo::BMXConversation::Direction arg6 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  arg3 = (int64_t)imarg3; 
  arg4 = (size_t)imarg4; 
  arg5 = (floo::BMXMessageList *)imarg5; 
  arg6 = (floo::BMXConversation::Direction)imarg6; 
  result = (floo::BMXErrorCode)(arg1)->searchMessages((std::string const &)*arg2,arg3,arg4,*arg5,arg6);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXConversation_searchMessages__SWIG_1(void* imarg1, NSString* imarg2, long long imarg3, unsigned long imarg4, void* imarg5) {
  long long larg1 = (long long)imarg1;
  floo::BMXConversationPtr arg1 ;
  floo::BMXConversationPtr *argp1 = *(floo::BMXConversationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  int64_t arg3 ;
  size_t arg4 ;
  floo::BMXMessageList *arg5 = 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  arg3 = (int64_t)imarg3; 
  arg4 = (size_t)imarg4; 
  arg5 = (floo::BMXMessageList *)imarg5; 
  result = (floo::BMXErrorCode)(arg1)->searchMessages((std::string const &)*arg2,arg3,arg4,*arg5);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXConversation_searchMessagesByType__SWIG_0(void* imarg1, int imarg2, long long imarg3, unsigned long imarg4, void* imarg5, int imarg6) {
  long long larg1 = (long long)imarg1;
  floo::BMXConversationPtr arg1 ;
  floo::BMXConversationPtr *argp1 = *(floo::BMXConversationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  floo::BMXMessage::ContentType arg2 ;
  int64_t arg3 ;
  size_t arg4 ;
  floo::BMXMessageList *arg5 = 0 ;
  floo::BMXConversation::Direction arg6 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg2 = (floo::BMXMessage::ContentType)imarg2; 
  arg3 = (int64_t)imarg3; 
  arg4 = (size_t)imarg4; 
  arg5 = (floo::BMXMessageList *)imarg5; 
  arg6 = (floo::BMXConversation::Direction)imarg6; 
  result = (floo::BMXErrorCode)(arg1)->searchMessagesByType(arg2,arg3,arg4,*arg5,arg6);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXConversation_searchMessagesByType__SWIG_1(void* imarg1, int imarg2, long long imarg3, unsigned long imarg4, void* imarg5) {
  long long larg1 = (long long)imarg1;
  floo::BMXConversationPtr arg1 ;
  floo::BMXConversationPtr *argp1 = *(floo::BMXConversationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  floo::BMXMessage::ContentType arg2 ;
  int64_t arg3 ;
  size_t arg4 ;
  floo::BMXMessageList *arg5 = 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg2 = (floo::BMXMessage::ContentType)imarg2; 
  arg3 = (int64_t)imarg3; 
  arg4 = (size_t)imarg4; 
  arg5 = (floo::BMXMessageList *)imarg5; 
  result = (floo::BMXErrorCode)(arg1)->searchMessagesByType(arg2,arg3,arg4,*arg5);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXConversation_searchMessages__SWIG_2(void* imarg1, int imarg2, long long imarg3, unsigned long imarg4, void* imarg5, int imarg6) {
  long long larg1 = (long long)imarg1;
  floo::BMXConversationPtr arg1 ;
  floo::BMXConversationPtr *argp1 = *(floo::BMXConversationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  floo::BMXMessage::ContentType arg2 ;
  int64_t arg3 ;
  size_t arg4 ;
  floo::BMXMessageList *arg5 = 0 ;
  floo::BMXConversation::Direction arg6 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg2 = (floo::BMXMessage::ContentType)imarg2; 
  arg3 = (int64_t)imarg3; 
  arg4 = (size_t)imarg4; 
  arg5 = (floo::BMXMessageList *)imarg5; 
  arg6 = (floo::BMXConversation::Direction)imarg6; 
  result = (floo::BMXErrorCode)(arg1)->searchMessages(arg2,arg3,arg4,*arg5,arg6);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXConversation_searchMessages__SWIG_3(void* imarg1, int imarg2, long long imarg3, unsigned long imarg4, void* imarg5) {
  long long larg1 = (long long)imarg1;
  floo::BMXConversationPtr arg1 ;
  floo::BMXConversationPtr *argp1 = *(floo::BMXConversationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  floo::BMXMessage::ContentType arg2 ;
  int64_t arg3 ;
  size_t arg4 ;
  floo::BMXMessageList *arg5 = 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg2 = (floo::BMXMessage::ContentType)imarg2; 
  arg3 = (int64_t)imarg3; 
  arg4 = (size_t)imarg4; 
  arg5 = (floo::BMXMessageList *)imarg5; 
  result = (floo::BMXErrorCode)(arg1)->searchMessages(arg2,arg3,arg4,*arg5);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXConversation_refreshConversation(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXConversationPtr arg1 ;
  floo::BMXConversationPtr *argp1 = *(floo::BMXConversationPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  result = (floo::BMXErrorCode)(arg1)->refreshConversation();
  imresult = (int)result; 
  return imresult;
}

void* _wrap_new_BMXSDKConfig__SWIG_0(int imarg1, NSString* imarg2, NSString* imarg3, NSString* imarg4, NSString* imarg5, NSString* imarg6, NSString* imarg7, BOOL imarg8) {
  floo::BMXClientType arg1 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  std::string *arg5 = 0 ;
  std::string *arg6 = 0 ;
  std::string *arg7 = 0 ;
  bool arg8 ;
  void* imresult = 0 ;
  floo::BMXSDKConfig *result = 0 ;
  
  arg1 = (floo::BMXClientType)imarg1; 
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str; 
  
  if(!imarg4) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg4_str(getStdString(imarg4));
  arg4 = &arg4_str; 
  
  if(!imarg5) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg5_str(getStdString(imarg5));
  arg5 = &arg5_str; 
  
  if(!imarg6) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg6_str(getStdString(imarg6));
  arg6 = &arg6_str; 
  
  if(!imarg7) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg7_str(getStdString(imarg7));
  arg7 = &arg7_str; 
  
  arg8 = imarg8? true : false; 
  result = (floo::BMXSDKConfig *)new floo::BMXSDKConfig(arg1,(std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4,(std::string const &)*arg5,(std::string const &)*arg6,(std::string const &)*arg7,arg8);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_BMXSDKConfig__SWIG_1(int imarg1, NSString* imarg2, NSString* imarg3, NSString* imarg4, NSString* imarg5, NSString* imarg6, NSString* imarg7) {
  floo::BMXClientType arg1 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  std::string *arg5 = 0 ;
  std::string *arg6 = 0 ;
  std::string *arg7 = 0 ;
  void* imresult = 0 ;
  floo::BMXSDKConfig *result = 0 ;
  
  arg1 = (floo::BMXClientType)imarg1; 
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str; 
  
  if(!imarg4) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg4_str(getStdString(imarg4));
  arg4 = &arg4_str; 
  
  if(!imarg5) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg5_str(getStdString(imarg5));
  arg5 = &arg5_str; 
  
  if(!imarg6) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg6_str(getStdString(imarg6));
  arg6 = &arg6_str; 
  
  if(!imarg7) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg7_str(getStdString(imarg7));
  arg7 = &arg7_str; 
  
  result = (floo::BMXSDKConfig *)new floo::BMXSDKConfig(arg1,(std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4,(std::string const &)*arg5,(std::string const &)*arg6,(std::string const &)*arg7);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_BMXSDKConfig__SWIG_2(int imarg1, NSString* imarg2, NSString* imarg3, NSString* imarg4, NSString* imarg5, NSString* imarg6, NSString* imarg7, NSString* imarg8, NSString* imarg9, BOOL imarg10) {
  floo::BMXClientType arg1 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  std::string *arg5 = 0 ;
  std::string *arg6 = 0 ;
  std::string *arg7 = 0 ;
  std::string *arg8 = 0 ;
  std::string *arg9 = 0 ;
  bool arg10 ;
  void* imresult = 0 ;
  floo::BMXSDKConfig *result = 0 ;
  
  arg1 = (floo::BMXClientType)imarg1; 
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str; 
  
  if(!imarg4) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg4_str(getStdString(imarg4));
  arg4 = &arg4_str; 
  
  if(!imarg5) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg5_str(getStdString(imarg5));
  arg5 = &arg5_str; 
  
  if(!imarg6) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg6_str(getStdString(imarg6));
  arg6 = &arg6_str; 
  
  if(!imarg7) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg7_str(getStdString(imarg7));
  arg7 = &arg7_str; 
  
  if(!imarg8) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg8_str(getStdString(imarg8));
  arg8 = &arg8_str; 
  
  if(!imarg9) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg9_str(getStdString(imarg9));
  arg9 = &arg9_str; 
  
  arg10 = imarg10? true : false; 
  result = (floo::BMXSDKConfig *)new floo::BMXSDKConfig(arg1,(std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4,(std::string const &)*arg5,(std::string const &)*arg6,(std::string const &)*arg7,(std::string const &)*arg8,(std::string const &)*arg9,arg10);

  BMXSDKConfig2Void(result)
  imresult = (void*)lresult;
  return imresult;
}

void* _wrap_new_BMXSDKConfig__SWIG_3(int imarg1, NSString* imarg2, NSString* imarg3, NSString* imarg4, NSString* imarg5, NSString* imarg6, NSString* imarg7, NSString* imarg8, NSString* imarg9) {
  floo::BMXClientType arg1 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  std::string *arg5 = 0 ;
  std::string *arg6 = 0 ;
  std::string *arg7 = 0 ;
  std::string *arg8 = 0 ;
  std::string *arg9 = 0 ;
  void* imresult = 0 ;
  floo::BMXSDKConfig *result = 0 ;
  
  arg1 = (floo::BMXClientType)imarg1; 
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str; 
  
  if(!imarg4) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg4_str(getStdString(imarg4));
  arg4 = &arg4_str; 
  
  if(!imarg5) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg5_str(getStdString(imarg5));
  arg5 = &arg5_str; 
  
  if(!imarg6) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg6_str(getStdString(imarg6));
  arg6 = &arg6_str; 
  
  if(!imarg7) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg7_str(getStdString(imarg7));
  arg7 = &arg7_str; 
  
  if(!imarg8) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg8_str(getStdString(imarg8));
  arg8 = &arg8_str; 
  
  if(!imarg9) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg9_str(getStdString(imarg9));
  arg9 = &arg9_str; 
  
  result = (floo::BMXSDKConfig *)new floo::BMXSDKConfig(arg1,(std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4,(std::string const &)*arg5,(std::string const &)*arg6,(std::string const &)*arg7,(std::string const &)*arg8,(std::string const &)*arg9);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_delete_BMXSDKConfig(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXSDKConfigPtr arg1 ;
  floo::BMXSDKConfigPtr *argp1 = *(floo::BMXSDKConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;

  delete argp1;
}

NSString* _wrap_BMXSDKConfig_getDataDir(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXSDKConfigPtr arg1 ;
  floo::BMXSDKConfigPtr *argp1 = *(floo::BMXSDKConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &(arg1)->getDataDir();
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_BMXSDKConfig_getCacheDir(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXSDKConfigPtr arg1 ;
  floo::BMXSDKConfigPtr *argp1 = *(floo::BMXSDKConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &(arg1)->getCacheDir();
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

int _wrap_BMXSDKConfig_getClientType(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXSDKConfigPtr arg1 ;
  floo::BMXSDKConfigPtr *argp1 = *(floo::BMXSDKConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  floo::BMXClientType result;
  
  result = (floo::BMXClientType)(arg1)->getClientType();
  imresult = (int)result; 
  return imresult;
}

NSString* _wrap_BMXSDKConfig_getVsn(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXSDKConfigPtr arg1 ;
  floo::BMXSDKConfigPtr *argp1 = *(floo::BMXSDKConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &(arg1)->getVsn();
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_BMXSDKConfig_getSDKVersion(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXSDKConfigPtr arg1 ;
  floo::BMXSDKConfigPtr *argp1 = *(floo::BMXSDKConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &(arg1)->getSDKVersion();
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_BMXSDKConfig_getPushCertName(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXSDKConfigPtr arg1 ;
  floo::BMXSDKConfigPtr *argp1 = *(floo::BMXSDKConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &(arg1)->getPushCertName();
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXSDKConfig_setPushCertName(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXSDKConfigPtr arg1 ;
  floo::BMXSDKConfigPtr *argp1 = *(floo::BMXSDKConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  (arg1)->setPushCertName((std::string const &)*arg2);
}

NSString* _wrap_BMXSDKConfig_getUserAgent(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXSDKConfigPtr arg1 ;
  floo::BMXSDKConfigPtr *argp1 = *(floo::BMXSDKConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &(arg1)->getUserAgent();
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

BOOL _wrap_BMXSDKConfig_carryUsernameInMessage(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXSDKConfigPtr arg1 ;
  floo::BMXSDKConfigPtr *argp1 = *(floo::BMXSDKConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BOOL imresult = 0 ;
  bool result;
  
  result = (bool)(arg1)->carryUsernameInMessage();
  imresult = (result)? YES:NO; 
  return imresult;
}

void _wrap_BMXSDKConfig_setCarryUsernameInMessage(void* imarg1, BOOL imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXSDKConfigPtr arg1 ;
  floo::BMXSDKConfigPtr *argp1 = *(floo::BMXSDKConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  bool arg2 ;
  
  arg2 = imarg2? true : false; 
  (arg1)->setCarryUsernameInMessage(arg2);
}

BOOL _wrap_BMXSDKConfig_enableDeliveryAck(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXSDKConfigPtr arg1 ;
  floo::BMXSDKConfigPtr *argp1 = *(floo::BMXSDKConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BOOL imresult = 0 ;
  bool result;
  
  result = (bool)(arg1)->enableDeliveryAck();
  imresult = (result)? YES:NO; 
  return imresult;
}

void _wrap_BMXSDKConfig_setEnableDeliveryAck(void* imarg1, BOOL imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXSDKConfigPtr arg1 ;
  floo::BMXSDKConfigPtr *argp1 = *(floo::BMXSDKConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  bool arg2 ;
  
  arg2 = imarg2? true : false; 
  (arg1)->setEnableDeliveryAck(arg2);
}

int _wrap_BMXSDKConfig_getLogLevel(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXSDKConfigPtr arg1 ;
  floo::BMXSDKConfigPtr *argp1 = *(floo::BMXSDKConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  floo::BMXLogLevel result;
  
  result = (floo::BMXLogLevel)(arg1)->getLogLevel();
  imresult = (int)result; 
  return imresult;
}

void _wrap_BMXSDKConfig_setLogLevel(void* imarg1, int imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXSDKConfigPtr arg1 ;
  floo::BMXSDKConfigPtr *argp1 = *(floo::BMXSDKConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  floo::BMXLogLevel arg2 ;
  
  arg2 = (floo::BMXLogLevel)imarg2; 
  (arg1)->setLogLevel(arg2);
}

BOOL _wrap_BMXSDKConfig_getConsoleOutput(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXSDKConfigPtr arg1 ;
  floo::BMXSDKConfigPtr *argp1 = *(floo::BMXSDKConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BOOL imresult = 0 ;
  bool result;
  
  result = (bool)(arg1)->getConsoleOutput();
  imresult = (result)? YES:NO; 
  return imresult;
}

void _wrap_BMXSDKConfig_setConsoleOutput(void* imarg1, BOOL imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXSDKConfigPtr arg1 ;
  floo::BMXSDKConfigPtr *argp1 = *(floo::BMXSDKConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  bool arg2 ;
  
  arg2 = imarg2? true : false; 
  (arg1)->setConsoleOutput(arg2);
}

void _wrap_BMXSDKConfig_setHostConfig(void* imarg1, void* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXSDKConfigPtr arg1 ;
  floo::BMXSDKConfigPtr *argp1 = *(floo::BMXSDKConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BMXSDKConfigHostConfig *arg2 = 0 ;
  
  arg2 = (BMXSDKConfigHostConfig *)imarg2; 
  (arg1)->setHostConfig((BMXSDKConfig::HostConfig const &)*arg2);
}

void* _wrap_BMXSDKConfig_getHostConfig(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXSDKConfigPtr arg1 ;
  floo::BMXSDKConfigPtr *argp1 = *(floo::BMXSDKConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  void* imresult = 0 ;
  BMXSDKConfigHostConfig *result = 0 ;
  
  result = (BMXSDKConfigHostConfig *) &(arg1)->getHostConfig();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

BOOL _wrap_BMXSDKConfig_getLoadAllServerConversations(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXSDKConfigPtr arg1 ;
  floo::BMXSDKConfigPtr *argp1 = *(floo::BMXSDKConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BOOL imresult = 0 ;
  bool result;
  
  result = (bool)(arg1)->getLoadAllServerConversations();
  imresult = (result)? YES:NO; 
  return imresult;
}

void _wrap_BMXSDKConfig_setLoadAllServerConversations__SWIG_0(void* imarg1, BOOL imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXSDKConfigPtr arg1 ;
  floo::BMXSDKConfigPtr *argp1 = *(floo::BMXSDKConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  bool arg2 ;
  
  arg2 = imarg2? true : false; 
  (arg1)->setLoadAllServerConversations(arg2);
}

void _wrap_BMXSDKConfig_setLoadAllServerConversations__SWIG_1(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXSDKConfigPtr arg1 ;
  floo::BMXSDKConfigPtr *argp1 = *(floo::BMXSDKConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  
  (arg1)->setLoadAllServerConversations();
}

NSString* _wrap_BMXSDKConfig_getDeviceUuid(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXSDKConfigPtr arg1 ;
  floo::BMXSDKConfigPtr *argp1 = *(floo::BMXSDKConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &(arg1)->getDeviceUuid();
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXSDKConfig_setDeviceUuid(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXSDKConfigPtr arg1 ;
  floo::BMXSDKConfigPtr *argp1 = *(floo::BMXSDKConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  (arg1)->setDeviceUuid((std::string const &)*arg2);
}

NSString* _wrap_BMXSDKConfig_getDBCryptoKey(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXSDKConfigPtr arg1 ;
  floo::BMXSDKConfigPtr *argp1 = *(floo::BMXSDKConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &(arg1)->getDBCryptoKey();
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXSDKConfig_setDBCryptoKey(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXSDKConfigPtr arg1 ;
  floo::BMXSDKConfigPtr *argp1 = *(floo::BMXSDKConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  (arg1)->setDBCryptoKey((std::string const &)*arg2);
}

BOOL _wrap_BMXSDKConfig_getVerifyCertificate(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXSDKConfigPtr arg1 ;
  floo::BMXSDKConfigPtr *argp1 = *(floo::BMXSDKConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BOOL imresult = 0 ;
  bool result;
  
  result = (bool)(arg1)->getVerifyCertificate();
  imresult = (result)? YES:NO; 
  return imresult;
}

void _wrap_BMXSDKConfig_setVerifyCertificate__SWIG_0(void* imarg1, BOOL imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXSDKConfigPtr arg1 ;
  floo::BMXSDKConfigPtr *argp1 = *(floo::BMXSDKConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  bool arg2 ;
  
  arg2 = imarg2? true : false; 
  (arg1)->setVerifyCertificate(arg2);
}

void _wrap_BMXSDKConfig_setVerifyCertificate__SWIG_1(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXSDKConfigPtr arg1 ;
  floo::BMXSDKConfigPtr *argp1 = *(floo::BMXSDKConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  
  (arg1)->setVerifyCertificate();
}

BOOL _wrap_BMXSDKConfig_getEnableDNS(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXSDKConfigPtr arg1 ;
  floo::BMXSDKConfigPtr *argp1 = *(floo::BMXSDKConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BOOL imresult = 0 ;
  bool result;
  
  result = (bool)(arg1)->getEnableDNS();
  imresult = (result)? YES:NO; 
  return imresult;
}

void _wrap_BMXSDKConfig_setEnableDNS__SWIG_0(void* imarg1, BOOL imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXSDKConfigPtr arg1 ;
  floo::BMXSDKConfigPtr *argp1 = *(floo::BMXSDKConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  bool arg2 ;
  
  arg2 = imarg2? true : false; 
  (arg1)->setEnableDNS(arg2);
}

void _wrap_BMXSDKConfig_setEnableDNS__SWIG_1(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXSDKConfigPtr arg1 ;
  floo::BMXSDKConfigPtr *argp1 = *(floo::BMXSDKConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  
  (arg1)->setEnableDNS();
}

NSString* _wrap_BMXSDKConfig_getUserDNSAddress(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXSDKConfigPtr arg1 ;
  floo::BMXSDKConfigPtr *argp1 = *(floo::BMXSDKConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string result;
  
  result = (arg1)->getUserDNSAddress();
  imresult = [NSString stringWithUTF8String: (&result)->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXSDKConfig_setUserDNSAddress(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXSDKConfigPtr arg1 ;
  floo::BMXSDKConfigPtr *argp1 = *(floo::BMXSDKConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  (arg1)->setUserDNSAddress((std::string const &)*arg2);
}

NSString* _wrap_BMXSDKConfig_getAppID(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXSDKConfigPtr arg1 ;
  floo::BMXSDKConfigPtr *argp1 = *(floo::BMXSDKConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string result;
  
  result = (arg1)->getAppID();
  imresult = [NSString stringWithUTF8String: (&result)->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXSDKConfig_setAppID(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXSDKConfigPtr arg1 ;
  floo::BMXSDKConfigPtr *argp1 = *(floo::BMXSDKConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  (arg1)->setAppID((std::string const &)*arg2);
}

NSString* _wrap_BMXSDKConfig_getAppSecret(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXSDKConfigPtr arg1 ;
  floo::BMXSDKConfigPtr *argp1 = *(floo::BMXSDKConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string result;
  
  result = (arg1)->getAppSecret();
  imresult = [NSString stringWithUTF8String: (&result)->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXSDKConfig_setAppSecret(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXSDKConfigPtr arg1 ;
  floo::BMXSDKConfigPtr *argp1 = *(floo::BMXSDKConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  (arg1)->setAppSecret((std::string const &)*arg2);
}

int _wrap_BMXSDKConfig_getPushProviderType(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXSDKConfigPtr arg1 ;
  floo::BMXSDKConfigPtr *argp1 = *(floo::BMXSDKConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  floo::BMXPushProviderType result;
  
  result = (floo::BMXPushProviderType)(arg1)->getPushProviderType();
  imresult = (int)result; 
  return imresult;
}

void _wrap_BMXSDKConfig_setPushProviderType(void* imarg1, int imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXSDKConfigPtr arg1 ;
  floo::BMXSDKConfigPtr *argp1 = *(floo::BMXSDKConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  floo::BMXPushProviderType arg2 ;
  
  arg2 = (floo::BMXPushProviderType)imarg2; 
  (arg1)->setPushProviderType(arg2);
}

int _wrap_BMXSDKConfig_getPushEnvironmentType(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXSDKConfigPtr arg1 ;
  floo::BMXSDKConfigPtr *argp1 = *(floo::BMXSDKConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  floo::BMXPushEnvironmentType result;
  
  result = (floo::BMXPushEnvironmentType)(arg1)->getPushEnvironmentType();
  imresult = (int)result; 
  return imresult;
}

void _wrap_BMXSDKConfig_setEnvironmentType(void* imarg1, int imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXSDKConfigPtr arg1 ;
  floo::BMXSDKConfigPtr *argp1 = *(floo::BMXSDKConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  floo::BMXPushEnvironmentType arg2 ;
  
  arg2 = (floo::BMXPushEnvironmentType)imarg2; 
  (arg1)->setEnvironmentType(arg2);
}

long long _wrap_BMXSDKConfig_getDebugLogReceiverId(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXSDKConfigPtr arg1 ;
  floo::BMXSDKConfigPtr *argp1 = *(floo::BMXSDKConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  long long imresult = 0 ;
  int64_t result;
  
  result = (int64_t)(arg1)->getDebugLogReceiverId();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXSDKConfig_setDebugLogReceiverId(void* imarg1, long long imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXSDKConfigPtr arg1 ;
  floo::BMXSDKConfigPtr *argp1 = *(floo::BMXSDKConfigPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int64_t arg2 ;
  
  arg2 = (int64_t)imarg2; 
  (arg1)->setDebugLogReceiverId(arg2);
}

void _wrap_delete_BMXNetworkListener(void* imarg1) {
  floo::BMXNetworkListener *arg1 = (floo::BMXNetworkListener *) 0 ;
  
  arg1 = (floo::BMXNetworkListener *)imarg1; 
  delete arg1;
}

void _wrap_BMXNetworkListener_onNetworkChanged(void* imarg1, int imarg2, BOOL imarg3) {
  floo::BMXNetworkListener *arg1 = (floo::BMXNetworkListener *) 0 ;
  floo::BMXNetworkType arg2 ;
  bool arg3 ;
  
  arg1 = (floo::BMXNetworkListener *)imarg1; 
  arg2 = (floo::BMXNetworkType)imarg2; 
  arg3 = imarg3? true : false; 
  (arg1)->onNetworkChanged(arg2,arg3);
}

void _wrap_delete_BMXChatService(void* imarg1) {
  floo::BMXChatService *arg1 = (floo::BMXChatService *) 0 ;
  
  arg1 = (floo::BMXChatService *)imarg1; 
  delete arg1;
}

void _wrap_BMXChatService_sendMessage(void* imarg1, void* imarg2) {
  floo::BMXChatService *arg1 = (floo::BMXChatService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXMessage > > arg2 ;
  floo::BMXMessagePtr *argp2 ;
  
  arg1 = (floo::BMXChatService *)imarg1; 
  
  argp2 = (floo::BMXMessagePtr *)imarg2;
  arg2 = *argp2; 
  
  (arg1)->sendMessage(arg2);
}

void _wrap_BMXChatService_resendMessage(void* imarg1, void* imarg2) {
  floo::BMXChatService *arg1 = (floo::BMXChatService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXMessage > > arg2 ;
  floo::BMXMessagePtr *argp2 ;
  
  arg1 = (floo::BMXChatService *)imarg1; 
  
  argp2 = (floo::BMXMessagePtr *)imarg2;
  arg2 = *argp2; 
  
  (arg1)->resendMessage(arg2);
}

void _wrap_BMXChatService_recallMessage(void* imarg1, void* imarg2) {
  floo::BMXChatService *arg1 = (floo::BMXChatService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXMessage > > arg2 ;
  floo::BMXMessagePtr *argp2 ;
  
  arg1 = (floo::BMXChatService *)imarg1; 
  
  argp2 = (floo::BMXMessagePtr *)imarg2;
  arg2 = *argp2; 
  
  (arg1)->recallMessage(arg2);
}

int _wrap_BMXChatService_forwardMessage__SWIG_0(void* imarg1, void* imarg2, void* imarg3, void* imarg4) {
  floo::BMXChatService *arg1 = (floo::BMXChatService *) 0 ;
  floo::BMXMessageList *arg2 = 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXConversation > > arg3 ;
  floo::BMXMessagePtr *arg4 = 0 ;
  floo::BMXConversationPtr *argp3 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXChatService *)imarg1; 
  arg2 = (floo::BMXMessageList *)imarg2; 
  
  argp3 = (floo::BMXConversationPtr *)imarg3;
  arg3 = *argp3; 
  
  arg4 = (floo::BMXMessagePtr *)imarg4; 
  result = (floo::BMXErrorCode)(arg1)->forwardMessage((floo::BMXMessageList const &)*arg2,arg3,*arg4);
  imresult = (int)result; 
  return imresult;
}

void _wrap_BMXChatService_forwardMessage__SWIG_1(void* imarg1, void* imarg2) {
  floo::BMXChatService *arg1 = (floo::BMXChatService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXMessage > > arg2 ;
  floo::BMXMessagePtr *argp2 ;
  
  arg1 = (floo::BMXChatService *)imarg1; 
  
  argp2 = (floo::BMXMessagePtr *)imarg2;
  arg2 = *argp2; 
  
  (arg1)->forwardMessage(arg2);
}

void _wrap_BMXChatService_ackMessage(void* imarg1, void* imarg2) {
  floo::BMXChatService *arg1 = (floo::BMXChatService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXMessage > > arg2 ;
  floo::BMXMessagePtr *argp2 ;
  
  arg1 = (floo::BMXChatService *)imarg1; 
  
  argp2 = (floo::BMXMessagePtr *)imarg2;
  arg2 = *argp2; 
  
  (arg1)->ackMessage(arg2);
}

void _wrap_BMXChatService_ackMessageDelivered(void* imarg1, void* imarg2) {
  floo::BMXChatService *arg1 = (floo::BMXChatService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXMessage > > arg2 ;
  floo::BMXMessagePtr *argp2 ;
  
  arg1 = (floo::BMXChatService *)imarg1; 
  
  argp2 = (floo::BMXMessagePtr *)imarg2;
  arg2 = *argp2; 
  
  (arg1)->ackMessageDelivered(arg2);
}

void _wrap_BMXChatService_ackPlayMessage(void* imarg1, void* imarg2) {
  floo::BMXChatService *arg1 = (floo::BMXChatService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXMessage > > arg2 ;
  floo::BMXMessagePtr *argp2 ;
  
  arg1 = (floo::BMXChatService *)imarg1; 
  
  argp2 = (floo::BMXMessagePtr *)imarg2;
  arg2 = *argp2; 
  
  (arg1)->ackPlayMessage(arg2);
}

void _wrap_BMXChatService_appendMessageContent(void* imarg1, void* imarg2) {
  floo::BMXChatService *arg1 = (floo::BMXChatService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXMessage > > arg2 ;
  floo::BMXMessagePtr *argp2 ;
  
  arg1 = (floo::BMXChatService *)imarg1;
  
  argp2 = (floo::BMXMessagePtr *)imarg2;
  arg2 = *argp2;
  
  (arg1)->appendMessageContent(arg2);
}

void _wrap_BMXChatService_replaceMessage(void* imarg1, void* imarg2) {
  floo::BMXChatService *arg1 = (floo::BMXChatService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXMessage > > arg2 ;
  floo::BMXMessagePtr *argp2 ;
  
  arg1 = (floo::BMXChatService *)imarg1;
  
  argp2 = (floo::BMXMessagePtr *)imarg2;
  arg2 = *argp2;
  
  (arg1)->replaceMessage(arg2);
}

void _wrap_BMXChatService_readCancel(void* imarg1, void* imarg2) {
  floo::BMXChatService *arg1 = (floo::BMXChatService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXMessage > > arg2 ;
  floo::BMXMessagePtr *argp2 ;
  
  arg1 = (floo::BMXChatService *)imarg1; 
  
  argp2 = (floo::BMXMessagePtr *)imarg2;
  arg2 = *argp2; 
  
  (arg1)->readCancel(arg2);
}

void _wrap_BMXChatService_readAllMessage(void* imarg1, void* imarg2) {
  floo::BMXChatService *arg1 = (floo::BMXChatService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXMessage > > arg2 ;
  floo::BMXMessagePtr *argp2 ;
  
  arg1 = (floo::BMXChatService *)imarg1; 
  
  argp2 = (floo::BMXMessagePtr *)imarg2;
  arg2 = *argp2; 
  
  (arg1)->readAllMessage(arg2);
}

void _wrap_BMXChatService_removeMessage__SWIG_0(void* imarg1, void* imarg2, BOOL imarg3) {
  floo::BMXChatService *arg1 = (floo::BMXChatService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXMessage > > arg2 ;
  bool arg3 ;
  floo::BMXMessagePtr *argp2 ;
  
  arg1 = (floo::BMXChatService *)imarg1; 
  
  argp2 = (floo::BMXMessagePtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = imarg3? true : false; 
  (arg1)->removeMessage(arg2,arg3);
}

void _wrap_BMXChatService_removeMessage__SWIG_1(void* imarg1, void* imarg2) {
  floo::BMXChatService *arg1 = (floo::BMXChatService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXMessage > > arg2 ;
  floo::BMXMessagePtr *argp2 ;
  
  arg1 = (floo::BMXChatService *)imarg1; 
  
  argp2 = (floo::BMXMessagePtr *)imarg2;
  arg2 = *argp2; 
  
  (arg1)->removeMessage(arg2);
}

void _wrap_BMXChatService_downloadThumbnail__SWIG_0(void* imarg1, void* imarg2, int imarg3) {
  floo::BMXChatService *arg1 = (floo::BMXChatService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXMessage > > arg2 ;
  floo::BMXChatService::ThumbnailStrategy arg3 ;
  floo::BMXMessagePtr *argp2 ;
  
  arg1 = (floo::BMXChatService *)imarg1; 
  
  argp2 = (floo::BMXMessagePtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (floo::BMXChatService::ThumbnailStrategy)imarg3; 
  (arg1)->downloadThumbnail(arg2,arg3);
}

void _wrap_BMXChatService_downloadThumbnail__SWIG_1(void* imarg1, void* imarg2) {
  floo::BMXChatService *arg1 = (floo::BMXChatService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXMessage > > arg2 ;
  floo::BMXMessagePtr *argp2 ;
  
  arg1 = (floo::BMXChatService *)imarg1; 
  
  argp2 = (floo::BMXMessagePtr *)imarg2;
  arg2 = *argp2; 
  
  (arg1)->downloadThumbnail(arg2);
}

void _wrap_BMXChatService_downloadAttachment(void* imarg1, void* imarg2) {
  floo::BMXChatService *arg1 = (floo::BMXChatService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXMessage > > arg2 ;
  floo::BMXMessagePtr *argp2 ;
  
  arg1 = (floo::BMXChatService *)imarg1; 
  
  argp2 = (floo::BMXMessagePtr *)imarg2;
  arg2 = *argp2; 
  
  (arg1)->downloadAttachment(arg2);
}

void _wrap_BMXChatService_downloadAttachmentByUrl(void* imarg1, long long imarg2, NSString* imarg3, NSString* imarg4) {
  floo::BMXChatService *arg1 = (floo::BMXChatService *) 0 ;
  int64_t arg2 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  
  arg1 = (floo::BMXChatService *)imarg1; 
  arg2 = (int64_t)imarg2; 
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str; 
  
  if(!imarg4) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg4_str(getStdString(imarg4));
  arg4 = &arg4_str; 
  
  (arg1)->downloadAttachmentByUrl(arg2,(std::string const &)*arg3,(std::string const &)*arg4);
}

void _wrap_BMXChatService_cancelUploadAttachment(void* imarg1, void* imarg2) {
  floo::BMXChatService *arg1 = (floo::BMXChatService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXMessage > > arg2 ;
  floo::BMXMessagePtr *argp2 ;
  
  arg1 = (floo::BMXChatService *)imarg1; 
  
  argp2 = (floo::BMXMessagePtr *)imarg2;
  arg2 = *argp2; 
  
  (arg1)->cancelUploadAttachment(arg2);
}

void _wrap_BMXChatService_cancelDownloadAttachment(void* imarg1, void* imarg2) {
  floo::BMXChatService *arg1 = (floo::BMXChatService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXMessage > > arg2 ;
  floo::BMXMessagePtr *argp2 ;
  
  arg1 = (floo::BMXChatService *)imarg1; 
  
  argp2 = (floo::BMXMessagePtr *)imarg2;
  arg2 = *argp2; 
  
  (arg1)->cancelDownloadAttachment(arg2);
}

int _wrap_BMXChatService_transferingNum(void* imarg1) {
  floo::BMXChatService *arg1 = (floo::BMXChatService *) 0 ;
  int imresult = 0 ;
  int result;
  
  arg1 = (floo::BMXChatService *)imarg1; 
  result = (int)(arg1)->transferingNum();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

int _wrap_BMXChatService_insertMessages(void* imarg1, void* imarg2) {
  floo::BMXChatService *arg1 = (floo::BMXChatService *) 0 ;
  floo::BMXMessageList *arg2 = 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXChatService *)imarg1; 
  arg2 = (floo::BMXMessageList *)imarg2; 
  result = (floo::BMXErrorCode)(arg1)->insertMessages((floo::BMXMessageList const &)*arg2);
  imresult = (int)result; 
  return imresult;
}

void* _wrap_BMXChatService_getMessage(void* imarg1, long long imarg2) {
  floo::BMXChatService *arg1 = (floo::BMXChatService *) 0 ;
  int64_t arg2 ;
  void* imresult = 0 ;
  floo::BMXMessagePtr *temp ;
  std::shared_ptr< floo::BMXMessage > result;
  
  arg1 = (floo::BMXChatService *)imarg1; 
  arg2 = (int64_t)imarg2; 
  result = (arg1)->getMessage(arg2);
  
  BMXMessage2Void(result)
  imresult = (void*)lresult; 
  
  return imresult;
}

void _wrap_BMXChatService_deleteConversation__SWIG_0(void* imarg1, long long imarg2, BOOL imarg3) {
  floo::BMXChatService *arg1 = (floo::BMXChatService *) 0 ;
  int64_t arg2 ;
  bool arg3 ;
  
  arg1 = (floo::BMXChatService *)imarg1; 
  arg2 = (int64_t)imarg2; 
  arg3 = imarg3? true : false; 
  (arg1)->deleteConversation(arg2,arg3);
}

void _wrap_BMXChatService_deleteConversation__SWIG_1(void* imarg1, long long imarg2) {
  floo::BMXChatService *arg1 = (floo::BMXChatService *) 0 ;
  int64_t arg2 ;
  
  arg1 = (floo::BMXChatService *)imarg1; 
  arg2 = (int64_t)imarg2; 
  (arg1)->deleteConversation(arg2);
}

void* _wrap_BMXChatService_openConversation__SWIG_0(void* imarg1, long long imarg2, int imarg3, BOOL imarg4) {
  floo::BMXChatService *arg1 = (floo::BMXChatService *) 0 ;
  int64_t arg2 ;
  floo::BMXConversation::Type arg3 ;
  bool arg4 ;
  void* imresult = 0 ;
  std::shared_ptr< floo::BMXConversation > result;
  
  arg1 = (floo::BMXChatService *)imarg1; 
  arg2 = (int64_t)imarg2; 
  arg3 = (floo::BMXConversation::Type)imarg3; 
  arg4 = imarg4? true : false; 
  result = (arg1)->openConversation(arg2,arg3,arg4);
  
  BMXConversation2Void(result)
  imresult = (void*)lresult;
  
  return imresult;
}

void* _wrap_BMXChatService_openConversation__SWIG_1(void* imarg1, long long imarg2, int imarg3) {
  floo::BMXChatService *arg1 = (floo::BMXChatService *) 0 ;
  int64_t arg2 ;
  floo::BMXConversation::Type arg3 ;
  void* imresult = 0 ;
  floo::BMXConversationPtr *temp ;
  std::shared_ptr< floo::BMXConversation > result;
  
  arg1 = (floo::BMXChatService *)imarg1; 
  arg2 = (int64_t)imarg2; 
  arg3 = (floo::BMXConversation::Type)imarg3; 
  result = (arg1)->openConversation(arg2,arg3);
  
  BMXConversation2Void(result)
  imresult = (void*)lresult; 
  
  return imresult;
}

NSString* _wrap_BMXChatService_attachmentDir(void* imarg1) {
  floo::BMXChatService *arg1 = (floo::BMXChatService *) 0 ;
  NSString* imresult = 0 ;
  std::string result;
  
  arg1 = (floo::BMXChatService *)imarg1; 
  result = (arg1)->attachmentDir();
  imresult = [NSString stringWithUTF8String: (&result)->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_BMXChatService_attachmentDirForConversation(void* imarg1, long long imarg2) {
  floo::BMXChatService *arg1 = (floo::BMXChatService *) 0 ;
  int64_t arg2 ;
  NSString* imresult = 0 ;
  std::string result;
  
  arg1 = (floo::BMXChatService *)imarg1; 
  arg2 = (int64_t)imarg2; 
  result = (arg1)->attachmentDirForConversation(arg2);
  imresult = [NSString stringWithUTF8String: (&result)->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void* _wrap_BMXChatService_getAllConversations(void* imarg1) {
  floo::BMXChatService *arg1 = (floo::BMXChatService *) 0 ;
  void* imresult = 0 ;
  floo::BMXConversationList *temp ;
  floo::BMXConversationList result;
  
  arg1 = (floo::BMXChatService *)imarg1; 
  result = (arg1)->getAllConversations();
    
  BMXConversationList2Void(result)
  imresult = (void*)lresult;
  
  return imresult;
}

int _wrap_BMXChatService_getAllConversationsUnreadCount(void* imarg1) {
  floo::BMXChatService *arg1 = (floo::BMXChatService *) 0 ;
  int imresult = 0 ;
  int result;
  
  arg1 = (floo::BMXChatService *)imarg1; 
  result = (int)(arg1)->getAllConversationsUnreadCount();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

int _wrap_BMXChatService_retrieveHistoryMessages(void* imarg1, void* imarg2, long long imarg3, unsigned long imarg4, void* imarg5) {
  floo::BMXChatService *arg1 = (floo::BMXChatService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXConversation > > arg2 ;
  int64_t arg3 ;
  size_t arg4 ;
  floo::BMXMessageList *arg5 = 0 ;
  floo::BMXConversationPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXChatService *)imarg1; 
  
  argp2 = (floo::BMXConversationPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (int64_t)imarg3; 
  arg4 = (size_t)imarg4; 
  arg5 = (floo::BMXMessageList *)imarg5; 
  result = (floo::BMXErrorCode)(arg1)->retrieveHistoryMessages(arg2,arg3,arg4,*arg5);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXChatService_searchMessagesByKeyWords__SWIG_0(void* imarg1, NSString* imarg2, long long imarg3, unsigned long imarg4, void* imarg5, int imarg6) {
  floo::BMXChatService *arg1 = (floo::BMXChatService *) 0 ;
  std::string *arg2 = 0 ;
  int64_t arg3 ;
  size_t arg4 ;
  std::vector< floo::BMXMessageList > *arg5 = 0 ;
  floo::BMXConversation::Direction arg6 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXChatService *)imarg1; 
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  arg3 = (int64_t)imarg3; 
  arg4 = (size_t)imarg4; 
  arg5 = (std::vector< floo::BMXMessageList > *)imarg5; 
  arg6 = (floo::BMXConversation::Direction)imarg6; 
  result = (floo::BMXErrorCode)(arg1)->searchMessagesByKeyWords((std::string const &)*arg2,arg3,arg4,*arg5,arg6);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXChatService_searchMessagesByKeyWords__SWIG_1(void* imarg1, NSString* imarg2, long long imarg3, unsigned long imarg4, void* imarg5) {
  floo::BMXChatService *arg1 = (floo::BMXChatService *) 0 ;
  std::string *arg2 = 0 ;
  int64_t arg3 ;
  size_t arg4 ;
  std::vector< floo::BMXMessageList > *arg5 = 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXChatService *)imarg1; 
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  arg3 = (int64_t)imarg3; 
  arg4 = (size_t)imarg4; 
  arg5 = (std::vector< floo::BMXMessageList > *)imarg5; 
  result = (floo::BMXErrorCode)(arg1)->searchMessagesByKeyWords((std::string const &)*arg2,arg3,arg4,*arg5);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXChatService_searchMessages__SWIG_0(void* imarg1, NSString* imarg2, long long imarg3, unsigned long imarg4, void* imarg5, int imarg6) {
  floo::BMXChatService *arg1 = (floo::BMXChatService *) 0 ;
  std::string *arg2 = 0 ;
  int64_t arg3 ;
  size_t arg4 ;
  std::vector< floo::BMXMessageList > *arg5 = 0 ;
  floo::BMXConversation::Direction arg6 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXChatService *)imarg1; 
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  arg3 = (int64_t)imarg3; 
  arg4 = (size_t)imarg4; 
  arg5 = (std::vector< floo::BMXMessageList > *)imarg5; 
  arg6 = (floo::BMXConversation::Direction)imarg6; 
  result = (floo::BMXErrorCode)(arg1)->searchMessages((std::string const &)*arg2,arg3,arg4,*arg5,arg6);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXChatService_searchMessages__SWIG_1(void* imarg1, NSString* imarg2, long long imarg3, unsigned long imarg4, void* imarg5) {
  floo::BMXChatService *arg1 = (floo::BMXChatService *) 0 ;
  std::string *arg2 = 0 ;
  int64_t arg3 ;
  size_t arg4 ;
  std::vector< floo::BMXMessageList > *arg5 = 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXChatService *)imarg1; 
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  arg3 = (int64_t)imarg3; 
  arg4 = (size_t)imarg4; 
  arg5 = (std::vector< floo::BMXMessageList > *)imarg5; 
  result = (floo::BMXErrorCode)(arg1)->searchMessages((std::string const &)*arg2,arg3,arg4,*arg5);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXChatService_getGroupAckMessageUserIdList(void* imarg1, void* imarg2, void* imarg3) {
  floo::BMXChatService *arg1 = (floo::BMXChatService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXMessage > > arg2 ;
  std::vector< int64_t > *arg3 = 0 ;
  floo::BMXMessagePtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXChatService *)imarg1; 
  
  argp2 = (floo::BMXMessagePtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (std::vector< int64_t > *)imarg3; 
  result = (floo::BMXErrorCode)(arg1)->getGroupAckMessageUserIdList(arg2,*arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXChatService_getGroupAckMessageUnreadUserIdList(void* imarg1, void* imarg2, void* imarg3) {
  floo::BMXChatService *arg1 = (floo::BMXChatService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXMessage > > arg2 ;
  std::vector< int64_t > *arg3 = 0 ;
  floo::BMXMessagePtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXChatService *)imarg1; 
  
  argp2 = (floo::BMXMessagePtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (std::vector< int64_t > *)imarg3; 
  result = (floo::BMXErrorCode)(arg1)->getGroupAckMessageUnreadUserIdList(arg2,*arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXChatService_getGroupPlayAckMessageUserIdList(void* imarg1, void* imarg2, void* imarg3) {
  floo::BMXChatService *arg1 = (floo::BMXChatService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXMessage > > arg2 ;
  std::vector< int64_t > *arg3 = 0 ;
  floo::BMXMessagePtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXChatService *)imarg1; 
  
  argp2 = (floo::BMXMessagePtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (std::vector< int64_t > *)imarg3; 
  result = (floo::BMXErrorCode)(arg1)->getGroupPlayAckMessageUserIdList(arg2,*arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXChatService_getGroupUnPlayAckMessageUserIdList(void* imarg1, void* imarg2, void* imarg3) {
  floo::BMXChatService *arg1 = (floo::BMXChatService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXMessage > > arg2 ;
  std::vector< int64_t > *arg3 = 0 ;
  floo::BMXMessagePtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXChatService *)imarg1; 
  
  argp2 = (floo::BMXMessagePtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (std::vector< int64_t > *)imarg3; 
  result = (floo::BMXErrorCode)(arg1)->getGroupUnPlayAckMessageUserIdList(arg2,*arg3);
  imresult = (int)result; 
  return imresult;
}

void _wrap_BMXChatService_addChatListener(void* imarg1, void* imarg2) {
  floo::BMXChatService *arg1 = (floo::BMXChatService *) 0 ;
  floo::BMXChatServiceListener *arg2 = (floo::BMXChatServiceListener *) 0 ;
  
  arg1 = (floo::BMXChatService *)imarg1; 
  arg2 = (floo::BMXChatServiceListener *)imarg2; 
  (arg1)->addChatListener(arg2);
}

void _wrap_BMXChatService_removeChatListener(void* imarg1, void* imarg2) {
  floo::BMXChatService *arg1 = (floo::BMXChatService *) 0 ;
  floo::BMXChatServiceListener *arg2 = (floo::BMXChatServiceListener *) 0 ;
  
  arg1 = (floo::BMXChatService *)imarg1; 
  arg2 = (floo::BMXChatServiceListener *)imarg2; 
  (arg1)->removeChatListener(arg2);
}

void* _wrap_new_BMXChatServiceListener() {
  void* imresult = 0 ;
  floo::BMXChatServiceListener *result = 0 ;
  
  result = (floo::BMXChatServiceListener *)new floo::BMXChatServiceListener();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_delete_BMXChatServiceListener(void* imarg1) {
  floo::BMXChatServiceListener *arg1 = (floo::BMXChatServiceListener *) 0 ;
  
  arg1 = (floo::BMXChatServiceListener *)imarg1; 
  delete arg1;
}

void _wrap_BMXChatServiceListener_onStatusChanged(void* imarg1, void* imarg2, int imarg3) {
  floo::BMXChatServiceListener *arg1 = (floo::BMXChatServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXMessage > > arg2 ;
  floo::BMXErrorCode arg3 ;
  floo::BMXMessagePtr *argp2 ;
  
  arg1 = (floo::BMXChatServiceListener *)imarg1; 
  
  argp2 = (floo::BMXMessagePtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (floo::BMXErrorCode)imarg3; 
  (arg1)->onStatusChanged(arg2,arg3);
}

void _wrap_BMXChatServiceListener_onAttachmentUploadProgressChanged(void* imarg1, void* imarg2, int imarg3) {
  floo::BMXChatServiceListener *arg1 = (floo::BMXChatServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXMessage > > arg2 ;
  int arg3 ;
  floo::BMXMessagePtr *argp2 ;
  
  arg1 = (floo::BMXChatServiceListener *)imarg1; 
  
  argp2 = (floo::BMXMessagePtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (int)imarg3; 
  (arg1)->onAttachmentUploadProgressChanged(arg2,arg3);
}
void _wrap_BMXChatServiceListener_onContentAppendChanged(void* imarg1, void* imarg2, int imarg3) {
  floo::BMXChatServiceListener *arg1 = (floo::BMXChatServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXMessage > > arg2 ;
  floo::BMXErrorCode arg3 ;
  floo::BMXMessagePtr *argp2 ;

  arg1 = (floo::BMXChatServiceListener *)imarg1;

  argp2 = (floo::BMXMessagePtr *)imarg2;
  arg2 = *argp2;

  arg3 = (floo::BMXErrorCode)imarg3;
  (arg1)->onContentAppendChanged(arg2,arg3);
}

void _wrap_BMXChatServiceListener_onReplaceChanged(void* imarg1, void* imarg2, int imarg3) {
  floo::BMXChatServiceListener *arg1 = (floo::BMXChatServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXMessage > > arg2 ;
  floo::BMXErrorCode arg3 ;
  floo::BMXMessagePtr *argp2 ;

  arg1 = (floo::BMXChatServiceListener *)imarg1;

  argp2 = (floo::BMXMessagePtr *)imarg2;
  arg2 = *argp2;

  arg3 = (floo::BMXErrorCode)imarg3;
  (arg1)->onReplaceChanged(arg2,arg3);
}

void _wrap_BMXChatServiceListener_onRecallStatusChanged(void* imarg1, void* imarg2, int imarg3) {
  floo::BMXChatServiceListener *arg1 = (floo::BMXChatServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXMessage > > arg2 ;
  floo::BMXErrorCode arg3 ;
  floo::BMXMessagePtr *argp2 ;
  
  arg1 = (floo::BMXChatServiceListener *)imarg1; 
  
  argp2 = (floo::BMXMessagePtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (floo::BMXErrorCode)imarg3; 
  (arg1)->onRecallStatusChanged(arg2,arg3);
}

void _wrap_BMXChatServiceListener_onReceive(void* imarg1, void* imarg2) {
  floo::BMXChatServiceListener *arg1 = (floo::BMXChatServiceListener *) 0 ;
  floo::BMXMessageList *arg2 = 0 ;
  
  arg1 = (floo::BMXChatServiceListener *)imarg1; 
  arg2 = (floo::BMXMessageList *)imarg2; 
  (arg1)->onReceive((floo::BMXMessageList const &)*arg2);
}

void _wrap_BMXChatServiceListener_onReceiveCommandMessages(void* imarg1, void* imarg2) {
  floo::BMXChatServiceListener *arg1 = (floo::BMXChatServiceListener *) 0 ;
  floo::BMXMessageList *arg2 = 0 ;
  
  arg1 = (floo::BMXChatServiceListener *)imarg1; 
  arg2 = (floo::BMXMessageList *)imarg2; 
  (arg1)->onReceiveCommandMessages((floo::BMXMessageList const &)*arg2);
}

void _wrap_BMXChatServiceListener_onReceiveSystemMessages(void* imarg1, void* imarg2) {
  floo::BMXChatServiceListener *arg1 = (floo::BMXChatServiceListener *) 0 ;
  floo::BMXMessageList *arg2 = 0 ;
  
  arg1 = (floo::BMXChatServiceListener *)imarg1; 
  arg2 = (floo::BMXMessageList *)imarg2; 
  (arg1)->onReceiveSystemMessages((floo::BMXMessageList const &)*arg2);
}

void _wrap_BMXChatServiceListener_onReceiveReadAcks(void* imarg1, void* imarg2) {
  floo::BMXChatServiceListener *arg1 = (floo::BMXChatServiceListener *) 0 ;
  floo::BMXMessageList *arg2 = 0 ;
  
  arg1 = (floo::BMXChatServiceListener *)imarg1; 
  arg2 = (floo::BMXMessageList *)imarg2; 
  (arg1)->onReceiveReadAcks((floo::BMXMessageList const &)*arg2);
}

void _wrap_BMXChatServiceListener_onReceiveDeliverAcks(void* imarg1, void* imarg2) {
  floo::BMXChatServiceListener *arg1 = (floo::BMXChatServiceListener *) 0 ;
  floo::BMXMessageList *arg2 = 0 ;
  
  arg1 = (floo::BMXChatServiceListener *)imarg1; 
  arg2 = (floo::BMXMessageList *)imarg2; 
  (arg1)->onReceiveDeliverAcks((floo::BMXMessageList const &)*arg2);
}

void _wrap_BMXChatServiceListener_onReceiveRecallMessages(void* imarg1, void* imarg2) {
  floo::BMXChatServiceListener *arg1 = (floo::BMXChatServiceListener *) 0 ;
  floo::BMXMessageList *arg2 = 0 ;
  
  arg1 = (floo::BMXChatServiceListener *)imarg1; 
  arg2 = (floo::BMXMessageList *)imarg2; 
  (arg1)->onReceiveRecallMessages((floo::BMXMessageList const &)*arg2);
}

void _wrap_BMXChatServiceListener_onReceiveReadCancels(void* imarg1, void* imarg2) {
  floo::BMXChatServiceListener *arg1 = (floo::BMXChatServiceListener *) 0 ;
  floo::BMXMessageList *arg2 = 0 ;
  
  arg1 = (floo::BMXChatServiceListener *)imarg1; 
  arg2 = (floo::BMXMessageList *)imarg2; 
  (arg1)->onReceiveReadCancels((floo::BMXMessageList const &)*arg2);
}

void _wrap_BMXChatServiceListener_onReceiveReadAllMessages(void* imarg1, void* imarg2) {
  floo::BMXChatServiceListener *arg1 = (floo::BMXChatServiceListener *) 0 ;
  floo::BMXMessageList *arg2 = 0 ;
  
  arg1 = (floo::BMXChatServiceListener *)imarg1; 
  arg2 = (floo::BMXMessageList *)imarg2; 
  (arg1)->onReceiveReadAllMessages((floo::BMXMessageList const &)*arg2);
}

void _wrap_BMXChatServiceListener_onReceiveDeleteMessages(void* imarg1, void* imarg2) {
  floo::BMXChatServiceListener *arg1 = (floo::BMXChatServiceListener *) 0 ;
  floo::BMXMessageList *arg2 = 0 ;
  
  arg1 = (floo::BMXChatServiceListener *)imarg1; 
  arg2 = (floo::BMXMessageList *)imarg2; 
  (arg1)->onReceiveDeleteMessages((floo::BMXMessageList const &)*arg2);
}

void _wrap_BMXChatServiceListener_onReceivePlayAcks(void* imarg1, void* imarg2) {
  floo::BMXChatServiceListener *arg1 = (floo::BMXChatServiceListener *) 0 ;
  floo::BMXMessageList *arg2 = 0 ;
  
  arg1 = (floo::BMXChatServiceListener *)imarg1;
  arg2 = (floo::BMXMessageList *)imarg2;
  (arg1)->onReceivePlayAcks((floo::BMXMessageList const &)*arg2);
}

void _wrap_BMXChatServiceListener_onReceiveAppendContentMessages(void* imarg1, void* imarg2) {
  floo::BMXChatServiceListener *arg1 = (floo::BMXChatServiceListener *) 0 ;
  floo::BMXMessageList *arg2 = 0 ;
  
  arg1 = (floo::BMXChatServiceListener *)imarg1;
  arg2 = (floo::BMXMessageList *)imarg2;
  (arg1)->onReceiveAppendContentMessages((floo::BMXMessageList const &)*arg2);
}

void _wrap_BMXChatServiceListener_onReceiveReplaceMessages(void* imarg1, void* imarg2) {
  floo::BMXChatServiceListener *arg1 = (floo::BMXChatServiceListener *) 0 ;
  floo::BMXMessageList *arg2 = 0 ;
  
  arg1 = (floo::BMXChatServiceListener *)imarg1;
  arg2 = (floo::BMXMessageList *)imarg2;
  (arg1)->onReceiveReplaceMessages((floo::BMXMessageList const &)*arg2);
}

void _wrap_BMXChatServiceListener_onAttachmentStatusChanged(void* imarg1, void* imarg2, int imarg3, int imarg4) {
  floo::BMXChatServiceListener *arg1 = (floo::BMXChatServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXMessage > > arg2 ;
  floo::BMXErrorCode arg3 ;
  int arg4 ;
  floo::BMXMessagePtr *argp2 ;
  
  arg1 = (floo::BMXChatServiceListener *)imarg1; 
  
  argp2 = (floo::BMXMessagePtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (floo::BMXErrorCode)imarg3; 
  arg4 = (int)imarg4; 
  (arg1)->onAttachmentStatusChanged(arg2,arg3,arg4);
}

void _wrap_BMXChatServiceListener_onAttachmentDownloadByUrlStatusChanged(void* imarg1, long long imarg2, int imarg3, int imarg4) {
  floo::BMXChatServiceListener *arg1 = (floo::BMXChatServiceListener *) 0 ;
  int64_t arg2 ;
  floo::BMXErrorCode arg3 ;
  int arg4 ;
  
  arg1 = (floo::BMXChatServiceListener *)imarg1; 
  arg2 = (int64_t)imarg2; 
  arg3 = (floo::BMXErrorCode)imarg3; 
  arg4 = (int)imarg4; 
  (arg1)->onAttachmentDownloadByUrlStatusChanged(arg2,arg3,arg4);
}

void _wrap_BMXChatServiceListener_onRetrieveHistoryMessages(void* imarg1, void* imarg2) {
  floo::BMXChatServiceListener *arg1 = (floo::BMXChatServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXConversation > > arg2 ;
  floo::BMXConversationPtr *argp2 ;
  
  arg1 = (floo::BMXChatServiceListener *)imarg1; 
  
  argp2 = (floo::BMXConversationPtr *)imarg2;
  arg2 = *argp2; 
  
  (arg1)->onRetrieveHistoryMessages(arg2);
}

void _wrap_BMXChatServiceListener_onLoadAllConversation(void* imarg1) {
  floo::BMXChatServiceListener *arg1 = (floo::BMXChatServiceListener *) 0 ;
  
  arg1 = (floo::BMXChatServiceListener *)imarg1; 
  (arg1)->onLoadAllConversation();
}

void _wrap_BMXChatServiceListener_onConversationCreate(void* imarg1, void* imarg2, void* imarg3) {
  floo::BMXChatServiceListener *arg1 = (floo::BMXChatServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXConversation > > arg2 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXMessage > > arg3 ;
  floo::BMXConversationPtr *argp2 ;
  floo::BMXMessagePtr *argp3 ;
  
  arg1 = (floo::BMXChatServiceListener *)imarg1; 
  
  argp2 = (floo::BMXConversationPtr *)imarg2;
  arg2 = *argp2; 
  
  
  argp3 = (floo::BMXMessagePtr *)imarg3;
  arg3 = *argp3; 
  
  (arg1)->onConversationCreate(arg2,arg3);
}

void _wrap_BMXChatServiceListener_onConversationDelete(void* imarg1, long long imarg2, int imarg3) {
  floo::BMXChatServiceListener *arg1 = (floo::BMXChatServiceListener *) 0 ;
  int64_t arg2 ;
  floo::BMXErrorCode arg3 ;
  
  arg1 = (floo::BMXChatServiceListener *)imarg1; 
  arg2 = (int64_t)imarg2; 
  arg3 = (floo::BMXErrorCode)imarg3; 
  (arg1)->onConversationDelete(arg2,arg3);
}

void _wrap_BMXChatServiceListener_onTotalUnreadCountChanged(void* imarg1, int imarg2) {
  floo::BMXChatServiceListener *arg1 = (floo::BMXChatServiceListener *) 0 ;
  int arg2 ;
  
  arg1 = (floo::BMXChatServiceListener *)imarg1; 
  arg2 = (int)imarg2; 
  (arg1)->onTotalUnreadCountChanged(arg2);
}

void _wrap_BMXChatServiceListener_registerChatService(void* imarg1, void* imarg2) {
  floo::BMXChatServiceListener *arg1 = (floo::BMXChatServiceListener *) 0 ;
  floo::BMXChatService *arg2 = (floo::BMXChatService *) 0 ;
  
  arg1 = (floo::BMXChatServiceListener *)imarg1; 
  arg2 = (floo::BMXChatService *)imarg2; 
  (arg1)->registerChatService(arg2);
}

void _wrap_delete_BMXPushService(void* imarg1) {
  floo::BMXPushService *arg1 = (floo::BMXPushService *) 0 ;
  
  arg1 = (floo::BMXPushService *)imarg1; 
  delete arg1;
}

int _wrap_BMXPushService_start__SWIG_0(void* imarg1, NSString* imarg2, NSString* imarg3) {
  floo::BMXPushService *arg1 = (floo::BMXPushService *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXPushService *)imarg1; 
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str; 
  
  result = (floo::BMXErrorCode)(arg1)->start((std::string const &)*arg2,(std::string const &)*arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXPushService_start__SWIG_1(void* imarg1, NSString* imarg2) {
  floo::BMXPushService *arg1 = (floo::BMXPushService *) 0 ;
  std::string *arg2 = 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXPushService *)imarg1; 
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  result = (floo::BMXErrorCode)(arg1)->start((std::string const &)*arg2);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXPushService_start__SWIG_2(void* imarg1) {
  floo::BMXPushService *arg1 = (floo::BMXPushService *) 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXPushService *)imarg1; 
  result = (floo::BMXErrorCode)(arg1)->start();
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXPushService_stop(void* imarg1) {
  floo::BMXPushService *arg1 = (floo::BMXPushService *) 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXPushService *)imarg1; 
  result = (floo::BMXErrorCode)(arg1)->stop();
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXPushService_resume(void* imarg1) {
  floo::BMXPushService *arg1 = (floo::BMXPushService *) 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXPushService *)imarg1; 
  result = (floo::BMXErrorCode)(arg1)->resume();
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXPushService_unbindAlias(void* imarg1, NSString* imarg2) {
  floo::BMXPushService *arg1 = (floo::BMXPushService *) 0 ;
  std::string *arg2 = 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXPushService *)imarg1; 
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  result = (floo::BMXErrorCode)(arg1)->unbindAlias((std::string const &)*arg2);
  imresult = (int)result; 
  return imresult;
}

NSString* _wrap_BMXPushService_getToken(void* imarg1) {
  floo::BMXPushService *arg1 = (floo::BMXPushService *) 0 ;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  arg1 = (floo::BMXPushService *)imarg1; 
  result = (std::string *) &(arg1)->getToken();
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_BMXPushService_getCert(void* imarg1) {
  floo::BMXPushService *arg1 = (floo::BMXPushService *) 0 ;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  arg1 = (floo::BMXPushService *)imarg1; 
  result = (std::string *) &(arg1)->getCert();
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

int _wrap_BMXPushService_status(void* imarg1) {
  floo::BMXPushService *arg1 = (floo::BMXPushService *) 0 ;
  int imresult = 0 ;
  floo::BMXPushService::PushSdkStatus result;
  
  arg1 = (floo::BMXPushService *)imarg1; 
  result = (floo::BMXPushService::PushSdkStatus)(arg1)->status();
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXPushService_bindDeviceToken(void* imarg1, NSString* imarg2) {
  floo::BMXPushService *arg1 = (floo::BMXPushService *) 0 ;
  std::string *arg2 = 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXPushService *)imarg1; 
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  result = (floo::BMXErrorCode)(arg1)->bindDeviceToken((std::string const &)*arg2);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXPushService_bindVoipToken(void* imarg1, NSString* imarg2) {
  floo::BMXPushService *arg1 = (floo::BMXPushService *) 0 ;
  std::string *arg2 = 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXPushService *)imarg1; 
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  result = (floo::BMXErrorCode)(arg1)->bindVoipToken((std::string const &)*arg2);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXPushService_getPushProfile(void* imarg1, void* imarg2, BOOL imarg3) {
  floo::BMXPushService *arg1 = (floo::BMXPushService *) 0 ;
  BMXPushUserProfilePtr *arg2 = 0 ;
  bool arg3 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXPushService *)imarg1; 
  arg2 = (BMXPushUserProfilePtr *)imarg2; 
  arg3 = imarg3? true : false; 
  result = (floo::BMXErrorCode)(arg1)->getPushProfile(*arg2,arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXPushService_setTags(void* imarg1, void* imarg2, NSString* imarg3) {
  floo::BMXPushService *arg1 = (floo::BMXPushService *) 0 ;
  std::vector< std::string > *arg2 = 0 ;
  std::string *arg3 = 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXPushService *)imarg1; 
  arg2 = (std::vector< std::string > *)imarg2; 
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str; 
  
  result = (floo::BMXErrorCode)(arg1)->setTags((std::vector< std::string > const &)*arg2,(std::string const &)*arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXPushService_getTags(void* imarg1, void* imarg2, NSString* imarg3) {
  floo::BMXPushService *arg1 = (floo::BMXPushService *) 0 ;
  std::vector< std::string > *arg2 = 0 ;
  std::string *arg3 = 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXPushService *)imarg1; 
  arg2 = (std::vector< std::string > *)imarg2; 
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str; 
  
  result = (floo::BMXErrorCode)(arg1)->getTags(*arg2,(std::string const &)*arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXPushService_deleteTags(void* imarg1, void* imarg2, NSString* imarg3) {
  floo::BMXPushService *arg1 = (floo::BMXPushService *) 0 ;
  std::vector< std::string > *arg2 = 0 ;
  std::string *arg3 = 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXPushService *)imarg1; 
  arg2 = (std::vector< std::string > *)imarg2; 
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str; 
  
  result = (floo::BMXErrorCode)(arg1)->deleteTags((std::vector< std::string > const &)*arg2,(std::string const &)*arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXPushService_clearTags(void* imarg1, NSString* imarg2) {
  floo::BMXPushService *arg1 = (floo::BMXPushService *) 0 ;
  std::string *arg2 = 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXPushService *)imarg1; 
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  result = (floo::BMXErrorCode)(arg1)->clearTags((std::string const &)*arg2);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXPushService_setBadge(void* imarg1, int imarg2) {
  floo::BMXPushService *arg1 = (floo::BMXPushService *) 0 ;
  int arg2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXPushService *)imarg1; 
  arg2 = (int)imarg2; 
  result = (floo::BMXErrorCode)(arg1)->setBadge(arg2);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXPushService_setPushMode__SWIG_0(void* imarg1, BOOL imarg2) {
  floo::BMXPushService *arg1 = (floo::BMXPushService *) 0 ;
  bool arg2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXPushService *)imarg1; 
  arg2 = imarg2? true : false; 
  result = (floo::BMXErrorCode)(arg1)->setPushMode(arg2);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXPushService_setPushMode__SWIG_1(void* imarg1) {
  floo::BMXPushService *arg1 = (floo::BMXPushService *) 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXPushService *)imarg1; 
  result = (floo::BMXErrorCode)(arg1)->setPushMode();
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXPushService_setPushTime(void* imarg1, int imarg2, int imarg3) {
  floo::BMXPushService *arg1 = (floo::BMXPushService *) 0 ;
  int arg2 ;
  int arg3 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXPushService *)imarg1; 
  arg2 = (int)imarg2; 
  arg3 = (int)imarg3; 
  result = (floo::BMXErrorCode)(arg1)->setPushTime(arg2,arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXPushService_setSilenceTime(void* imarg1, int imarg2, int imarg3) {
  floo::BMXPushService *arg1 = (floo::BMXPushService *) 0 ;
  int arg2 ;
  int arg3 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXPushService *)imarg1; 
  arg2 = (int)imarg2; 
  arg3 = (int)imarg3; 
  result = (floo::BMXErrorCode)(arg1)->setSilenceTime(arg2,arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXPushService_setRunBackgroundMode__SWIG_0(void* imarg1, BOOL imarg2) {
  floo::BMXPushService *arg1 = (floo::BMXPushService *) 0 ;
  bool arg2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXPushService *)imarg1; 
  arg2 = imarg2? true : false; 
  result = (floo::BMXErrorCode)(arg1)->setRunBackgroundMode(arg2);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXPushService_setRunBackgroundMode__SWIG_1(void* imarg1) {
  floo::BMXPushService *arg1 = (floo::BMXPushService *) 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXPushService *)imarg1; 
  result = (floo::BMXErrorCode)(arg1)->setRunBackgroundMode();
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXPushService_setGeoFenceMode__SWIG_0(void* imarg1, BOOL imarg2, BOOL imarg3) {
  floo::BMXPushService *arg1 = (floo::BMXPushService *) 0 ;
  bool arg2 ;
  bool arg3 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXPushService *)imarg1; 
  arg2 = imarg2? true : false; 
  arg3 = imarg3? true : false; 
  result = (floo::BMXErrorCode)(arg1)->setGeoFenceMode(arg2,arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXPushService_setGeoFenceMode__SWIG_1(void* imarg1, BOOL imarg2) {
  floo::BMXPushService *arg1 = (floo::BMXPushService *) 0 ;
  bool arg2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXPushService *)imarg1; 
  arg2 = imarg2? true : false; 
  result = (floo::BMXErrorCode)(arg1)->setGeoFenceMode(arg2);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXPushService_setGeoFenceMode__SWIG_2(void* imarg1) {
  floo::BMXPushService *arg1 = (floo::BMXPushService *) 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXPushService *)imarg1; 
  result = (floo::BMXErrorCode)(arg1)->setGeoFenceMode();
  imresult = (int)result; 
  return imresult;
}

void _wrap_BMXPushService_clearNotification(void* imarg1, long long imarg2) {
  floo::BMXPushService *arg1 = (floo::BMXPushService *) 0 ;
  int64_t arg2 ;
  
  arg1 = (floo::BMXPushService *)imarg1; 
  arg2 = (int64_t)imarg2; 
  (arg1)->clearNotification(arg2);
}

void _wrap_BMXPushService_clearAllNotifications(void* imarg1) {
  floo::BMXPushService *arg1 = (floo::BMXPushService *) 0 ;
  
  arg1 = (floo::BMXPushService *)imarg1; 
  (arg1)->clearAllNotifications();
}

void _wrap_BMXPushService_sendMessage(void* imarg1, NSString* imarg2) {
  floo::BMXPushService *arg1 = (floo::BMXPushService *) 0 ;
  std::string *arg2 = 0 ;
  
  arg1 = (floo::BMXPushService *)imarg1; 
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  (arg1)->sendMessage((std::string const &)*arg2);
}

int _wrap_BMXPushService_loadLocalPushMessages__SWIG_0(void* imarg1, long long imarg2, unsigned long imarg3, void* imarg4, int imarg5) {
  floo::BMXPushService *arg1 = (floo::BMXPushService *) 0 ;
  int64_t arg2 ;
  size_t arg3 ;
  floo::BMXMessageList *arg4 = 0 ;
  floo::BMXPushService::PushDirection arg5 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXPushService *)imarg1; 
  arg2 = (int64_t)imarg2; 
  arg3 = (size_t)imarg3; 
  arg4 = (floo::BMXMessageList *)imarg4; 
  arg5 = (floo::BMXPushService::PushDirection)imarg5; 
  result = (floo::BMXErrorCode)(arg1)->loadLocalPushMessages(arg2,arg3,*arg4,arg5);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXPushService_loadLocalPushMessages__SWIG_1(void* imarg1, long long imarg2, unsigned long imarg3, void* imarg4) {
  floo::BMXPushService *arg1 = (floo::BMXPushService *) 0 ;
  int64_t arg2 ;
  size_t arg3 ;
  floo::BMXMessageList *arg4 = 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXPushService *)imarg1; 
  arg2 = (int64_t)imarg2; 
  arg3 = (size_t)imarg3; 
  arg4 = (floo::BMXMessageList *)imarg4; 
  result = (floo::BMXErrorCode)(arg1)->loadLocalPushMessages(arg2,arg3,*arg4);
  imresult = (int)result; 
  return imresult;
}

void _wrap_BMXPushService_addPushListener(void* imarg1, void* imarg2) {
  floo::BMXPushService *arg1 = (floo::BMXPushService *) 0 ;
  floo::BMXPushServiceListener *arg2 = (floo::BMXPushServiceListener *) 0 ;
  
  arg1 = (floo::BMXPushService *)imarg1; 
  arg2 = (floo::BMXPushServiceListener *)imarg2; 
  (arg1)->addPushListener(arg2);
}

void _wrap_BMXPushService_removePushListener(void* imarg1, void* imarg2) {
  floo::BMXPushService *arg1 = (floo::BMXPushService *) 0 ;
  floo::BMXPushServiceListener *arg2 = (floo::BMXPushServiceListener *) 0 ;
  
  arg1 = (floo::BMXPushService *)imarg1; 
  arg2 = (floo::BMXPushServiceListener *)imarg2; 
  (arg1)->removePushListener(arg2);
}

void* _wrap_new_BMXPushServiceListener() {
  void* imresult = 0 ;
  floo::BMXPushServiceListener *result = 0 ;
  
  result = (floo::BMXPushServiceListener *)new floo::BMXPushServiceListener();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_delete_BMXPushServiceListener(void* imarg1) {
  floo::BMXPushServiceListener *arg1 = (floo::BMXPushServiceListener *) 0 ;
  
  arg1 = (floo::BMXPushServiceListener *)imarg1; 
  delete arg1;
}

void _wrap_BMXPushServiceListener_onPushStart(void* imarg1, NSString* imarg2) {
  floo::BMXPushServiceListener *arg1 = (floo::BMXPushServiceListener *) 0 ;
  std::string arg2 ;
  
  arg1 = (floo::BMXPushServiceListener *)imarg1; 
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  } 
  
  (arg1)->onPushStart(getStdString(imarg2));
}

void _wrap_BMXPushServiceListener_onPushStop(void* imarg1) {
  floo::BMXPushServiceListener *arg1 = (floo::BMXPushServiceListener *) 0 ;
  
  arg1 = (floo::BMXPushServiceListener *)imarg1; 
  (arg1)->onPushStop();
}

void _wrap_BMXPushServiceListener_onCertRetrieved(void* imarg1, NSString* imarg2) {
  floo::BMXPushServiceListener *arg1 = (floo::BMXPushServiceListener *) 0 ;
  std::string arg2 ;
  
  arg1 = (floo::BMXPushServiceListener *)imarg1; 
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  } 
  
  (arg1)->onCertRetrieved(getStdString(imarg2));
}

void _wrap_BMXPushServiceListener_onSetTags(void* imarg1, NSString* imarg2) {
  floo::BMXPushServiceListener *arg1 = (floo::BMXPushServiceListener *) 0 ;
  std::string *arg2 = 0 ;
  
  arg1 = (floo::BMXPushServiceListener *)imarg1; 
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  (arg1)->onSetTags((std::string const &)*arg2);
}

void _wrap_BMXPushServiceListener_onGetTags(void* imarg1, NSString* imarg2) {
  floo::BMXPushServiceListener *arg1 = (floo::BMXPushServiceListener *) 0 ;
  std::string *arg2 = 0 ;
  
  arg1 = (floo::BMXPushServiceListener *)imarg1; 
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  (arg1)->onGetTags((std::string const &)*arg2);
}

void _wrap_BMXPushServiceListener_onDeleteTags(void* imarg1, NSString* imarg2) {
  floo::BMXPushServiceListener *arg1 = (floo::BMXPushServiceListener *) 0 ;
  std::string *arg2 = 0 ;
  
  arg1 = (floo::BMXPushServiceListener *)imarg1; 
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  (arg1)->onDeleteTags((std::string const &)*arg2);
}

void _wrap_BMXPushServiceListener_onClearTags(void* imarg1, NSString* imarg2) {
  floo::BMXPushServiceListener *arg1 = (floo::BMXPushServiceListener *) 0 ;
  std::string *arg2 = 0 ;
  
  arg1 = (floo::BMXPushServiceListener *)imarg1; 
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  (arg1)->onClearTags((std::string const &)*arg2);
}

void _wrap_BMXPushServiceListener_onReceivePush(void* imarg1, void* imarg2) {
  floo::BMXPushServiceListener *arg1 = (floo::BMXPushServiceListener *) 0 ;
  floo::BMXMessageList *arg2 = 0 ;
  
  arg1 = (floo::BMXPushServiceListener *)imarg1; 
  arg2 = (floo::BMXMessageList *)imarg2; 
  (arg1)->onReceivePush((floo::BMXMessageList const &)*arg2);
}

void _wrap_BMXPushServiceListener_onStatusChanged(void* imarg1, void* imarg2, int imarg3) {
  floo::BMXPushServiceListener *arg1 = (floo::BMXPushServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXMessage > > arg2 ;
  floo::BMXErrorCode arg3 ;
  floo::BMXMessagePtr *argp2 ;
  
  arg1 = (floo::BMXPushServiceListener *)imarg1; 
  
  argp2 = (floo::BMXMessagePtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (floo::BMXErrorCode)imarg3; 
  (arg1)->onStatusChanged(arg2,arg3);
}

void _wrap_BMXPushServiceListener_registerPushService(void* imarg1, void* imarg2) {
  floo::BMXPushServiceListener *arg1 = (floo::BMXPushServiceListener *) 0 ;
  floo::BMXPushService *arg2 = (floo::BMXPushService *) 0 ;
  
  arg1 = (floo::BMXPushServiceListener *)imarg1; 
  arg2 = (floo::BMXPushService *)imarg2; 
  (arg1)->registerPushService(arg2);
}

void* _wrap_BMXClient_create(void* imarg1) {
  SwigValueWrapper< std::shared_ptr< floo::BMXSDKConfig > > arg1 ;
  floo::BMXSDKConfigPtr *argp1 ;
  void* imresult = 0 ;
  std::shared_ptr< floo::BMXClient > result;
  
  
  argp1 = (floo::BMXSDKConfigPtr *)imarg1;
  arg1 = *argp1; 
  
  result = floo::BMXClient::create(arg1);
  
  BMXClient2Void(result)
  imresult = (void*)lresult;

  return imresult;
}

void _wrap_delete_BMXClient(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXClientPtr arg1 ;
  floo::BMXClientPtr *argp1 = *(floo::BMXClientPtr **)&larg1;
  delete argp1;
}

void* _wrap_BMXClient_getSDKConfig(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXClientPtr arg1 ;
  floo::BMXClientPtr *argp1 = *(floo::BMXClientPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  void* imresult = 0 ;
  floo::BMXSDKConfigPtr *temp ;
  std::shared_ptr< floo::BMXSDKConfig > result;
  
  result = (arg1)->getSDKConfig();
  
  BMXSDKConfig2Void(result)
  imresult = (void*)lresult; 
  
  return imresult;
}

void* _wrap_BMXClient_getUserService(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXClientPtr arg1 ;
  floo::BMXClientPtr *argp1 = *(floo::BMXClientPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  void* imresult = 0 ;
  floo::BMXUserService *result = 0 ;
  
  result = (floo::BMXUserService *) &(arg1)->getUserService();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_BMXClient_getChatService(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXClientPtr arg1 ;
  floo::BMXClientPtr *argp1 = *(floo::BMXClientPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  void* imresult = 0 ;
  floo::BMXChatService *result = 0 ;
  
  result = (floo::BMXChatService *) &(arg1)->getChatService();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_BMXClient_getGroupService(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXClientPtr arg1 ;
  floo::BMXClientPtr *argp1 = *(floo::BMXClientPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  void* imresult = 0 ;
  floo::BMXGroupService *result = 0 ;
  
  result = (floo::BMXGroupService *) &(arg1)->getGroupService();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_BMXClient_getRosterService(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXClientPtr arg1 ;
  floo::BMXClientPtr *argp1 = *(floo::BMXClientPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  void* imresult = 0 ;
  floo::BMXRosterService *result = 0 ;
  
  result = (floo::BMXRosterService *) &(arg1)->getRosterService();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_BMXClient_getPushService(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXClientPtr arg1 ;
  floo::BMXClientPtr *argp1 = *(floo::BMXClientPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  void* imresult = 0 ;
  floo::BMXPushService *result = 0 ;
  
  result = (floo::BMXPushService *) &(arg1)->getPushService();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_BMXClient_getRTCService(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXClientPtr arg1 ;
  floo::BMXClientPtr *argp1 = *(floo::BMXClientPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  void* imresult = 0 ;
  floo::BMXRTCService *result = 0 ;
  
  result = (floo::BMXRTCService *) &(arg1)->getRTCService();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}
int _wrap_BMXClient_signUpNewUser(void* imarg1, NSString* imarg2, NSString* imarg3, void** imarg4) {
  long long larg1 = (long long)imarg1;
  floo::BMXClientPtr arg1 ;
  floo::BMXClientPtr *argp1 = *(floo::BMXClientPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  BMXUserProfilePtr arg4 = 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str; 
  
  result = (floo::BMXErrorCode)(arg1)->signUpNewUser((std::string const &)*arg2,(std::string const &)*arg3,arg4);
  BMXUserProfile2Void(arg4)
  *imarg4 = (void*)lresult;
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXClient_signInByName(void* imarg1, NSString* imarg2, NSString* imarg3) {
  long long larg1 = (long long)imarg1;
  floo::BMXClientPtr arg1 ;
  floo::BMXClientPtr *argp1 = *(floo::BMXClientPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str; 
  
  result = (floo::BMXErrorCode)(arg1)->signInByName((std::string const &)*arg2,(std::string const &)*arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXClient_signInById(void* imarg1, long long imarg2, NSString* imarg3) {
  long long larg1 = (long long)imarg1;
  floo::BMXClientPtr arg1 ;
  floo::BMXClientPtr *argp1 = *(floo::BMXClientPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int64_t arg2 ;
  std::string *arg3 = 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg2 = (int64_t)imarg2; 
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str; 
  
  result = (floo::BMXErrorCode)(arg1)->signInById(arg2,(std::string const &)*arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXClient_fastSignInByName(void* imarg1, NSString* imarg2, NSString* imarg3) {
  long long larg1 = (long long)imarg1;
  floo::BMXClientPtr arg1 ;
  floo::BMXClientPtr *argp1 = *(floo::BMXClientPtr **)&larg1;
  if (argp1) arg1 = *argp1;

  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str; 
  
  result = (floo::BMXErrorCode)(arg1)->fastSignInByName((std::string const &)*arg2,(std::string const &)*arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXClient_fastSignInById(void* imarg1, long long imarg2, NSString* imarg3) {
  long long larg1 = (long long)imarg1;
  floo::BMXClientPtr arg1 ;
  floo::BMXClientPtr *argp1 = *(floo::BMXClientPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int64_t arg2 ;
  std::string *arg3 = 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg2 = (int64_t)imarg2; 
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str; 
  
  result = (floo::BMXErrorCode)(arg1)->fastSignInById(arg2,(std::string const &)*arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXClient_signOut__SWIG_0(void* imarg1, long long imarg2, BOOL imarg3) {
  long long larg1 = (long long)imarg1;
  floo::BMXClientPtr arg1 ;
  floo::BMXClientPtr *argp1 = *(floo::BMXClientPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int64_t arg2 ;
  bool arg3 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg2 = (int64_t)imarg2; 
  arg3 = imarg3? true : false; 
  result = (floo::BMXErrorCode)(arg1)->signOut(arg2,arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXClient_signOut__SWIG_1(void* imarg1, long long imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXClientPtr arg1 ;
  floo::BMXClientPtr *argp1 = *(floo::BMXClientPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int64_t arg2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg2 = (int64_t)imarg2; 
  result = (floo::BMXErrorCode)(arg1)->signOut(arg2);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXClient_signOut__SWIG_2(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXClientPtr arg1 ;
  floo::BMXClientPtr *argp1 = *(floo::BMXClientPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  result = (floo::BMXErrorCode)(arg1)->signOut();
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXClient_deleteAccount(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXClientPtr arg1 ;
  floo::BMXClientPtr *argp1 = *(floo::BMXClientPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string arg2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  } 
  
  result = (floo::BMXErrorCode)(arg1)->deleteAccount(getStdString(imarg2));
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXClient_connectStatus(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXClientPtr arg1 ;
  floo::BMXClientPtr *argp1 = *(floo::BMXClientPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  floo::BMXConnectStatus result;
  
  result = (floo::BMXConnectStatus)(arg1)->connectStatus();
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXClient_signInStatus(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXClientPtr arg1 ;
  floo::BMXClientPtr *argp1 = *(floo::BMXClientPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  floo::BMXSignInStatus result;
  
  result = (floo::BMXSignInStatus)(arg1)->signInStatus();
  imresult = (int)result; 
  return imresult;
}

void _wrap_BMXClient_reconnect(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXClientPtr arg1 ;
  floo::BMXClientPtr *argp1 = *(floo::BMXClientPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  
  (arg1)->reconnect();
}

void _wrap_BMXClient_onNetworkChanged(void* imarg1, int imarg2, BOOL imarg3) {
  long long larg1 = (long long)imarg1;
  floo::BMXClientPtr arg1 ;
  floo::BMXClientPtr *argp1 = *(floo::BMXClientPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  floo::BMXNetworkType arg2 ;
  bool arg3 ;
  
  arg2 = (floo::BMXNetworkType)imarg2; 
  arg3 = imarg3? true : false; 
  (arg1)->onNetworkChanged(arg2,arg3);
}

void _wrap_BMXClient_disconnect(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXClientPtr arg1 ;
  floo::BMXClientPtr *argp1 = *(floo::BMXClientPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  
  (arg1)->disconnect();
}

int _wrap_BMXClient_changeAppId__SWIG_0(void* imarg1, NSString* imarg2, NSString* imarg3) {
  long long larg1 = (long long)imarg1;
  floo::BMXClientPtr arg1 ;
  floo::BMXClientPtr *argp1 = *(floo::BMXClientPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str; 
  
  result = (floo::BMXErrorCode)(arg1)->changeAppId((std::string const &)*arg2,(std::string const &)*arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXClient_changeAppId__SWIG_1(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXClientPtr arg1 ;
  floo::BMXClientPtr *argp1 = *(floo::BMXClientPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  result = (floo::BMXErrorCode)(arg1)->changeAppId((std::string const &)*arg2);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXClient_initializeServerConfig(void* imarg1, BOOL imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXClientPtr arg1 ;
  floo::BMXClientPtr *argp1 = *(floo::BMXClientPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  bool arg2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg2 = imarg2? true : false; 
  result = (floo::BMXErrorCode)(arg1)->initializeServerConfig(arg2);
  imresult = (int)result; 
  return imresult;
}

void _wrap_BMXClient_sendMessage(void* imarg1, void* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXClientPtr arg1 ;
  floo::BMXClientPtr *argp1 = *(floo::BMXClientPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  SwigValueWrapper< std::shared_ptr< floo::BMXMessage > > arg2 ;
  floo::BMXMessagePtr *argp2 ;
  
  
  argp2 = (floo::BMXMessagePtr *)imarg2;
  arg2 = *argp2; 
  
  (arg1)->sendMessage(arg2);
}

void* _wrap_new_BMXFileAttachment__SWIG_0(NSString* imarg1, NSString* imarg2) {
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  void* imresult = 0 ;
  floo::BMXFileAttachment *result = 0 ;
  
  if(!imarg1) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg1_str(getStdString(imarg1));
  arg1 = &arg1_str; 
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  result = (floo::BMXFileAttachment *)new floo::BMXFileAttachment((std::string const &)*arg1,(std::string const &)*arg2);
  BMXFileAttachment2Void(result)
  imresult = (void*)lresult;
  return imresult;
}

void* _wrap_new_BMXFileAttachment__SWIG_1(NSString* imarg1) {
  std::string *arg1 = 0 ;
  void* imresult = 0 ;
  floo::BMXFileAttachment *result = 0 ;
  
  if(!imarg1) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg1_str(getStdString(imarg1));
  arg1 = &arg1_str; 
  
  result = (floo::BMXFileAttachment *)new floo::BMXFileAttachment((std::string const &)*arg1);
  BMXFileAttachment2Void(result)
  imresult = (void*)lresult;
  return imresult;
}

void* _wrap_new_BMXFileAttachment__SWIG_2(NSString* imarg1, NSString* imarg2, long long imarg3) {
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  int64_t arg3 ;
  void* imresult = 0 ;
  floo::BMXFileAttachment *result = 0 ;
  
  if(!imarg1) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg1_str(getStdString(imarg1));
  arg1 = &arg1_str; 
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  arg3 = (int64_t)imarg3; 
  result = (floo::BMXFileAttachment *)new floo::BMXFileAttachment((std::string const &)*arg1,(std::string const &)*arg2,arg3);
  BMXFileAttachment2Void(result)
  imresult = (void*)lresult;
  return imresult;
}

void _wrap_delete_BMXFileAttachment(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXFileAttachmentPtr arg1 ;
  floo::BMXFileAttachmentPtr *argp1 = *(floo::BMXFileAttachmentPtr **)&larg1;
  delete argp1;
}

int _wrap_BMXFileAttachment_type(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXFileAttachmentPtr arg1 ;
  floo::BMXFileAttachmentPtr *argp1 = *(floo::BMXFileAttachmentPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  floo::BMXMessageAttachment::Type result;
  
  result = (floo::BMXMessageAttachment::Type)(arg1)->type();
  imresult = (int)result; 
  return imresult;
}

void* _wrap_BMXFileAttachment_clone(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXFileAttachmentPtr arg1 ;
  floo::BMXFileAttachmentPtr *argp1 = *(floo::BMXFileAttachmentPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  void* imresult = 0 ;
  floo::BMXMessageAttachmentPtr *temp ;
  std::shared_ptr< floo::BMXMessageAttachment > result;
  
  result = (arg1)->clone();
  
  BMXMessageAttachment2Void(result)
  imresult = (void*)lresult;
  
  return imresult;
}

NSString* _wrap_BMXFileAttachment_path(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXFileAttachmentPtr arg1 ;
  floo::BMXFileAttachmentPtr *argp1 = *(floo::BMXFileAttachmentPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &(arg1)->path();
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_BMXFileAttachment_displayName(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXFileAttachmentPtr arg1 ;
  floo::BMXFileAttachmentPtr *argp1 = *(floo::BMXFileAttachmentPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &(arg1)->displayName();
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_BMXFileAttachment_ratelUrl(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXFileAttachmentPtr arg1 ;
  floo::BMXFileAttachmentPtr *argp1 = *(floo::BMXFileAttachmentPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &(arg1)->ratelUrl();
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_BMXFileAttachment_url(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXFileAttachmentPtr arg1 ;
  floo::BMXFileAttachmentPtr *argp1 = *(floo::BMXFileAttachmentPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &(arg1)->url();
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

long long _wrap_BMXFileAttachment_fileLength(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXFileAttachmentPtr arg1 ;
  floo::BMXFileAttachmentPtr *argp1 = *(floo::BMXFileAttachmentPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  long long imresult = 0 ;
  int64_t result;
  
  result = (int64_t)(arg1)->fileLength();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

int _wrap_BMXFileAttachment_downloadStatus(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXFileAttachmentPtr arg1 ;
  floo::BMXFileAttachmentPtr *argp1 = *(floo::BMXFileAttachmentPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  floo::BMXMessageAttachment::DownloadStatus result;
  
  result = (floo::BMXMessageAttachment::DownloadStatus)(arg1)->downloadStatus();
  imresult = (int)result; 
  return imresult;
}

void* _wrap_BMXFileAttachment_dynamic_cast(void* imarg1) {
    long long larg1 = (long long)imarg1;
    floo::BMXFileAttachmentPtr arg1 ;
    floo::BMXFileAttachmentPtr *argp1 = *(floo::BMXFileAttachmentPtr **)&larg1;
    if (argp1) arg1 = *argp1;
      
    return argp1;
}

void _wrap_BMXVideoConfig_width_set(void* imarg1, int imarg2) {
  floo::BMXVideoConfig *arg1 = (floo::BMXVideoConfig *) 0 ;
  int arg2 ;
  
  arg1 = (floo::BMXVideoConfig *)imarg1;
  arg2 = (int)imarg2;
  if (arg1) (arg1)->width = arg2;
}

int _wrap_BMXVideoConfig_width_get(void* imarg1) {
  floo::BMXVideoConfig *arg1 = (floo::BMXVideoConfig *) 0 ;
  int imresult = 0 ;
  int result;
  
  arg1 = (floo::BMXVideoConfig *)imarg1;
  result = (int) ((arg1)->width);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_BMXVideoConfig_height_set(void* imarg1, int imarg2) {
  floo::BMXVideoConfig *arg1 = (floo::BMXVideoConfig *) 0 ;
  int arg2 ;
  
  arg1 = (floo::BMXVideoConfig *)imarg1;
  arg2 = (int)imarg2;
  if (arg1) (arg1)->height = arg2;
}

int _wrap_BMXVideoConfig_height_get(void* imarg1) {
  floo::BMXVideoConfig *arg1 = (floo::BMXVideoConfig *) 0 ;
  int imresult = 0 ;
  int result;
  
  arg1 = (floo::BMXVideoConfig *)imarg1;
  result = (int) ((arg1)->height);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_BMXVideoConfig_frameRate_set(void* imarg1, int imarg2) {
  floo::BMXVideoConfig *arg1 = (floo::BMXVideoConfig *) 0 ;
  int arg2 ;
  
  arg1 = (floo::BMXVideoConfig *)imarg1;
  arg2 = (int)imarg2;
  if (arg1) (arg1)->frameRate = arg2;
}

int _wrap_BMXVideoConfig_frameRate_get(void* imarg1) {
  floo::BMXVideoConfig *arg1 = (floo::BMXVideoConfig *) 0 ;
  int imresult = 0 ;
  int result;
  
  arg1 = (floo::BMXVideoConfig *)imarg1;
  result = (int) ((arg1)->frameRate);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_BMXVideoConfig_profile_set(void* imarg1, int imarg2) {
  floo::BMXVideoConfig *arg1 = (floo::BMXVideoConfig *) 0 ;
  floo::BMXVideoProfile arg2 ;
  
  arg1 = (floo::BMXVideoConfig *)imarg1;
  arg2 = (floo::BMXVideoProfile)imarg2;
  if (arg1) (arg1)->profile = arg2;
}

int _wrap_BMXVideoConfig_profile_get(void* imarg1) {
  floo::BMXVideoConfig *arg1 = (floo::BMXVideoConfig *) 0 ;
  int imresult = 0 ;
  floo::BMXVideoProfile result;
  
  arg1 = (floo::BMXVideoConfig *)imarg1;
  result = (floo::BMXVideoProfile) ((arg1)->profile);
  imresult = (int)result;
  return imresult;
}

void* _wrap_new_BMXVideoConfig() {
  void* imresult = 0 ;
  floo::BMXVideoConfig *result = 0 ;
  
  result = (floo::BMXVideoConfig *)new floo::BMXVideoConfig();
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_delete_BMXVideoConfig(void* imarg1) {
  floo::BMXVideoConfig *arg1 = (floo::BMXVideoConfig *) 0 ;
  
  arg1 = (floo::BMXVideoConfig *)imarg1;
  delete arg1;
}

void _wrap_BMXRoomAuth_mRoomId_set(void* imarg1, long long imarg2) {
  floo::BMXRoomAuth *arg1 = (floo::BMXRoomAuth *) 0 ;
  int64_t arg2 ;
  
  arg1 = (floo::BMXRoomAuth *)imarg1;
  arg2 = (int64_t)imarg2;
  if (arg1) (arg1)->mRoomId = arg2;
}

long long _wrap_BMXRoomAuth_mRoomId_get(void* imarg1) {
  floo::BMXRoomAuth *arg1 = (floo::BMXRoomAuth *) 0 ;
  long long imresult = 0 ;
  int64_t result;
  
  arg1 = (floo::BMXRoomAuth *)imarg1;
  result = (int64_t) ((arg1)->mRoomId);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_BMXRoomAuth_mToken_set(void* imarg1, NSString* imarg2) {
  floo::BMXRoomAuth *arg1 = (floo::BMXRoomAuth *) 0 ;
  std::string *arg2 = 0 ;
  
  arg1 = (floo::BMXRoomAuth *)imarg1;
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str;
  
  if (arg1) (arg1)->mToken = *arg2;
}

NSString* _wrap_BMXRoomAuth_mToken_get(void* imarg1) {
  floo::BMXRoomAuth *arg1 = (floo::BMXRoomAuth *) 0 ;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  arg1 = (floo::BMXRoomAuth *)imarg1;
  result = (std::string *) & ((arg1)->mToken);
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXRoomAuth_mOptionalInfo_set(void* imarg1, NSString* imarg2) {
  floo::BMXRoomAuth *arg1 = (floo::BMXRoomAuth *) 0 ;
  std::string *arg2 = 0 ;
  
  arg1 = (floo::BMXRoomAuth *)imarg1;
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str;
  
  if (arg1) (arg1)->mOptionalInfo = *arg2;
}

NSString* _wrap_BMXRoomAuth_mOptionalInfo_get(void* imarg1) {
  floo::BMXRoomAuth *arg1 = (floo::BMXRoomAuth *) 0 ;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  arg1 = (floo::BMXRoomAuth *)imarg1;
  result = (std::string *) & ((arg1)->mOptionalInfo);
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXRoomAuth_mUserId_set(void* imarg1, long long imarg2) {
  floo::BMXRoomAuth *arg1 = (floo::BMXRoomAuth *) 0 ;
  int64_t arg2 ;
  
  arg1 = (floo::BMXRoomAuth *)imarg1;
  arg2 = (int64_t)imarg2;
  if (arg1) (arg1)->mUserId = arg2;
}

long long _wrap_BMXRoomAuth_mUserId_get(void* imarg1) {
  floo::BMXRoomAuth *arg1 = (floo::BMXRoomAuth *) 0 ;
  long long imresult = 0 ;
  int64_t result;
  
  arg1 = (floo::BMXRoomAuth *)imarg1;
  result = (int64_t) ((arg1)->mUserId);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void* _wrap_new_BMXRoomAuth() {
  void* imresult = 0 ;
  floo::BMXRoomAuth *result = 0 ;
  
  result = (floo::BMXRoomAuth *)new floo::BMXRoomAuth();
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_delete_BMXRoomAuth(void* imarg1) {
  floo::BMXRoomAuth *arg1 = (floo::BMXRoomAuth *) 0 ;
  
  arg1 = (floo::BMXRoomAuth *)imarg1;
  delete arg1;
}

void _wrap_BMXStream_mUserId_set(void* imarg1, long long imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXStreamPtr arg1 ;
  floo::BMXStreamPtr *argp1 = *(floo::BMXStreamPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int64_t arg2 ;
  
  arg2 = (int64_t)imarg2;
  if (arg1) (arg1)->mUserId = arg2;
}

long long _wrap_BMXStream_mUserId_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXStreamPtr arg1 ;
  floo::BMXStreamPtr *argp1 = *(floo::BMXStreamPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  long long imresult = 0 ;
  int64_t result;
  
  result = (int64_t) ((arg1)->mUserId);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_BMXStream_mStreamId_set(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXStreamPtr arg1 ;
  floo::BMXStreamPtr *argp1 = *(floo::BMXStreamPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str;
  
  if (arg1) (arg1)->mStreamId = *arg2;
}

NSString* _wrap_BMXStream_mStreamId_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXStreamPtr arg1 ;
  floo::BMXStreamPtr *argp1 = *(floo::BMXStreamPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) & ((arg1)->mStreamId);
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXStream_mMediaType_set(void* imarg1, int imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXStreamPtr arg1 ;
  floo::BMXStreamPtr *argp1 = *(floo::BMXStreamPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  floo::BMXVideoMediaType arg2 ;
  
  arg2 = (floo::BMXVideoMediaType)imarg2;
  if (arg1) (arg1)->mMediaType = arg2;
}

int _wrap_BMXStream_mMediaType_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXStreamPtr arg1 ;
  floo::BMXStreamPtr *argp1 = *(floo::BMXStreamPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  floo::BMXVideoMediaType result;
  
  result = (floo::BMXVideoMediaType) ((arg1)->mMediaType);
  imresult = (int)result;
  return imresult;
}

void _wrap_BMXStream_mEnableVideo_set(void* imarg1, BOOL imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXStreamPtr arg1 ;
  floo::BMXStreamPtr *argp1 = *(floo::BMXStreamPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  bool arg2 ;
  
  arg2 = imarg2? true : false;
  if (arg1) (arg1)->mEnableVideo = arg2;
}

BOOL _wrap_BMXStream_mEnableVideo_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXStreamPtr arg1 ;
  floo::BMXStreamPtr *argp1 = *(floo::BMXStreamPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BOOL imresult = 0 ;
  bool result;
  
  result = (bool) ((arg1)->mEnableVideo);
  imresult = (result)? YES:NO;
  return imresult;
}

void _wrap_BMXStream_mEnableAudio_set(void* imarg1, BOOL imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXStreamPtr arg1 ;
  floo::BMXStreamPtr *argp1 = *(floo::BMXStreamPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  bool arg2 ;
  
  arg2 = imarg2? true : false;
  if (arg1) (arg1)->mEnableAudio = arg2;
}

BOOL _wrap_BMXStream_mEnableAudio_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXStreamPtr arg1 ;
  floo::BMXStreamPtr *argp1 = *(floo::BMXStreamPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BOOL imresult = 0 ;
  bool result;
  
  result = (bool) ((arg1)->mEnableAudio);
  imresult = (result)? YES:NO;
  return imresult;
}

void _wrap_BMXStream_mEnableData_set(void* imarg1, BOOL imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXStreamPtr arg1 ;
  floo::BMXStreamPtr *argp1 = *(floo::BMXStreamPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  bool arg2 ;
  
  arg2 = imarg2? true : false;
  if (arg1) (arg1)->mEnableData = arg2;
}

BOOL _wrap_BMXStream_mEnableData_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXStreamPtr arg1 ;
  floo::BMXStreamPtr *argp1 = *(floo::BMXStreamPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BOOL imresult = 0 ;
  bool result;
  
  result = (bool) ((arg1)->mEnableData);
  imresult = (result)? YES:NO;
  return imresult;
}

void _wrap_BMXStream_mMuteVideo_set(void* imarg1, BOOL imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXStreamPtr arg1 ;
  floo::BMXStreamPtr *argp1 = *(floo::BMXStreamPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  bool arg2 ;
  
  arg2 = imarg2? true : false;
  if (arg1) (arg1)->mMuteVideo = arg2;
}

BOOL _wrap_BMXStream_mMuteVideo_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXStreamPtr arg1 ;
  floo::BMXStreamPtr *argp1 = *(floo::BMXStreamPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BOOL imresult = 0 ;
  bool result;
  
  result = (bool) ((arg1)->mMuteVideo);
  imresult = (result)? YES:NO;
  return imresult;
}

void _wrap_BMXStream_mMuteAudio_set(void* imarg1, BOOL imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXStreamPtr arg1 ;
  floo::BMXStreamPtr *argp1 = *(floo::BMXStreamPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  bool arg2 ;
  
  arg2 = imarg2? true : false;
  if (arg1) (arg1)->mMuteAudio = arg2;
}

BOOL _wrap_BMXStream_mMuteAudio_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXStreamPtr arg1 ;
  floo::BMXStreamPtr *argp1 = *(floo::BMXStreamPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BOOL imresult = 0 ;
  bool result;
  
  result = (bool) ((arg1)->mMuteAudio);
  imresult = (result)? YES:NO;
  return imresult;
}

void* _wrap_new_BMXStream() {
  void* imresult = 0 ;
  floo::BMXStream *result = 0 ;
  
  result = (floo::BMXStream *)new floo::BMXStream();
  BMXStream2Void(result)
  imresult = (void*)lresult;
  return imresult;
}

void _wrap_delete_BMXStream(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXStreamPtr arg1 ;
  floo::BMXStreamPtr *argp1 = *(floo::BMXStreamPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  
  delete argp1;
}

void _wrap_BMXVideoCanvas_mView_set(void* imarg1, void* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXVideoCanvasPtr arg1 ;
  floo::BMXVideoCanvasPtr *argp1 = *(floo::BMXVideoCanvasPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  void *arg2 = (void *) 0 ;
  
  arg2 = (void *)imarg2;
  if (arg1) (arg1)->mView = arg2;
}

void* _wrap_BMXVideoCanvas_mView_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXVideoCanvasPtr arg1 ;
  floo::BMXVideoCanvasPtr *argp1 = *(floo::BMXVideoCanvasPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  void* imresult = 0 ;
  void *result = 0 ;
  
  result = (void *) ((arg1)->mView);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_BMXVideoCanvas_mUserId_set(void* imarg1, long long imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXVideoCanvasPtr arg1 ;
  floo::BMXVideoCanvasPtr *argp1 = *(floo::BMXVideoCanvasPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int64_t arg2 ;
  
  arg2 = (int64_t)imarg2;
  if (arg1) (arg1)->mUserId = arg2;
}

long long _wrap_BMXVideoCanvas_mUserId_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXVideoCanvasPtr arg1 ;
  floo::BMXVideoCanvasPtr *argp1 = *(floo::BMXVideoCanvasPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  long long imresult = 0 ;
  int64_t result;
  
  result = (int64_t) ((arg1)->mUserId);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_BMXVideoCanvas_mStream_set(void* imarg1, void* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXVideoCanvasPtr arg1 ;
  floo::BMXVideoCanvasPtr *argp1 = *(floo::BMXVideoCanvasPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  floo::BMXStreamPtr *arg2 = (floo::BMXStreamPtr *) 0 ;
  
  arg2 = (floo::BMXStreamPtr *)imarg2;
  if (arg1) (arg1)->mStream = *arg2;
}

void* _wrap_BMXVideoCanvas_mStream_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXVideoCanvasPtr arg1 ;
  floo::BMXVideoCanvasPtr *argp1 = *(floo::BMXVideoCanvasPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  void* imresult = 0 ;
  floo::BMXStreamPtr *result = 0 ;
  
  result = (floo::BMXStreamPtr *)& ((arg1)->mStream);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_BMXVideoCanvas_mRenderMode_set(void* imarg1, int imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXVideoCanvasPtr arg1 ;
  floo::BMXVideoCanvasPtr *argp1 = *(floo::BMXVideoCanvasPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  floo::BMXRenderMode arg2 ;
  
  arg2 = (floo::BMXRenderMode)imarg2;
  if (arg1) (arg1)->mRenderMode = arg2;
}

int _wrap_BMXVideoCanvas_mRenderMode_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXVideoCanvasPtr arg1 ;
  floo::BMXVideoCanvasPtr *argp1 = *(floo::BMXVideoCanvasPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  floo::BMXRenderMode result;
  
  result = (floo::BMXRenderMode) ((arg1)->mRenderMode);
  imresult = (int)result;
  return imresult;
}

void _wrap_BMXVideoCanvas_mMirrodMode_set(void* imarg1, int imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXVideoCanvasPtr arg1 ;
  floo::BMXVideoCanvasPtr *argp1 = *(floo::BMXVideoCanvasPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  floo::BMXMirrorMode arg2 ;
  
  arg2 = (floo::BMXMirrorMode)imarg2;
  if (arg1) (arg1)->mMirrodMode = arg2;
}

int _wrap_BMXVideoCanvas_mMirrodMode_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXVideoCanvasPtr arg1 ;
  floo::BMXVideoCanvasPtr *argp1 = *(floo::BMXVideoCanvasPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  floo::BMXMirrorMode result;
  
  result = (floo::BMXMirrorMode) ((arg1)->mMirrodMode);
  imresult = (int)result;
  return imresult;
}

void* _wrap_new_BMXVideoCanvas() {
  void* imresult = 0 ;
  floo::BMXVideoCanvas *result = 0 ;
  
  result = (floo::BMXVideoCanvas *)new floo::BMXVideoCanvas();
  BMXVideoCanvas2Void(result)
  imresult = (void*)lresult;
  return imresult;
}

void _wrap_delete_BMXVideoCanvas(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXVideoCanvasPtr arg1 ;
  floo::BMXVideoCanvasPtr *argp1 = *(floo::BMXVideoCanvasPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  
  delete argp1;
}

void _wrap_BMXStreamStats_mUserId_set(void* imarg1, int imarg2) {
  floo::BMXStreamStats *arg1 = (floo::BMXStreamStats *) 0 ;
  int arg2 ;
  
  arg1 = (floo::BMXStreamStats *)imarg1;
  arg2 = (int)imarg2;
  if (arg1) (arg1)->mUserId = arg2;
}

int _wrap_BMXStreamStats_mUserId_get(void* imarg1) {
  floo::BMXStreamStats *arg1 = (floo::BMXStreamStats *) 0 ;
  int imresult = 0 ;
  int result;
  
  arg1 = (floo::BMXStreamStats *)imarg1;
  result = (int) ((arg1)->mUserId);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_BMXStreamStats_mStreamId_set(void* imarg1, NSString* imarg2) {
  floo::BMXStreamStats *arg1 = (floo::BMXStreamStats *) 0 ;
  std::string *arg2 = 0 ;
  
  arg1 = (floo::BMXStreamStats *)imarg1;
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str;
  
  if (arg1) (arg1)->mStreamId = *arg2;
}

NSString* _wrap_BMXStreamStats_mStreamId_get(void* imarg1) {
  floo::BMXStreamStats *arg1 = (floo::BMXStreamStats *) 0 ;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  arg1 = (floo::BMXStreamStats *)imarg1;
  result = (std::string *) & ((arg1)->mStreamId);
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXStreamStats_mMediaType_set(void* imarg1, int imarg2) {
  floo::BMXStreamStats *arg1 = (floo::BMXStreamStats *) 0 ;
  floo::BMXVideoMediaType arg2 ;
  
  arg1 = (floo::BMXStreamStats *)imarg1;
  arg2 = (floo::BMXVideoMediaType)imarg2;
  if (arg1) (arg1)->mMediaType = arg2;
}

int _wrap_BMXStreamStats_mMediaType_get(void* imarg1) {
  floo::BMXStreamStats *arg1 = (floo::BMXStreamStats *) 0 ;
  int imresult = 0 ;
  floo::BMXVideoMediaType result;
  
  arg1 = (floo::BMXStreamStats *)imarg1;
  result = (floo::BMXVideoMediaType) ((arg1)->mMediaType);
  imresult = (int)result;
  return imresult;
}

void _wrap_BMXStreamStats_mTrackType_set(void* imarg1, int imarg2) {
  floo::BMXStreamStats *arg1 = (floo::BMXStreamStats *) 0 ;
  floo::BMXTrackType arg2 ;
  
  arg1 = (floo::BMXStreamStats *)imarg1;
  arg2 = (floo::BMXTrackType)imarg2;
  if (arg1) (arg1)->mTrackType = arg2;
}

int _wrap_BMXStreamStats_mTrackType_get(void* imarg1) {
  floo::BMXStreamStats *arg1 = (floo::BMXStreamStats *) 0 ;
  int imresult = 0 ;
  floo::BMXTrackType result;
  
  arg1 = (floo::BMXStreamStats *)imarg1;
  result = (floo::BMXTrackType) ((arg1)->mTrackType);
  imresult = (int)result;
  return imresult;
}

void _wrap_BMXStreamStats_mAudioBitrate_set(void* imarg1, int imarg2) {
  floo::BMXStreamStats *arg1 = (floo::BMXStreamStats *) 0 ;
  int arg2 ;
  
  arg1 = (floo::BMXStreamStats *)imarg1;
  arg2 = (int)imarg2;
  if (arg1) (arg1)->mAudioBitrate = arg2;
}

int _wrap_BMXStreamStats_mAudioBitrate_get(void* imarg1) {
  floo::BMXStreamStats *arg1 = (floo::BMXStreamStats *) 0 ;
  int imresult = 0 ;
  int result;
  
  arg1 = (floo::BMXStreamStats *)imarg1;
  result = (int) ((arg1)->mAudioBitrate);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_BMXStreamStats_mVideoBitrate_set(void* imarg1, int imarg2) {
  floo::BMXStreamStats *arg1 = (floo::BMXStreamStats *) 0 ;
  int arg2 ;
  
  arg1 = (floo::BMXStreamStats *)imarg1;
  arg2 = (int)imarg2;
  if (arg1) (arg1)->mVideoBitrate = arg2;
}

int _wrap_BMXStreamStats_mVideoBitrate_get(void* imarg1) {
  floo::BMXStreamStats *arg1 = (floo::BMXStreamStats *) 0 ;
  int imresult = 0 ;
  int result;
  
  arg1 = (floo::BMXStreamStats *)imarg1;
  result = (int) ((arg1)->mVideoBitrate);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_BMXStreamStats_mWidth_set(void* imarg1, int imarg2) {
  floo::BMXStreamStats *arg1 = (floo::BMXStreamStats *) 0 ;
  int arg2 ;
  
  arg1 = (floo::BMXStreamStats *)imarg1;
  arg2 = (int)imarg2;
  if (arg1) (arg1)->mWidth = arg2;
}

int _wrap_BMXStreamStats_mWidth_get(void* imarg1) {
  floo::BMXStreamStats *arg1 = (floo::BMXStreamStats *) 0 ;
  int imresult = 0 ;
  int result;
  
  arg1 = (floo::BMXStreamStats *)imarg1;
  result = (int) ((arg1)->mWidth);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_BMXStreamStats_mHeight_set(void* imarg1, int imarg2) {
  floo::BMXStreamStats *arg1 = (floo::BMXStreamStats *) 0 ;
  int arg2 ;
  
  arg1 = (floo::BMXStreamStats *)imarg1;
  arg2 = (int)imarg2;
  if (arg1) (arg1)->mHeight = arg2;
}

int _wrap_BMXStreamStats_mHeight_get(void* imarg1) {
  floo::BMXStreamStats *arg1 = (floo::BMXStreamStats *) 0 ;
  int imresult = 0 ;
  int result;
  
  arg1 = (floo::BMXStreamStats *)imarg1;
  result = (int) ((arg1)->mHeight);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_BMXStreamStats_mFrameRate_set(void* imarg1, int imarg2) {
  floo::BMXStreamStats *arg1 = (floo::BMXStreamStats *) 0 ;
  int arg2 ;
  
  arg1 = (floo::BMXStreamStats *)imarg1;
  arg2 = (int)imarg2;
  if (arg1) (arg1)->mFrameRate = arg2;
}

int _wrap_BMXStreamStats_mFrameRate_get(void* imarg1) {
  floo::BMXStreamStats *arg1 = (floo::BMXStreamStats *) 0 ;
  int imresult = 0 ;
  int result;
  
  arg1 = (floo::BMXStreamStats *)imarg1;
  result = (int) ((arg1)->mFrameRate);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_BMXStreamStats_mPacketLostRate_set(void* imarg1, float imarg2) {
  floo::BMXStreamStats *arg1 = (floo::BMXStreamStats *) 0 ;
  float arg2 ;
  
  arg1 = (floo::BMXStreamStats *)imarg1;
  arg2 = (float)imarg2;
  if (arg1) (arg1)->mPacketLostRate = arg2;
}

float _wrap_BMXStreamStats_mPacketLostRate_get(void* imarg1) {
  floo::BMXStreamStats *arg1 = (floo::BMXStreamStats *) 0 ;
  float imresult = 0 ;
  float result;
  
  arg1 = (floo::BMXStreamStats *)imarg1;
  result = (float) ((arg1)->mPacketLostRate);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void* _wrap_new_BMXStreamStats() {
  void* imresult = 0 ;
  floo::BMXStreamStats *result = 0 ;
  
  result = (floo::BMXStreamStats *)new floo::BMXStreamStats();
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_delete_BMXStreamStats(void* imarg1) {
  floo::BMXStreamStats *arg1 = (floo::BMXStreamStats *) 0 ;
  
  arg1 = (floo::BMXStreamStats *)imarg1;
  delete arg1;
}

void* _wrap_new_BMXJanusStreamInfo() {
  void* imresult = 0 ;
  floo::BMXJanusStreamInfo *result = 0 ;
  
  result = (floo::BMXJanusStreamInfo *)new floo::BMXJanusStreamInfo();
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_BMXJanusStreamInfo_mFeedId_set(void* imarg1, long long imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXJanusStreamInfoPtr arg1 ;
  floo::BMXJanusStreamInfoPtr *argp1 = *(floo::BMXJanusStreamInfoPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int64_t arg2 ;
  
  arg2 = (int64_t)imarg2;
  if (arg1) (arg1)->mFeedId = arg2;
}

long long _wrap_BMXJanusStreamInfo_mFeedId_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXJanusStreamInfoPtr arg1 ;
  floo::BMXJanusStreamInfoPtr *argp1 = *(floo::BMXJanusStreamInfoPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  long long imresult = 0 ;
  int64_t result;
  
  result = (int64_t) ((arg1)->mFeedId);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_BMXJanusStreamInfo_mFeedDisplay_set(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXJanusStreamInfoPtr arg1 ;
  floo::BMXJanusStreamInfoPtr *argp1 = *(floo::BMXJanusStreamInfoPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str;
  
  if (arg1) (arg1)->mFeedDisplay = *arg2;
}

NSString* _wrap_BMXJanusStreamInfo_mFeedDisplay_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXJanusStreamInfoPtr arg1 ;
  floo::BMXJanusStreamInfoPtr *argp1 = *(floo::BMXJanusStreamInfoPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) & ((arg1)->mFeedDisplay);
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXJanusStreamInfo_mFeedMid_set(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXJanusStreamInfoPtr arg1 ;
  floo::BMXJanusStreamInfoPtr *argp1 = *(floo::BMXJanusStreamInfoPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str;
  
  if (arg1) (arg1)->mFeedMid = *arg2;
}

NSString* _wrap_BMXJanusStreamInfo_mFeedMid_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXJanusStreamInfoPtr arg1 ;
  floo::BMXJanusStreamInfoPtr *argp1 = *(floo::BMXJanusStreamInfoPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) & ((arg1)->mFeedMid);
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXJanusStreamInfo_mType_set(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXJanusStreamInfoPtr arg1 ;
  floo::BMXJanusStreamInfoPtr *argp1 = *(floo::BMXJanusStreamInfoPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str;
  
  if (arg1) (arg1)->mType = *arg2;
}

NSString* _wrap_BMXJanusStreamInfo_mType_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXJanusStreamInfoPtr arg1 ;
  floo::BMXJanusStreamInfoPtr *argp1 = *(floo::BMXJanusStreamInfoPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) & ((arg1)->mType);
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXJanusStreamInfo_mMid_set(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXJanusStreamInfoPtr arg1 ;
  floo::BMXJanusStreamInfoPtr *argp1 = *(floo::BMXJanusStreamInfoPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str;
  
  if (arg1) (arg1)->mMid = *arg2;
}

NSString* _wrap_BMXJanusStreamInfo_mMid_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXJanusStreamInfoPtr arg1 ;
  floo::BMXJanusStreamInfoPtr *argp1 = *(floo::BMXJanusStreamInfoPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) & ((arg1)->mMid);
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXJanusStreamInfo_mCodec_set(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXJanusStreamInfoPtr arg1 ;
  floo::BMXJanusStreamInfoPtr *argp1 = *(floo::BMXJanusStreamInfoPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str;
  
  if (arg1) (arg1)->mCodec = *arg2;
}

NSString* _wrap_BMXJanusStreamInfo_mCodec_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXJanusStreamInfoPtr arg1 ;
  floo::BMXJanusStreamInfoPtr *argp1 = *(floo::BMXJanusStreamInfoPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) & ((arg1)->mCodec);
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXJanusStreamInfo_mMindex_set(void* imarg1, int imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXJanusStreamInfoPtr arg1 ;
  floo::BMXJanusStreamInfoPtr *argp1 = *(floo::BMXJanusStreamInfoPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int arg2 ;
  
  arg2 = (int)imarg2;
  if (arg1) (arg1)->mMindex = arg2;
}

int _wrap_BMXJanusStreamInfo_mMindex_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXJanusStreamInfoPtr arg1 ;
  floo::BMXJanusStreamInfoPtr *argp1 = *(floo::BMXJanusStreamInfoPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  int result;
  
  result = (int) ((arg1)->mMindex);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_BMXJanusStreamInfo_mTalking_set(void* imarg1, BOOL imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXJanusStreamInfoPtr arg1 ;
  floo::BMXJanusStreamInfoPtr *argp1 = *(floo::BMXJanusStreamInfoPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  bool arg2 ;
  
  arg2 = imarg2? true : false;
  if (arg1) (arg1)->mTalking = arg2;
}

BOOL _wrap_BMXJanusStreamInfo_mTalking_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXJanusStreamInfoPtr arg1 ;
  floo::BMXJanusStreamInfoPtr *argp1 = *(floo::BMXJanusStreamInfoPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BOOL imresult = 0 ;
  bool result;
  
  result = (bool) ((arg1)->mTalking);
  imresult = (result)? YES:NO;
  return imresult;
}

void _wrap_BMXJanusStreamInfo_mActive_set(void* imarg1, BOOL imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXJanusStreamInfoPtr arg1 ;
  floo::BMXJanusStreamInfoPtr *argp1 = *(floo::BMXJanusStreamInfoPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  bool arg2 ;
  
  arg2 = imarg2? true : false;
  if (arg1) (arg1)->mActive = arg2;
}

BOOL _wrap_BMXJanusStreamInfo_mActive_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXJanusStreamInfoPtr arg1 ;
  floo::BMXJanusStreamInfoPtr *argp1 = *(floo::BMXJanusStreamInfoPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BOOL imresult = 0 ;
  bool result;
  
  result = (bool) ((arg1)->mActive);
  imresult = (result)? YES:NO;
  return imresult;
}

void _wrap_BMXJanusStreamInfo_mReady_set(void* imarg1, BOOL imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXJanusStreamInfoPtr arg1 ;
  floo::BMXJanusStreamInfoPtr *argp1 = *(floo::BMXJanusStreamInfoPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  bool arg2 ;
  
  arg2 = imarg2? true : false;
  if (arg1) (arg1)->mReady = arg2;
}

BOOL _wrap_BMXJanusStreamInfo_mReady_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXJanusStreamInfoPtr arg1 ;
  floo::BMXJanusStreamInfoPtr *argp1 = *(floo::BMXJanusStreamInfoPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BOOL imresult = 0 ;
  bool result;
  
  result = (bool) ((arg1)->mReady);
  imresult = (result)? YES:NO;
  return imresult;
}

void _wrap_BMXJanusStreamInfo_mSend_set(void* imarg1, BOOL imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXJanusStreamInfoPtr arg1 ;
  floo::BMXJanusStreamInfoPtr *argp1 = *(floo::BMXJanusStreamInfoPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  bool arg2 ;
  
  arg2 = imarg2? true : false;
  if (arg1) (arg1)->mSend = arg2;
}

BOOL _wrap_BMXJanusStreamInfo_mSend_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXJanusStreamInfoPtr arg1 ;
  floo::BMXJanusStreamInfoPtr *argp1 = *(floo::BMXJanusStreamInfoPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BOOL imresult = 0 ;
  bool result;
  
  result = (bool) ((arg1)->mSend);
  imresult = (result)? YES:NO;
  return imresult;
}

void _wrap_delete_BMXJanusStreamInfo(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXJanusStreamInfoPtr arg1 ;
  floo::BMXJanusStreamInfoPtr *argp1 = *(floo::BMXJanusStreamInfoPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  
  delete argp1;
}

void* _wrap_new_BMXRoomParticipant() {
  void* imresult = 0 ;
  floo::BMXRoomParticipant *result = 0 ;
  
  result = (floo::BMXRoomParticipant *)new floo::BMXRoomParticipant();
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_BMXRoomParticipant_mUserId_set(void* imarg1, long long imarg2) {
  floo::BMXRoomParticipant *arg1 = (floo::BMXRoomParticipant *) 0 ;
  int64_t arg2 ;
  
  arg1 = (floo::BMXRoomParticipant *)imarg1;
  arg2 = (int64_t)imarg2;
  if (arg1) (arg1)->mUserId = arg2;
}

long long _wrap_BMXRoomParticipant_mUserId_get(void* imarg1) {
  floo::BMXRoomParticipant *arg1 = (floo::BMXRoomParticipant *) 0 ;
  long long imresult = 0 ;
  int64_t result;
  
  arg1 = (floo::BMXRoomParticipant *)imarg1;
  result = (int64_t) ((arg1)->mUserId);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_BMXRoomParticipant_mDisplay_set(void* imarg1, NSString* imarg2) {
  floo::BMXRoomParticipant *arg1 = (floo::BMXRoomParticipant *) 0 ;
  std::string *arg2 = 0 ;
  
  arg1 = (floo::BMXRoomParticipant *)imarg1;
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str;
  
  if (arg1) (arg1)->mDisplay = *arg2;
}

NSString* _wrap_BMXRoomParticipant_mDisplay_get(void* imarg1) {
  floo::BMXRoomParticipant *arg1 = (floo::BMXRoomParticipant *) 0 ;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  arg1 = (floo::BMXRoomParticipant *)imarg1;
  result = (std::string *) & ((arg1)->mDisplay);
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXRoomParticipant_mIsPublisher_set(void* imarg1, BOOL imarg2) {
  floo::BMXRoomParticipant *arg1 = (floo::BMXRoomParticipant *) 0 ;
  bool arg2 ;
  
  arg1 = (floo::BMXRoomParticipant *)imarg1;
  arg2 = imarg2? true : false;
  if (arg1) (arg1)->mIsPublisher = arg2;
}

BOOL _wrap_BMXRoomParticipant_mIsPublisher_get(void* imarg1) {
  floo::BMXRoomParticipant *arg1 = (floo::BMXRoomParticipant *) 0 ;
  BOOL imresult = 0 ;
  bool result;
  
  arg1 = (floo::BMXRoomParticipant *)imarg1;
  result = (bool) ((arg1)->mIsPublisher);
  imresult = (result)? YES:NO;
  return imresult;
}

void _wrap_BMXRoomParticipant_mIstalking_set(void* imarg1, BOOL imarg2) {
  floo::BMXRoomParticipant *arg1 = (floo::BMXRoomParticipant *) 0 ;
  bool arg2 ;
  
  arg1 = (floo::BMXRoomParticipant *)imarg1;
  arg2 = imarg2? true : false;
  if (arg1) (arg1)->mIstalking = arg2;
}

BOOL _wrap_BMXRoomParticipant_mIstalking_get(void* imarg1) {
  floo::BMXRoomParticipant *arg1 = (floo::BMXRoomParticipant *) 0 ;
  BOOL imresult = 0 ;
  bool result;
  
  arg1 = (floo::BMXRoomParticipant *)imarg1;
  result = (bool) ((arg1)->mIstalking);
  imresult = (result)? YES:NO;
  return imresult;
}

void _wrap_delete_BMXRoomParticipant(void* imarg1) {
  floo::BMXRoomParticipant *arg1 = (floo::BMXRoomParticipant *) 0 ;
  
  arg1 = (floo::BMXRoomParticipant *)imarg1;
  delete arg1;
}

void* _wrap_new_BMXJanusPublisher(long long imarg1) {
  int64_t arg1 ;
  void* imresult = 0 ;
  floo::BMXJanusPublisher *result = 0 ;
  
  arg1 = (int64_t)imarg1;
  result = (floo::BMXJanusPublisher *)new floo::BMXJanusPublisher(arg1);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_BMXJanusPublisher_mUserId_set(void* imarg1, long long imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXJanusPublisherPtr arg1 ;
  floo::BMXJanusPublisherPtr *argp1 = *(floo::BMXJanusPublisherPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int64_t arg2 ;
  
  arg2 = (int64_t)imarg2;
  if (arg1) (arg1)->mUserId = arg2;
}

long long _wrap_BMXJanusPublisher_mUserId_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXJanusPublisherPtr arg1 ;
  floo::BMXJanusPublisherPtr *argp1 = *(floo::BMXJanusPublisherPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  long long imresult = 0 ;
  int64_t result;
  
  result = (int64_t) ((arg1)->mUserId);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_BMXJanusPublisher_mDisplay_set(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXJanusPublisherPtr arg1 ;
  floo::BMXJanusPublisherPtr *argp1 = *(floo::BMXJanusPublisherPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str;
  
  if (arg1) (arg1)->mDisplay = *arg2;
}

NSString* _wrap_BMXJanusPublisher_mDisplay_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXJanusPublisherPtr arg1 ;
  floo::BMXJanusPublisherPtr *argp1 = *(floo::BMXJanusPublisherPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) & ((arg1)->mDisplay);
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXJanusPublisher_mAudioCodec_set(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXJanusPublisherPtr arg1 ;
  floo::BMXJanusPublisherPtr *argp1 = *(floo::BMXJanusPublisherPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str;
  
  if (arg1) (arg1)->mAudioCodec = *arg2;
}

NSString* _wrap_BMXJanusPublisher_mAudioCodec_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXJanusPublisherPtr arg1 ;
  floo::BMXJanusPublisherPtr *argp1 = *(floo::BMXJanusPublisherPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) & ((arg1)->mAudioCodec);
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXJanusPublisher_mVideoCodec_set(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXJanusPublisherPtr arg1 ;
  floo::BMXJanusPublisherPtr *argp1 = *(floo::BMXJanusPublisherPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str;
  
  if (arg1) (arg1)->mVideoCodec = *arg2;
}

NSString* _wrap_BMXJanusPublisher_mVideoCodec_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXJanusPublisherPtr arg1 ;
  floo::BMXJanusPublisherPtr *argp1 = *(floo::BMXJanusPublisherPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) & ((arg1)->mVideoCodec);
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXJanusPublisher_mSimulcast_set(void* imarg1, BOOL imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXJanusPublisherPtr arg1 ;
  floo::BMXJanusPublisherPtr *argp1 = *(floo::BMXJanusPublisherPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  bool arg2 ;
  
  arg2 = imarg2? true : false;
  if (arg1) (arg1)->mSimulcast = arg2;
}

BOOL _wrap_BMXJanusPublisher_mSimulcast_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXJanusPublisherPtr arg1 ;
  floo::BMXJanusPublisherPtr *argp1 = *(floo::BMXJanusPublisherPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BOOL imresult = 0 ;
  bool result;
  
  result = (bool) ((arg1)->mSimulcast);
  imresult = (result)? YES:NO;
  return imresult;
}

void _wrap_BMXJanusPublisher_mTalking_set(void* imarg1, BOOL imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXJanusPublisherPtr arg1 ;
  floo::BMXJanusPublisherPtr *argp1 = *(floo::BMXJanusPublisherPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  bool arg2 ;
  
  arg2 = imarg2? true : false;
  if (arg1) (arg1)->mTalking = arg2;
}

BOOL _wrap_BMXJanusPublisher_mTalking_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXJanusPublisherPtr arg1 ;
  floo::BMXJanusPublisherPtr *argp1 = *(floo::BMXJanusPublisherPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BOOL imresult = 0 ;
  bool result;
  
  result = (bool) ((arg1)->mTalking);
  imresult = (result)? YES:NO;
  return imresult;
}

void _wrap_BMXJanusPublisher_streams_set(void* imarg1, void* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXJanusPublisherPtr arg1 ;
  floo::BMXJanusPublisherPtr *argp1 = *(floo::BMXJanusPublisherPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  floo::BMXRTCStreams *arg2 = (floo::BMXRTCStreams *) 0 ;
  
  arg2 = (floo::BMXRTCStreams *)imarg2;
  if (arg1) (arg1)->streams = *arg2;
}

void* _wrap_BMXJanusPublisher_streams_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXJanusPublisherPtr arg1 ;
  floo::BMXJanusPublisherPtr *argp1 = *(floo::BMXJanusPublisherPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  void* imresult = 0 ;
  floo::BMXRTCStreams *result = 0 ;
  
  result = (floo::BMXRTCStreams *)& ((arg1)->streams);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_delete_BMXJanusPublisher(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXJanusPublisherPtr arg1 ;
  floo::BMXJanusPublisherPtr *argp1 = *(floo::BMXJanusPublisherPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  
  delete argp1;
}

void* _wrap_new_BMXRoomSDPInfo() {
  void* imresult = 0 ;
  floo::BMXRoomSDPInfo *result = 0 ;
  
  result = (floo::BMXRoomSDPInfo *)new floo::BMXRoomSDPInfo();
  BMXRoomSDPInfo2Void(result)
  imresult = (void*)lresult;
  return imresult;
}

void _wrap_BMXRoomSDPInfo_sdp_set(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRoomSDPInfoPtr arg1 ;
  floo::BMXRoomSDPInfoPtr *argp1 = *(floo::BMXRoomSDPInfoPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str;
  
  if (arg1) (arg1)->sdp = *arg2;
}

NSString* _wrap_BMXRoomSDPInfo_sdp_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRoomSDPInfoPtr arg1 ;
  floo::BMXRoomSDPInfoPtr *argp1 = *(floo::BMXRoomSDPInfoPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) & ((arg1)->sdp);
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXRoomSDPInfo_type_set(void* imarg1, int imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRoomSDPInfoPtr arg1 ;
  floo::BMXRoomSDPInfoPtr *argp1 = *(floo::BMXRoomSDPInfoPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  floo::BMXRoomSDPType arg2 ;
  
  arg2 = (floo::BMXRoomSDPType)imarg2;
  if (arg1) (arg1)->type = arg2;
}

int _wrap_BMXRoomSDPInfo_type_get(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRoomSDPInfoPtr arg1 ;
  floo::BMXRoomSDPInfoPtr *argp1 = *(floo::BMXRoomSDPInfoPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  floo::BMXRoomSDPType result;
  
  result = (floo::BMXRoomSDPType) ((arg1)->type);
  imresult = (int)result;
  return imresult;
}

void _wrap_delete_BMXRoomSDPInfo(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRoomSDPInfoPtr arg1 ;
  floo::BMXRoomSDPInfoPtr *argp1 = *(floo::BMXRoomSDPInfoPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  
  delete argp1;
}

void* _wrap_new_BMXRTCConfig() {
  void* imresult = 0 ;
  floo::BMXRTCConfig *result = 0 ;
  
  result = (floo::BMXRTCConfig *)new floo::BMXRTCConfig();
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_delete_BMXRTCConfig(void* imarg1) {
  floo::BMXRTCConfig *arg1 = (floo::BMXRTCConfig *) 0 ;
  
  arg1 = (floo::BMXRTCConfig *)imarg1;
  delete arg1;
}

NSString* _wrap_BMXRTCConfig_getVersion(void* imarg1) {
  floo::BMXRTCConfig *arg1 = (floo::BMXRTCConfig *) 0 ;
  NSString* imresult = 0 ;
  std::string result;
  
  arg1 = (floo::BMXRTCConfig *)imarg1;
  result = (arg1)->getVersion();
  imresult = [NSString stringWithUTF8String: (&result)->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXRTCConfig_setLogLevel(void* imarg1, int imarg2) {
  floo::BMXRTCConfig *arg1 = (floo::BMXRTCConfig *) 0 ;
  floo::BMXLogLevel arg2 ;
  
  arg1 = (floo::BMXRTCConfig *)imarg1;
  arg2 = (floo::BMXLogLevel)imarg2;
  (arg1)->setLogLevel(arg2);
}

int _wrap_BMXRTCConfig_getLogLevel(void* imarg1) {
  floo::BMXRTCConfig *arg1 = (floo::BMXRTCConfig *) 0 ;
  int imresult = 0 ;
  floo::BMXLogLevel result;
  
  arg1 = (floo::BMXRTCConfig *)imarg1;
  result = (floo::BMXLogLevel)(arg1)->getLogLevel();
  imresult = (int)result;
  return imresult;
}

void _wrap_BMXRTCConfig_setSDKMode(void* imarg1, int imarg2) {
  floo::BMXRTCConfig *arg1 = (floo::BMXRTCConfig *) 0 ;
  floo::BMXSDKMode arg2 ;
  
  arg1 = (floo::BMXRTCConfig *)imarg1;
  arg2 = (floo::BMXSDKMode)imarg2;
  (arg1)->setSDKMode(arg2);
}

int _wrap_BMXRTCConfig_getSDKMode(void* imarg1) {
  floo::BMXRTCConfig *arg1 = (floo::BMXRTCConfig *) 0 ;
  int imresult = 0 ;
  floo::BMXSDKMode result;
  
  arg1 = (floo::BMXRTCConfig *)imarg1;
  result = (floo::BMXSDKMode)(arg1)->getSDKMode();
  imresult = (int)result;
  return imresult;
}

void _wrap_BMXRTCConfig_setAutoPublishMode(void* imarg1, BOOL imarg2) {
  floo::BMXRTCConfig *arg1 = (floo::BMXRTCConfig *) 0 ;
  bool arg2 ;
  
  arg1 = (floo::BMXRTCConfig *)imarg1;
  arg2 = imarg2? true : false;
  (arg1)->setAutoPublishMode(arg2);
}

BOOL _wrap_BMXRTCConfig_getAutoPublishMode(void* imarg1) {
  floo::BMXRTCConfig *arg1 = (floo::BMXRTCConfig *) 0 ;
  BOOL imresult = 0 ;
  bool result;
  
  arg1 = (floo::BMXRTCConfig *)imarg1;
  result = (bool)(arg1)->getAutoPublishMode();
  imresult = (result)? YES:NO;
  return imresult;
}

void _wrap_BMXRTCConfig_setAutoSubscribeMode(void* imarg1, BOOL imarg2) {
  floo::BMXRTCConfig *arg1 = (floo::BMXRTCConfig *) 0 ;
  bool arg2 ;
  
  arg1 = (floo::BMXRTCConfig *)imarg1;
  arg2 = imarg2? true : false;
  (arg1)->setAutoSubscribeMode(arg2);
}

BOOL _wrap_BMXRTCConfig_getAutoSubscribeMode(void* imarg1) {
  floo::BMXRTCConfig *arg1 = (floo::BMXRTCConfig *) 0 ;
  BOOL imresult = 0 ;
  bool result;
  
  arg1 = (floo::BMXRTCConfig *)imarg1;
  result = (bool)(arg1)->getAutoSubscribeMode();
  imresult = (result)? YES:NO;
  return imresult;
}

void _wrap_BMXRTCConfig_setAudioOnlyMode(void* imarg1, BOOL imarg2) {
  floo::BMXRTCConfig *arg1 = (floo::BMXRTCConfig *) 0 ;
  bool arg2 ;
  
  arg1 = (floo::BMXRTCConfig *)imarg1;
  arg2 = imarg2? true : false;
  (arg1)->setAudioOnlyMode(arg2);
}

BOOL _wrap_BMXRTCConfig_getAudioOnlyMode(void* imarg1) {
  floo::BMXRTCConfig *arg1 = (floo::BMXRTCConfig *) 0 ;
  BOOL imresult = 0 ;
  bool result;
  
  arg1 = (floo::BMXRTCConfig *)imarg1;
  result = (bool)(arg1)->getAudioOnlyMode();
  imresult = (result)? YES:NO;
  return imresult;
}

void _wrap_BMXRTCConfig_setEnableLocalAudio(void* imarg1, BOOL imarg2) {
  floo::BMXRTCConfig *arg1 = (floo::BMXRTCConfig *) 0 ;
  bool arg2 ;
  
  arg1 = (floo::BMXRTCConfig *)imarg1;
  arg2 = imarg2? true : false;
  (arg1)->setEnableLocalAudio(arg2);
}

BOOL _wrap_BMXRTCConfig_getEnableLocalAudio(void* imarg1) {
  floo::BMXRTCConfig *arg1 = (floo::BMXRTCConfig *) 0 ;
  BOOL imresult = 0 ;
  bool result;
  
  arg1 = (floo::BMXRTCConfig *)imarg1;
  result = (bool)(arg1)->getEnableLocalAudio();
  imresult = (result)? YES:NO;
  return imresult;
}

void _wrap_BMXRTCConfig_setEnableLocalVideo(void* imarg1, BOOL imarg2) {
  floo::BMXRTCConfig *arg1 = (floo::BMXRTCConfig *) 0 ;
  bool arg2 ;
  
  arg1 = (floo::BMXRTCConfig *)imarg1;
  arg2 = imarg2? true : false;
  (arg1)->setEnableLocalVideo(arg2);
}

BOOL _wrap_BMXRTCConfig_getEnableLocalVideo(void* imarg1) {
  floo::BMXRTCConfig *arg1 = (floo::BMXRTCConfig *) 0 ;
  BOOL imresult = 0 ;
  bool result;
  
  arg1 = (floo::BMXRTCConfig *)imarg1;
  result = (bool)(arg1)->getEnableLocalVideo();
  imresult = (result)? YES:NO;
  return imresult;
}

void _wrap_delete_BMXRTCEngine(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCEnginePtr arg1 ;
  floo::BMXRTCEnginePtr *argp1 = *(floo::BMXRTCEnginePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  
  delete argp1;
}

void _wrap_BMXRTCEngine_destroy(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCEnginePtr arg1 ;
  floo::BMXRTCEnginePtr *argp1 = *(floo::BMXRTCEnginePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  
  (arg1)->destroy();
}

void _wrap_BMXRTCEngine_addRTCEngineListener(void* imarg1, void* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCEnginePtr arg1 ;
  floo::BMXRTCEnginePtr *argp1 = *(floo::BMXRTCEnginePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BMXRTCEngineListener *arg2 = (BMXRTCEngineListener *) 0 ;
  
  arg2 = (BMXRTCEngineListener *)imarg2;
  (arg1)->addRTCEngineListener(arg2);
}

void _wrap_BMXRTCEngine_removeRTCEngineListener(void* imarg1, void* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCEnginePtr arg1 ;
  floo::BMXRTCEnginePtr *argp1 = *(floo::BMXRTCEnginePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BMXRTCEngineListener *arg2 = (BMXRTCEngineListener *) 0 ;
  
  arg2 = (BMXRTCEngineListener *)imarg2;
  (arg1)->removeRTCEngineListener(arg2);
}

void* _wrap_BMXRTCEngine_getRTCConfig(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCEnginePtr arg1 ;
  floo::BMXRTCEnginePtr *argp1 = *(floo::BMXRTCEnginePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  void* imresult = 0 ;
  floo::BMXRTCConfigPtr *temp ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCConfig > > result;
  
  result = (arg1)->getRTCConfig();
  
  temp = new floo::BMXRTCConfigPtr((const floo::BMXRTCConfigPtr &)result);
  imresult = *(typeof(imresult)*)&temp;
  
  return imresult;
}

int _wrap_BMXRTCEngine_setRoomType(void* imarg1, int imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCEnginePtr arg1 ;
  floo::BMXRTCEnginePtr *argp1 = *(floo::BMXRTCEnginePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  floo::BMXRoomType arg2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg2 = (floo::BMXRoomType)imarg2;
  result = (floo::BMXErrorCode)(arg1)->setRoomType(arg2);
  imresult = (int)result;
  return imresult;
}

int _wrap_BMXRTCEngine_setStreamRole(void* imarg1, int imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCEnginePtr arg1 ;
  floo::BMXRTCEnginePtr *argp1 = *(floo::BMXRTCEnginePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  floo::BMXStreamRole arg2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg2 = (floo::BMXStreamRole)imarg2;
  result = (floo::BMXErrorCode)(arg1)->setStreamRole(arg2);
  imresult = (int)result;
  return imresult;
}

int _wrap_BMXRTCEngine_setVideoCodec(void* imarg1, int imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCEnginePtr arg1 ;
  floo::BMXRTCEnginePtr *argp1 = *(floo::BMXRTCEnginePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  floo::BMXVideoCodec arg2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg2 = (floo::BMXVideoCodec)imarg2;
  result = (floo::BMXErrorCode)(arg1)->setVideoCodec(arg2);
  imresult = (int)result;
  return imresult;
}

int _wrap_BMXRTCEngine_setVideoProfile(void* imarg1, void* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCEnginePtr arg1 ;
  floo::BMXRTCEnginePtr *argp1 = *(floo::BMXRTCEnginePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  SwigValueWrapper< std::shared_ptr< floo::BMXVideoConfig > > arg2 ;
  floo::BMXVideoConfigPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  
  argp2 = (floo::BMXVideoConfigPtr *)imarg2;
  arg2 = *argp2;
  
  result = (floo::BMXErrorCode)(arg1)->setVideoProfile(arg2);
  imresult = (int)result;
  return imresult;
}

int _wrap_BMXRTCEngine_setAudioProfile(void* imarg1, int imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCEnginePtr arg1 ;
  floo::BMXRTCEnginePtr *argp1 = *(floo::BMXRTCEnginePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  floo::BMXAudioProfile arg2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg2 = (floo::BMXAudioProfile)imarg2;
  result = (floo::BMXErrorCode)(arg1)->setAudioProfile(arg2);
  imresult = (int)result;
  return imresult;
}

int _wrap_BMXRTCEngine_joinRoom(void* imarg1, void* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCEnginePtr arg1 ;
  floo::BMXRTCEnginePtr *argp1 = *(floo::BMXRTCEnginePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  SwigValueWrapper< std::shared_ptr< floo::BMXRoomAuth > > arg2 ;
  floo::BMXRoomAuthPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  
  argp2 = (floo::BMXRoomAuthPtr *)imarg2;
  arg2 = *argp2;
  
  result = (floo::BMXErrorCode)(arg1)->joinRoom(arg2);
  imresult = (int)result;
  return imresult;
}

int _wrap_BMXRTCEngine_leaveRoom(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCEnginePtr arg1 ;
  floo::BMXRTCEnginePtr *argp1 = *(floo::BMXRTCEnginePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  result = (floo::BMXErrorCode)(arg1)->leaveRoom();
  imresult = (int)result;
  return imresult;
}

int _wrap_BMXRTCEngine_publish(void* imarg1, int imarg2, BOOL imarg3, BOOL imarg4) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCEnginePtr arg1 ;
  floo::BMXRTCEnginePtr *argp1 = *(floo::BMXRTCEnginePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  floo::BMXVideoMediaType arg2 ;
  bool arg3 ;
  bool arg4 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg2 = (floo::BMXVideoMediaType)imarg2;
  arg3 = imarg3? true : false;
  arg4 = imarg4? true : false;
  result = (floo::BMXErrorCode)(arg1)->publish(arg2,arg3,arg4);
  imresult = (int)result;
  return imresult;
}

int _wrap_BMXRTCEngine_unPublish(void* imarg1, int imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCEnginePtr arg1 ;
  floo::BMXRTCEnginePtr *argp1 = *(floo::BMXRTCEnginePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  floo::BMXVideoMediaType arg2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg2 = (floo::BMXVideoMediaType)imarg2;
  result = (floo::BMXErrorCode)(arg1)->unPublish(arg2);
  imresult = (int)result;
  return imresult;
}

int _wrap_BMXRTCEngine_subscribe(void* imarg1, void* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCEnginePtr arg1 ;
  floo::BMXRTCEnginePtr *argp1 = *(floo::BMXRTCEnginePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  SwigValueWrapper< std::shared_ptr< floo::BMXStream > > arg2 ;
  floo::BMXStreamPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  
  argp2 = (floo::BMXStreamPtr *)imarg2;
  arg2 = *argp2;
  
  result = (floo::BMXErrorCode)(arg1)->subscribe(arg2);
  imresult = (int)result;
  return imresult;
}

int _wrap_BMXRTCEngine_unSubscribe(void* imarg1, void* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCEnginePtr arg1 ;
  floo::BMXRTCEnginePtr *argp1 = *(floo::BMXRTCEnginePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  SwigValueWrapper< std::shared_ptr< floo::BMXStream > > arg2 ;
  floo::BMXStreamPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  
  argp2 = (floo::BMXStreamPtr *)imarg2;
  arg2 = *argp2;
  
  result = (floo::BMXErrorCode)(arg1)->unSubscribe(arg2);
  imresult = (int)result;
  return imresult;
}

int _wrap_BMXRTCEngine_startPreview(void* imarg1, void* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCEnginePtr arg1 ;
  floo::BMXRTCEnginePtr *argp1 = *(floo::BMXRTCEnginePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  SwigValueWrapper< std::shared_ptr< floo::BMXVideoCanvas > > arg2 ;
  floo::BMXVideoCanvasPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  
  argp2 = (floo::BMXVideoCanvasPtr *)imarg2;
  arg2 = *argp2;
  
  result = (floo::BMXErrorCode)(arg1)->startPreview(arg2);
  imresult = (int)result;
  return imresult;
}

int _wrap_BMXRTCEngine_stopPreview(void* imarg1, void* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCEnginePtr arg1 ;
  floo::BMXRTCEnginePtr *argp1 = *(floo::BMXRTCEnginePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  SwigValueWrapper< std::shared_ptr< floo::BMXVideoCanvas > > arg2 ;
  floo::BMXVideoCanvasPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  
  argp2 = (floo::BMXVideoCanvasPtr *)imarg2;
  arg2 = *argp2;
  
  result = (floo::BMXErrorCode)(arg1)->stopPreview(arg2);
  imresult = (int)result;
  return imresult;
}

int _wrap_BMXRTCEngine_startRemoteView(void* imarg1, void* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCEnginePtr arg1 ;
  floo::BMXRTCEnginePtr *argp1 = *(floo::BMXRTCEnginePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  SwigValueWrapper< std::shared_ptr< floo::BMXVideoCanvas > > arg2 ;
  floo::BMXVideoCanvasPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  
  argp2 = (floo::BMXVideoCanvasPtr *)imarg2;
  arg2 = *argp2;
  
  result = (floo::BMXErrorCode)(arg1)->startRemoteView(arg2);
  imresult = (int)result;
  return imresult;
}

int _wrap_BMXRTCEngine_stopRemoteView(void* imarg1, void* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCEnginePtr arg1 ;
  floo::BMXRTCEnginePtr *argp1 = *(floo::BMXRTCEnginePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  SwigValueWrapper< std::shared_ptr< floo::BMXVideoCanvas > > arg2 ;
  floo::BMXVideoCanvasPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  
  argp2 = (floo::BMXVideoCanvasPtr *)imarg2;
  arg2 = *argp2;
  
  result = (floo::BMXErrorCode)(arg1)->stopRemoteView(arg2);
  imresult = (int)result;
  return imresult;
}

int _wrap_BMXRTCEngine_muteLocalAudio(void* imarg1, BOOL imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCEnginePtr arg1 ;
  floo::BMXRTCEnginePtr *argp1 = *(floo::BMXRTCEnginePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  bool arg2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg2 = imarg2? true : false;
  result = (floo::BMXErrorCode)(arg1)->muteLocalAudio(arg2);
  imresult = (int)result;
  return imresult;
}

int _wrap_BMXRTCEngine_muteLocalVideo(void* imarg1, int imarg2, BOOL imarg3) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCEnginePtr arg1 ;
  floo::BMXRTCEnginePtr *argp1 = *(floo::BMXRTCEnginePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  floo::BMXVideoMediaType arg2 ;
  bool arg3 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg2 = (floo::BMXVideoMediaType)imarg2;
  arg3 = imarg3? true : false;
  result = (floo::BMXErrorCode)(arg1)->muteLocalVideo(arg2,arg3);
  imresult = (int)result;
  return imresult;
}

int _wrap_BMXRTCEngine_muteRemoteAudio(void* imarg1, void* imarg2, BOOL imarg3) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCEnginePtr arg1 ;
  floo::BMXRTCEnginePtr *argp1 = *(floo::BMXRTCEnginePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  SwigValueWrapper< std::shared_ptr< floo::BMXStream > > arg2 ;
  bool arg3 ;
  floo::BMXStreamPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  
  argp2 = (floo::BMXStreamPtr *)imarg2;
  arg2 = *argp2;
  
  arg3 = imarg3? true : false;
  result = (floo::BMXErrorCode)(arg1)->muteRemoteAudio(arg2,arg3);
  imresult = (int)result;
  return imresult;
}

int _wrap_BMXRTCEngine_muteRemoteVideo(void* imarg1, void* imarg2, BOOL imarg3) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCEnginePtr arg1 ;
  floo::BMXRTCEnginePtr *argp1 = *(floo::BMXRTCEnginePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  SwigValueWrapper< std::shared_ptr< floo::BMXStream > > arg2 ;
  bool arg3 ;
  floo::BMXStreamPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  
  argp2 = (floo::BMXStreamPtr *)imarg2;
  arg2 = *argp2;
  
  arg3 = imarg3? true : false;
  result = (floo::BMXErrorCode)(arg1)->muteRemoteVideo(arg2,arg3);
  imresult = (int)result;
  return imresult;
}

int _wrap_BMXRTCEngine_switchCamera(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCEnginePtr arg1 ;
  floo::BMXRTCEnginePtr *argp1 = *(floo::BMXRTCEnginePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  result = (floo::BMXErrorCode)(arg1)->switchCamera();
  imresult = (int)result;
  return imresult;
}

void _wrap_delete_BMXRTCEngineListener(void* imarg1) {
  floo::BMXRTCEngineListener *arg1 = (floo::BMXRTCEngineListener *) 0 ;
  
  arg1 = (floo::BMXRTCEngineListener *)imarg1;
  delete arg1;
}

void _wrap_BMXRTCEngineListener_onJoinRoom(void* imarg1, NSString* imarg2, long long imarg3, int imarg4) {
  floo::BMXRTCEngineListener *arg1 = (floo::BMXRTCEngineListener *) 0 ;
  std::string *arg2 = 0 ;
  int64_t arg3 ;
  floo::BMXErrorCode arg4 ;
  
  arg1 = (floo::BMXRTCEngineListener *)imarg1;
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str;
  
  arg3 = (int64_t)imarg3;
  arg4 = (floo::BMXErrorCode)imarg4;
  (arg1)->onJoinRoom((std::string const &)*arg2,arg3,arg4);
}

void _wrap_BMXRTCEngineListener_onLeaveRoom(void* imarg1, NSString* imarg2, long long imarg3, int imarg4, NSString* imarg5) {
  floo::BMXRTCEngineListener *arg1 = (floo::BMXRTCEngineListener *) 0 ;
  std::string *arg2 = 0 ;
  int64_t arg3 ;
  floo::BMXErrorCode arg4 ;
  std::string *arg5 = 0 ;
  
  arg1 = (floo::BMXRTCEngineListener *)imarg1;
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str;
  
  arg3 = (int64_t)imarg3;
  arg4 = (floo::BMXErrorCode)imarg4;
  if(!imarg5) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg5_str(getStdString(imarg5));
  arg5 = &arg5_str;
  
  (arg1)->onLeaveRoom((std::string const &)*arg2,arg3,arg4,(std::string const &)*arg5);
}

void _wrap_BMXRTCEngineListener_onRejoining(void* imarg1, long long imarg2, int imarg3) {
  floo::BMXRTCEngineListener *arg1 = (floo::BMXRTCEngineListener *) 0 ;
  int64_t arg2 ;
  floo::BMXErrorCode arg3 ;
  
  arg1 = (floo::BMXRTCEngineListener *)imarg1;
  arg2 = (int64_t)imarg2;
  arg3 = (floo::BMXErrorCode)imarg3;
  (arg1)->onRejoining(arg2,arg3);
}

void _wrap_BMXRTCEngineListener_onReJoinRoom(void* imarg1, NSString* imarg2, long long imarg3, int imarg4) {
  floo::BMXRTCEngineListener *arg1 = (floo::BMXRTCEngineListener *) 0 ;
  std::string *arg2 = 0 ;
  int64_t arg3 ;
  floo::BMXErrorCode arg4 ;
  
  arg1 = (floo::BMXRTCEngineListener *)imarg1;
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str;
  
  arg3 = (int64_t)imarg3;
  arg4 = (floo::BMXErrorCode)imarg4;
  (arg1)->onReJoinRoom((std::string const &)*arg2,arg3,arg4);
}

void _wrap_BMXRTCEngineListener_onMemberJoined(void* imarg1, long long imarg2, long long imarg3) {
  floo::BMXRTCEngineListener *arg1 = (floo::BMXRTCEngineListener *) 0 ;
  int64_t arg2 ;
  int64_t arg3 ;
  
  arg1 = (floo::BMXRTCEngineListener *)imarg1;
  arg2 = (int64_t)imarg2;
  arg3 = (int64_t)imarg3;
  (arg1)->onMemberJoined(arg2,arg3);
}

void _wrap_BMXRTCEngineListener_onMemberExited(void* imarg1, long long imarg2, long long imarg3, NSString* imarg4) {
  floo::BMXRTCEngineListener *arg1 = (floo::BMXRTCEngineListener *) 0 ;
  int64_t arg2 ;
  int64_t arg3 ;
  std::string *arg4 = 0 ;
  
  arg1 = (floo::BMXRTCEngineListener *)imarg1;
  arg2 = (int64_t)imarg2;
  arg3 = (int64_t)imarg3;
  if(!imarg4) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg4_str(getStdString(imarg4));
  arg4 = &arg4_str;
  
  (arg1)->onMemberExited(arg2,arg3,(std::string const &)*arg4);
}

void _wrap_BMXRTCEngineListener_onLocalPublish(void* imarg1, void* imarg2, NSString* imarg3, int imarg4) {
  floo::BMXRTCEngineListener *arg1 = (floo::BMXRTCEngineListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXStream > > arg2 ;
  std::string *arg3 = 0 ;
  floo::BMXErrorCode arg4 ;
  floo::BMXStreamPtr *argp2 ;
  
  arg1 = (floo::BMXRTCEngineListener *)imarg1;
  
  argp2 = (floo::BMXStreamPtr *)imarg2;
  arg2 = *argp2;
  
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str;
  
  arg4 = (floo::BMXErrorCode)imarg4;
  (arg1)->onLocalPublish(arg2,(std::string const &)*arg3,arg4);
}

void _wrap_BMXRTCEngineListener_onLocalUnPublish(void* imarg1, void* imarg2, NSString* imarg3, int imarg4) {
  floo::BMXRTCEngineListener *arg1 = (floo::BMXRTCEngineListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXStream > > arg2 ;
  std::string *arg3 = 0 ;
  floo::BMXErrorCode arg4 ;
  floo::BMXStreamPtr *argp2 ;
  
  arg1 = (floo::BMXRTCEngineListener *)imarg1;
  
  argp2 = (floo::BMXStreamPtr *)imarg2;
  arg2 = *argp2;
  
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str;
  
  arg4 = (floo::BMXErrorCode)imarg4;
  (arg1)->onLocalUnPublish(arg2,(std::string const &)*arg3,arg4);
}

void _wrap_BMXRTCEngineListener_onRemotePublish(void* imarg1, void* imarg2, NSString* imarg3, int imarg4) {
  floo::BMXRTCEngineListener *arg1 = (floo::BMXRTCEngineListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXStream > > arg2 ;
  std::string *arg3 = 0 ;
  floo::BMXErrorCode arg4 ;
  floo::BMXStreamPtr *argp2 ;
  
  arg1 = (floo::BMXRTCEngineListener *)imarg1;
  
  argp2 = (floo::BMXStreamPtr *)imarg2;
  arg2 = *argp2;
  
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str;
  
  arg4 = (floo::BMXErrorCode)imarg4;
  (arg1)->onRemotePublish(arg2,(std::string const &)*arg3,arg4);
}

void _wrap_BMXRTCEngineListener_onRemoteUnPublish(void* imarg1, void* imarg2, NSString* imarg3, int imarg4) {
  floo::BMXRTCEngineListener *arg1 = (floo::BMXRTCEngineListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXStream > > arg2 ;
  std::string *arg3 = 0 ;
  floo::BMXErrorCode arg4 ;
  floo::BMXStreamPtr *argp2 ;
  
  arg1 = (floo::BMXRTCEngineListener *)imarg1;
  
  argp2 = (floo::BMXStreamPtr *)imarg2;
  arg2 = *argp2;
  
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str;
  
  arg4 = (floo::BMXErrorCode)imarg4;
  (arg1)->onRemoteUnPublish(arg2,(std::string const &)*arg3,arg4);
}

void _wrap_BMXRTCEngineListener_onSubscribe(void* imarg1, void* imarg2, NSString* imarg3, int imarg4) {
  floo::BMXRTCEngineListener *arg1 = (floo::BMXRTCEngineListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXStream > > arg2 ;
  std::string *arg3 = 0 ;
  floo::BMXErrorCode arg4 ;
  floo::BMXStreamPtr *argp2 ;
  
  arg1 = (floo::BMXRTCEngineListener *)imarg1;
  
  argp2 = (floo::BMXStreamPtr *)imarg2;
  arg2 = *argp2;
  
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str;
  
  arg4 = (floo::BMXErrorCode)imarg4;
  (arg1)->onSubscribe(arg2,(std::string const &)*arg3,arg4);
}

void _wrap_BMXRTCEngineListener_onUnSubscribe(void* imarg1, void* imarg2, NSString* imarg3, int imarg4) {
  floo::BMXRTCEngineListener *arg1 = (floo::BMXRTCEngineListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXStream > > arg2 ;
  std::string *arg3 = 0 ;
  floo::BMXErrorCode arg4 ;
  floo::BMXStreamPtr *argp2 ;
  
  arg1 = (floo::BMXRTCEngineListener *)imarg1;
  
  argp2 = (floo::BMXStreamPtr *)imarg2;
  arg2 = *argp2;
  
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str;
  
  arg4 = (floo::BMXErrorCode)imarg4;
  (arg1)->onUnSubscribe(arg2,(std::string const &)*arg3,arg4);
}

void _wrap_BMXRTCEngineListener_onRemoteTrackNotify(void* imarg1, void* imarg2, int imarg3, NSString* imarg4, int imarg5) {
  floo::BMXRTCEngineListener *arg1 = (floo::BMXRTCEngineListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXStream > > arg2 ;
  floo::BMXTrackType arg3 ;
  std::string *arg4 = 0 ;
  floo::BMXErrorCode arg5 ;
  floo::BMXStreamPtr *argp2 ;
  
  arg1 = (floo::BMXRTCEngineListener *)imarg1;
  
  argp2 = (floo::BMXStreamPtr *)imarg2;
  arg2 = *argp2;
  
  arg3 = (floo::BMXTrackType)imarg3;
  if(!imarg4) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg4_str(getStdString(imarg4));
  arg4 = &arg4_str;
  
  arg5 = (floo::BMXErrorCode)imarg5;
  (arg1)->onRemoteTrackNotify(arg2,arg3,(std::string const &)*arg4,arg5);
}

void _wrap_BMXRTCEngineListener_onLocalStreamMuteRsp(void* imarg1, void* imarg2, int imarg3, BOOL imarg4, NSString* imarg5, int imarg6) {
  floo::BMXRTCEngineListener *arg1 = (floo::BMXRTCEngineListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXStream > > arg2 ;
  floo::BMXTrackType arg3 ;
  bool arg4 ;
  std::string *arg5 = 0 ;
  floo::BMXErrorCode arg6 ;
  floo::BMXStreamPtr *argp2 ;
  
  arg1 = (floo::BMXRTCEngineListener *)imarg1;
  
  argp2 = (floo::BMXStreamPtr *)imarg2;
  arg2 = *argp2;
  
  arg3 = (floo::BMXTrackType)imarg3;
  arg4 = imarg4? true : false;
  if(!imarg5) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg5_str(getStdString(imarg5));
  arg5 = &arg5_str;
  
  arg6 = (floo::BMXErrorCode)imarg6;
  (arg1)->onLocalStreamMuteRsp(arg2,arg3,arg4,(std::string const &)*arg5,arg6);
}

void _wrap_BMXRTCEngineListener_onRemoteStreamMuteRsp(void* imarg1, void* imarg2, int imarg3, BOOL imarg4, NSString* imarg5, int imarg6) {
  floo::BMXRTCEngineListener *arg1 = (floo::BMXRTCEngineListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXStream > > arg2 ;
  floo::BMXTrackType arg3 ;
  bool arg4 ;
  std::string *arg5 = 0 ;
  floo::BMXErrorCode arg6 ;
  floo::BMXStreamPtr *argp2 ;
  
  arg1 = (floo::BMXRTCEngineListener *)imarg1;
  
  argp2 = (floo::BMXStreamPtr *)imarg2;
  arg2 = *argp2;
  
  arg3 = (floo::BMXTrackType)imarg3;
  arg4 = imarg4? true : false;
  if(!imarg5) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg5_str(getStdString(imarg5));
  arg5 = &arg5_str;
  
  arg6 = (floo::BMXErrorCode)imarg6;
  (arg1)->onRemoteStreamMuteRsp(arg2,arg3,arg4,(std::string const &)*arg5,arg6);
}

void _wrap_BMXRTCEngineListener_onSendRTCStats(void* imarg1, void* imarg2, NSString* imarg3, int imarg4) {
  floo::BMXRTCEngineListener *arg1 = (floo::BMXRTCEngineListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXStreamStats > > arg2 ;
  std::string *arg3 = 0 ;
  floo::BMXErrorCode arg4 ;
  floo::BMXStreamStatsPtr *argp2 ;
  
  arg1 = (floo::BMXRTCEngineListener *)imarg1;
  
  argp2 = (floo::BMXStreamStatsPtr *)imarg2;
  arg2 = *argp2;
  
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str;
  
  arg4 = (floo::BMXErrorCode)imarg4;
  (arg1)->onSendRTCStats(arg2,(std::string const &)*arg3,arg4);
}

void _wrap_BMXRTCEngineListener_onRemoteRTCStats(void* imarg1, void* imarg2, NSString* imarg3, int imarg4) {
  floo::BMXRTCEngineListener *arg1 = (floo::BMXRTCEngineListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXStreamStats > > arg2 ;
  std::string *arg3 = 0 ;
  floo::BMXErrorCode arg4 ;
  floo::BMXStreamStatsPtr *argp2 ;
  
  arg1 = (floo::BMXRTCEngineListener *)imarg1;
  
  argp2 = (floo::BMXStreamStatsPtr *)imarg2;
  arg2 = *argp2;
  
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str;
  
  arg4 = (floo::BMXErrorCode)imarg4;
  (arg1)->onRemoteRTCStats(arg2,(std::string const &)*arg3,arg4);
}

void _wrap_BMXRTCEngineListener_onLocalAudioLevel(void* imarg1, int imarg2) {
  floo::BMXRTCEngineListener *arg1 = (floo::BMXRTCEngineListener *) 0 ;
  int arg2 ;
  
  arg1 = (floo::BMXRTCEngineListener *)imarg1;
  arg2 = (int)imarg2;
  (arg1)->onLocalAudioLevel(arg2);
}

void _wrap_BMXRTCEngineListener_onRemoteAudioLevel(void* imarg1, long long imarg2, int imarg3) {
  floo::BMXRTCEngineListener *arg1 = (floo::BMXRTCEngineListener *) 0 ;
  int64_t arg2 ;
  int arg3 ;
  
  arg1 = (floo::BMXRTCEngineListener *)imarg1;
  arg2 = (int64_t)imarg2;
  arg3 = (int)imarg3;
  (arg1)->onRemoteAudioLevel(arg2,arg3);
}

void _wrap_BMXRTCEngineListener_onKickoff(void* imarg1, NSString* imarg2, int imarg3) {
  floo::BMXRTCEngineListener *arg1 = (floo::BMXRTCEngineListener *) 0 ;
  std::string *arg2 = 0 ;
  floo::BMXErrorCode arg3 ;
  
  arg1 = (floo::BMXRTCEngineListener *)imarg1;
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str;
  
  arg3 = (floo::BMXErrorCode)imarg3;
  (arg1)->onKickoff((std::string const &)*arg2,arg3);
}

void _wrap_BMXRTCEngineListener_onWarning(void* imarg1, NSString* imarg2, int imarg3) {
  floo::BMXRTCEngineListener *arg1 = (floo::BMXRTCEngineListener *) 0 ;
  std::string *arg2 = 0 ;
  floo::BMXErrorCode arg3 ;
  
  arg1 = (floo::BMXRTCEngineListener *)imarg1;
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str;
  
  arg3 = (floo::BMXErrorCode)imarg3;
  (arg1)->onWarning((std::string const &)*arg2,arg3);
}

void _wrap_BMXRTCEngineListener_onError(void* imarg1, NSString* imarg2, int imarg3) {
  floo::BMXRTCEngineListener *arg1 = (floo::BMXRTCEngineListener *) 0 ;
  std::string *arg2 = 0 ;
  floo::BMXErrorCode arg3 ;
  
  arg1 = (floo::BMXRTCEngineListener *)imarg1;
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str;
  
  arg3 = (floo::BMXErrorCode)imarg3;
  (arg1)->onError((std::string const &)*arg2,arg3);
}

void _wrap_BMXRTCEngineListener_onNetworkQuality(void* imarg1, void* imarg2, NSString* imarg3, int imarg4) {
  floo::BMXRTCEngineListener *arg1 = (floo::BMXRTCEngineListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXStream > > arg2 ;
  std::string *arg3 = 0 ;
  floo::BMXErrorCode arg4 ;
  floo::BMXStreamPtr *argp2 ;
  
  arg1 = (floo::BMXRTCEngineListener *)imarg1;
  
  argp2 = (floo::BMXStreamPtr *)imarg2;
  arg2 = *argp2;
  
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str;
  
  arg4 = (floo::BMXErrorCode)imarg4;
  (arg1)->onNetworkQuality(arg2,(std::string const &)*arg3,arg4);
}

void* _wrap_new_BMXRTCEngineListener() {
  void* imresult = 0 ;
  floo::BMXRTCEngineListener *result = 0 ;
  
  result = (floo::BMXRTCEngineListener *)new floo::BMXRTCEngineListener();
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_delete_BMXRTCRoom(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCRoomPtr arg1 ;
  floo::BMXRTCRoomPtr *argp1 = *(floo::BMXRTCRoomPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  
  delete argp1;
}

long long _wrap_BMXRTCRoom_roomId(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCRoomPtr arg1 ;
  floo::BMXRTCRoomPtr *argp1 = *(floo::BMXRTCRoomPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  long long imresult = 0 ;
  int64_t result;
  
  result = (int64_t)(arg1)->roomId();
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_BMXRTCRoom_setRoomSecret(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCRoomPtr arg1 ;
  floo::BMXRTCRoomPtr *argp1 = *(floo::BMXRTCRoomPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str;
  
  (arg1)->setRoomSecret((std::string const &)*arg2);
}

NSString* _wrap_BMXRTCRoom_roomSecret(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCRoomPtr arg1 ;
  floo::BMXRTCRoomPtr *argp1 = *(floo::BMXRTCRoomPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string result;
  
  result = (arg1)->roomSecret();
  imresult = [NSString stringWithUTF8String: (&result)->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXRTCRoom_setPin(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCRoomPtr arg1 ;
  floo::BMXRTCRoomPtr *argp1 = *(floo::BMXRTCRoomPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str;
  
  (arg1)->setPin((std::string const &)*arg2);
}

NSString* _wrap_BMXRTCRoom_pin(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCRoomPtr arg1 ;
  floo::BMXRTCRoomPtr *argp1 = *(floo::BMXRTCRoomPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string result;
  
  result = (arg1)->pin();
  imresult = [NSString stringWithUTF8String: (&result)->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

BOOL _wrap_BMXRTCRoom_permanent(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCRoomPtr arg1 ;
  floo::BMXRTCRoomPtr *argp1 = *(floo::BMXRTCRoomPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BOOL imresult = 0 ;
  bool result;
  
  result = (bool)(arg1)->permanent();
  imresult = (result)? YES:NO;
  return imresult;
}

BOOL _wrap_BMXRTCRoom_isPrivate(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCRoomPtr arg1 ;
  floo::BMXRTCRoomPtr *argp1 = *(floo::BMXRTCRoomPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BOOL imresult = 0 ;
  bool result;
  
  result = (bool)(arg1)->isPrivate();
  imresult = (result)? YES:NO;
  return imresult;
}

NSString* _wrap_BMXRTCRoom_roomDescription(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCRoomPtr arg1 ;
  floo::BMXRTCRoomPtr *argp1 = *(floo::BMXRTCRoomPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string result;
  
  result = (arg1)->roomDescription();
  imresult = [NSString stringWithUTF8String: (&result)->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

long long _wrap_BMXRTCRoom_roomPrivateId(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCRoomPtr arg1 ;
  floo::BMXRTCRoomPtr *argp1 = *(floo::BMXRTCRoomPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  long long imresult = 0 ;
  int64_t result;
  
  result = (int64_t)(arg1)->roomPrivateId();
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_delete_BMXRTCService(void* imarg1) {
  floo::BMXRTCService *arg1 = (floo::BMXRTCService *) 0 ;
  
  arg1 = (floo::BMXRTCService *)imarg1;
  delete arg1;
}

void _wrap_BMXRTCService_setupRTCEngine(void* imarg1, void* imarg2) {
  floo::BMXRTCService *arg1 = (floo::BMXRTCService *) 0 ;
  floo::BMXRTCEngine *arg2 = (floo::BMXRTCEngine *) 0 ;
  
  arg1 = (floo::BMXRTCService *)imarg1;
  arg2 = (floo::BMXRTCEngine *)imarg2;
  (arg1)->setupRTCEngine(arg2);
}

void* _wrap_BMXRTCService_getRTCEngine(void* imarg1) {
  floo::BMXRTCService *arg1 = (floo::BMXRTCService *) 0 ;
  void* imresult = 0 ;
  floo::BMXRTCEngine *result = 0 ;
  
  arg1 = (floo::BMXRTCService *)imarg1;
  result = (floo::BMXRTCEngine *)(arg1)->getRTCEngine();
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void* _wrap_BMXRTCService_getBMXRTCSignalService(void* imarg1) {
  floo::BMXRTCService *arg1 = (floo::BMXRTCService *) 0 ;
  void* imresult = 0 ;
  BMXRTCSignalService *result = 0 ;
  
  arg1 = (floo::BMXRTCService *)imarg1;
  result = (BMXRTCSignalService *) &(arg1)->getBMXRTCSignalService();
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_BMXRTCService_sendRTCMessage(void* imarg1, void* imarg2) {
  floo::BMXRTCService *arg1 = (floo::BMXRTCService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXMessage > > arg2 ;
  floo::BMXMessagePtr *argp2 ;
  
  arg1 = (floo::BMXRTCService *)imarg1;
  
  argp2 = (floo::BMXMessagePtr *)imarg2;
  arg2 = *argp2;
  
  (arg1)->sendRTCMessage(arg2);
}

void _wrap_BMXRTCService_addRTCServiceListener(void* imarg1, void* imarg2) {
  floo::BMXRTCService *arg1 = (floo::BMXRTCService *) 0 ;
  floo::BMXRTCServiceListener *arg2 = (floo::BMXRTCServiceListener *) 0 ;
  
  arg1 = (floo::BMXRTCService *)imarg1;
  arg2 = (floo::BMXRTCServiceListener *)imarg2;
  (arg1)->addRTCServiceListener(arg2);
}

void _wrap_BMXRTCService_removeRTCServiceListener(void* imarg1, void* imarg2) {
  floo::BMXRTCService *arg1 = (floo::BMXRTCService *) 0 ;
  floo::BMXRTCServiceListener *arg2 = (floo::BMXRTCServiceListener *) 0 ;
  
  arg1 = (floo::BMXRTCService *)imarg1;
  arg2 = (floo::BMXRTCServiceListener *)imarg2;
  (arg1)->removeRTCServiceListener(arg2);
}

void* _wrap_new_BMXRTCServiceListener() {
  void* imresult = 0 ;
  floo::BMXRTCServiceListener *result = 0 ;
  
  result = (floo::BMXRTCServiceListener *)new floo::BMXRTCServiceListener();
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_delete_BMXRTCServiceListener(void* imarg1) {
  floo::BMXRTCServiceListener *arg1 = (floo::BMXRTCServiceListener *) 0 ;
  
  arg1 = (floo::BMXRTCServiceListener *)imarg1;
  delete arg1;
}

void _wrap_BMXRTCServiceListener_onRTCMessageStatusChanged(void* imarg1, void* imarg2, int imarg3) {
  floo::BMXRTCServiceListener *arg1 = (floo::BMXRTCServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXMessage > > arg2 ;
  floo::BMXErrorCode arg3 ;
  floo::BMXMessagePtr *argp2 ;
  
  arg1 = (floo::BMXRTCServiceListener *)imarg1;
  
  argp2 = (floo::BMXMessagePtr *)imarg2;
  arg2 = *argp2;
  
  arg3 = (floo::BMXErrorCode)imarg3;
  (arg1)->onRTCMessageStatusChanged(arg2,arg3);
}

void _wrap_BMXRTCServiceListener_onRTCCallMessageReceive(void* imarg1, void* imarg2) {
  floo::BMXRTCServiceListener *arg1 = (floo::BMXRTCServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXMessage > > arg2 ;
  floo::BMXMessagePtr *argp2 ;
  
  arg1 = (floo::BMXRTCServiceListener *)imarg1; 
  
  argp2 = (floo::BMXMessagePtr *)imarg2;
  arg2 = *argp2; 
  
  (arg1)->onRTCCallMessageReceive(arg2);
}

void _wrap_BMXRTCServiceListener_onRTCPickupMessageReceive(void* imarg1, void* imarg2) {
  floo::BMXRTCServiceListener *arg1 = (floo::BMXRTCServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXMessage > > arg2 ;
  floo::BMXMessagePtr *argp2 ;
  
  arg1 = (floo::BMXRTCServiceListener *)imarg1; 
  
  argp2 = (floo::BMXMessagePtr *)imarg2;
  arg2 = *argp2; 
  
  (arg1)->onRTCPickupMessageReceive(arg2);
}

void _wrap_BMXRTCServiceListener_onRTCHangupMessageReceive(void* imarg1, void* imarg2) {
  floo::BMXRTCServiceListener *arg1 = (floo::BMXRTCServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXMessage > > arg2 ;
  floo::BMXMessagePtr *argp2 ;
  
  arg1 = (floo::BMXRTCServiceListener *)imarg1;
  
  argp2 = (floo::BMXMessagePtr *)imarg2;
  arg2 = *argp2;
  
  (arg1)->onRTCHangupMessageReceive(arg2);
}

void _wrap_BMXRTCServiceListener_onRTCRecordMessageReceive(void* imarg1, void* imarg2) {
  floo::BMXRTCServiceListener *arg1 = (floo::BMXRTCServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXMessage > > arg2 ;
  floo::BMXMessagePtr *argp2 ;
  
  arg1 = (floo::BMXRTCServiceListener *)imarg1;
  
  argp2 = (floo::BMXMessagePtr *)imarg2;
  arg2 = *argp2;
  
  (arg1)->onRTCRecordMessageReceive(arg2);
}

void _wrap_BMXRTCServiceListener_registerRTCService(void* imarg1, void* imarg2) {
  floo::BMXRTCServiceListener *arg1 = (floo::BMXRTCServiceListener *) 0 ;
  floo::BMXRTCService *arg2 = (floo::BMXRTCService *) 0 ;
  
  arg1 = (floo::BMXRTCServiceListener *)imarg1;
  arg2 = (floo::BMXRTCService *)imarg2;
  (arg1)->registerRTCService(arg2);
}

void _wrap_delete_BMXRTCSession(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSessionPtr arg1 ;
  floo::BMXRTCSessionPtr *argp1 = *(floo::BMXRTCSessionPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  
  delete argp1;
}

long long _wrap_BMXRTCSession_sessionId(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSessionPtr arg1 ;
  floo::BMXRTCSessionPtr *argp1 = *(floo::BMXRTCSessionPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  long long imresult = 0 ;
  int64_t result;
  
  result = (int64_t)(arg1)->sessionId();
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

long long _wrap_BMXRTCSession_pubHandlerId(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSessionPtr arg1 ;
  floo::BMXRTCSessionPtr *argp1 = *(floo::BMXRTCSessionPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  long long imresult = 0 ;
  int64_t result;
  
  result = (int64_t)(arg1)->pubHandlerId();
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

long long _wrap_BMXRTCSession_subHandlerId(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRTCSessionPtr arg1 ;
  floo::BMXRTCSessionPtr *argp1 = *(floo::BMXRTCSessionPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  long long imresult = 0 ;
  int64_t result;
  
  result = (int64_t)(arg1)->subHandlerId();
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_delete_BMXRTCSignalService(void* imarg1) {
  floo::BMXRTCSignalService *arg1 = (floo::BMXRTCSignalService *) 0 ;
  
  arg1 = (floo::BMXRTCSignalService *)imarg1;
  delete arg1;
}

void _wrap_BMXRTCSignalService_createSession(void* imarg1) {
  floo::BMXRTCSignalService *arg1 = (floo::BMXRTCSignalService *) 0 ;
  
  arg1 = (floo::BMXRTCSignalService *)imarg1;
  (arg1)->createSession();
}

void _wrap_BMXRTCSignalService_attachSession(void* imarg1, void* imarg2, int imarg3) {
  floo::BMXRTCSignalService *arg1 = (floo::BMXRTCSignalService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  floo::BMXRTCSignalService::HandlerType arg3 ;
  floo::BMXRTCSessionPtr *argp2 ;
  
  arg1 = (floo::BMXRTCSignalService *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  arg3 = (floo::BMXRTCSignalService::HandlerType)imarg3;
  (arg1)->attachSession(arg2,arg3);
}

void _wrap_BMXRTCSignalService_createRoom(void* imarg1, void* imarg2, void* imarg3) {
  floo::BMXRTCSignalService *arg1 = (floo::BMXRTCSignalService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSignalService::BMXRoomCreateOptions > > arg3 ;
  floo::BMXRTCSessionPtr *argp2 ;
  floo::BMXRTCSignalService::BMXRoomCreateOptionsPtr *argp3 ;
  
  arg1 = (floo::BMXRTCSignalService *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  
  argp3 = (floo::BMXRTCSignalService::BMXRoomCreateOptionsPtr *)imarg3;
  arg3 = *argp3;
  
  (arg1)->createRoom(arg2,arg3);
}

void _wrap_BMXRTCSignalService_destroyRoom__SWIG_0(void* imarg1, void* imarg2, void* imarg3, BOOL imarg4) {
  floo::BMXRTCSignalService *arg1 = (floo::BMXRTCSignalService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCRoom > > arg3 ;
  bool arg4 ;
  floo::BMXRTCSessionPtr *argp2 ;
  floo::BMXRTCRoomPtr *argp3 ;
  
  arg1 = (floo::BMXRTCSignalService *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  
  argp3 = (floo::BMXRTCRoomPtr *)imarg3;
  arg3 = *argp3;
  
  arg4 = imarg4? true : false;
  (arg1)->destroyRoom(arg2,arg3,arg4);
}

void _wrap_BMXRTCSignalService_destroyRoom__SWIG_1(void* imarg1, void* imarg2, void* imarg3) {
  floo::BMXRTCSignalService *arg1 = (floo::BMXRTCSignalService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCRoom > > arg3 ;
  floo::BMXRTCSessionPtr *argp2 ;
  floo::BMXRTCRoomPtr *argp3 ;
  
  arg1 = (floo::BMXRTCSignalService *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  
  argp3 = (floo::BMXRTCRoomPtr *)imarg3;
  arg3 = *argp3;
  
  (arg1)->destroyRoom(arg2,arg3);
}

void _wrap_BMXRTCSignalService_editRoom(void* imarg1, void* imarg2, void* imarg3, void* imarg4) {
  floo::BMXRTCSignalService *arg1 = (floo::BMXRTCSignalService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCRoom > > arg3 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSignalService::BMXRoomEditOptions > > arg4 ;
  floo::BMXRTCSessionPtr *argp2 ;
  floo::BMXRTCRoomPtr *argp3 ;
  floo::BMXRTCSignalService::BMXRoomEditOptionsPtr *argp4 ;
  
  arg1 = (floo::BMXRTCSignalService *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  
  argp3 = (floo::BMXRTCRoomPtr *)imarg3;
  arg3 = *argp3;
  
  
  argp4 = (floo::BMXRTCSignalService::BMXRoomEditOptionsPtr *)imarg4;
  arg4 = *argp4;
  
  (arg1)->editRoom(arg2,arg3,arg4);
}

void _wrap_BMXRTCSignalService_isExistsRoom(void* imarg1, void* imarg2, long long imarg3) {
  floo::BMXRTCSignalService *arg1 = (floo::BMXRTCSignalService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  int64_t arg3 ;
  floo::BMXRTCSessionPtr *argp2 ;
  
  arg1 = (floo::BMXRTCSignalService *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  arg3 = (int64_t)imarg3;
  (arg1)->isExistsRoom(arg2,arg3);
}

void _wrap_BMXRTCSignalService_allowed(void* imarg1, void* imarg2, void* imarg3, void* imarg4) {
  floo::BMXRTCSignalService *arg1 = (floo::BMXRTCSignalService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCRoom > > arg3 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSignalService::BMXRoomAllowdOptions > > arg4 ;
  floo::BMXRTCSessionPtr *argp2 ;
  floo::BMXRTCRoomPtr *argp3 ;
  floo::BMXRTCSignalService::BMXRoomAllowdOptionsPtr *argp4 ;
  
  arg1 = (floo::BMXRTCSignalService *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  
  argp3 = (floo::BMXRTCRoomPtr *)imarg3;
  arg3 = *argp3;
  
  
  argp4 = (floo::BMXRTCSignalService::BMXRoomAllowdOptionsPtr *)imarg4;
  arg4 = *argp4;
  
  (arg1)->allowed(arg2,arg3,arg4);
}

void _wrap_BMXRTCSignalService_kickParticipants(void* imarg1, void* imarg2, void* imarg3, long long imarg4) {
  floo::BMXRTCSignalService *arg1 = (floo::BMXRTCSignalService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCRoom > > arg3 ;
  int64_t arg4 ;
  floo::BMXRTCSessionPtr *argp2 ;
  floo::BMXRTCRoomPtr *argp3 ;
  
  arg1 = (floo::BMXRTCSignalService *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  
  argp3 = (floo::BMXRTCRoomPtr *)imarg3;
  arg3 = *argp3;
  
  arg4 = (int64_t)imarg4;
  (arg1)->kickParticipants(arg2,arg3,arg4);
}

void _wrap_BMXRTCSignalService_moderate(void* imarg1, void* imarg2, void* imarg3, void* imarg4) {
  floo::BMXRTCSignalService *arg1 = (floo::BMXRTCSignalService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCRoom > > arg3 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSignalService::BMXRoomModerateOptions > > arg4 ;
  floo::BMXRTCSessionPtr *argp2 ;
  floo::BMXRTCRoomPtr *argp3 ;
  floo::BMXRTCSignalService::BMXRoomModerateOptionsPtr *argp4 ;
  
  arg1 = (floo::BMXRTCSignalService *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  
  argp3 = (floo::BMXRTCRoomPtr *)imarg3;
  arg3 = *argp3;
  
  
  argp4 = (floo::BMXRTCSignalService::BMXRoomModerateOptionsPtr *)imarg4;
  arg4 = *argp4;
  
  (arg1)->moderate(arg2,arg3,arg4);
}

void _wrap_BMXRTCSignalService_listRoom(void* imarg1, void* imarg2) {
  floo::BMXRTCSignalService *arg1 = (floo::BMXRTCSignalService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  floo::BMXRTCSessionPtr *argp2 ;
  
  arg1 = (floo::BMXRTCSignalService *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  (arg1)->listRoom(arg2);
}

void _wrap_BMXRTCSignalService_listRoomparticipants(void* imarg1, void* imarg2, void* imarg3) {
  floo::BMXRTCSignalService *arg1 = (floo::BMXRTCSignalService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCRoom > > arg3 ;
  floo::BMXRTCSessionPtr *argp2 ;
  floo::BMXRTCRoomPtr *argp3 ;
  
  arg1 = (floo::BMXRTCSignalService *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  
  argp3 = (floo::BMXRTCRoomPtr *)imarg3;
  arg3 = *argp3;
  
  (arg1)->listRoomparticipants(arg2,arg3);
}

void _wrap_BMXRTCSignalService_trickle(void* imarg1, void* imarg2, int imarg3, NSString* imarg4, int imarg5, NSString* imarg6) {
  floo::BMXRTCSignalService *arg1 = (floo::BMXRTCSignalService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  floo::BMXRTCSignalService::HandlerType arg3 ;
  std::string *arg4 = 0 ;
  int32_t arg5 ;
  std::string *arg6 = 0 ;
  floo::BMXRTCSessionPtr *argp2 ;
  
  arg1 = (floo::BMXRTCSignalService *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  arg3 = (floo::BMXRTCSignalService::HandlerType)imarg3;
  if(!imarg4) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg4_str(getStdString(imarg4));
  arg4 = &arg4_str;
  
  arg5 = (int32_t)imarg5;
  if(!imarg6) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg6_str(getStdString(imarg6));
  arg6 = &arg6_str;
  
  (arg1)->trickle(arg2,arg3,(std::string const &)*arg4,arg5,(std::string const &)*arg6);
}

void _wrap_BMXRTCSignalService_trickleCompleted(void* imarg1, void* imarg2, int imarg3) {
  floo::BMXRTCSignalService *arg1 = (floo::BMXRTCSignalService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  floo::BMXRTCSignalService::HandlerType arg3 ;
  floo::BMXRTCSessionPtr *argp2 ;
  
  arg1 = (floo::BMXRTCSignalService *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  arg3 = (floo::BMXRTCSignalService::HandlerType)imarg3;
  (arg1)->trickleCompleted(arg2,arg3);
}

void _wrap_BMXRTCSignalService_pubJoinRoom(void* imarg1, void* imarg2, void* imarg3) {
  floo::BMXRTCSignalService *arg1 = (floo::BMXRTCSignalService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSignalService::BMXPubRoomJoinOptions > > arg3 ;
  floo::BMXRTCSessionPtr *argp2 ;
  floo::BMXRTCSignalService::BMXPubRoomJoinOptionsPtr *argp3 ;
  
  arg1 = (floo::BMXRTCSignalService *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  
  argp3 = (floo::BMXRTCSignalService::BMXPubRoomJoinOptionsPtr *)imarg3;
  arg3 = *argp3;
  
  (arg1)->pubJoinRoom(arg2,arg3);
}

void _wrap_BMXRTCSignalService_pubPublish(void* imarg1, void* imarg2, void* imarg3, void* imarg4) {
  floo::BMXRTCSignalService *arg1 = (floo::BMXRTCSignalService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSignalService::BMXRoomPubConfigureOptions > > arg3 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRoomSDPInfo > > arg4 ;
  floo::BMXRTCSessionPtr *argp2 ;
  floo::BMXRTCSignalService::BMXRoomPubConfigureOptionsPtr *argp3 ;
  floo::BMXRoomSDPInfoPtr *argp4 ;
  
  arg1 = (floo::BMXRTCSignalService *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  
  argp3 = (floo::BMXRTCSignalService::BMXRoomPubConfigureOptionsPtr *)imarg3;
  arg3 = *argp3;
  
  
  argp4 = (floo::BMXRoomSDPInfoPtr *)imarg4;
  arg4 = *argp4;
  
  (arg1)->pubPublish(arg2,arg3,arg4);
}

void _wrap_BMXRTCSignalService_pubUnPublish(void* imarg1, void* imarg2) {
  floo::BMXRTCSignalService *arg1 = (floo::BMXRTCSignalService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  floo::BMXRTCSessionPtr *argp2 ;
  
  arg1 = (floo::BMXRTCSignalService *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  (arg1)->pubUnPublish(arg2);
}

void _wrap_BMXRTCSignalService_pubConfigue(void* imarg1, void* imarg2, void* imarg3, void* imarg4) {
  floo::BMXRTCSignalService *arg1 = (floo::BMXRTCSignalService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSignalService::BMXRoomPubConfigureOptions > > arg3 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRoomSDPInfo > > arg4 ;
  floo::BMXRTCSessionPtr *argp2 ;
  floo::BMXRTCSignalService::BMXRoomPubConfigureOptionsPtr *argp3 ;
  floo::BMXRoomSDPInfoPtr *argp4 ;
  
  arg1 = (floo::BMXRTCSignalService *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  
  argp3 = (floo::BMXRTCSignalService::BMXRoomPubConfigureOptionsPtr *)imarg3;
  arg3 = *argp3;
  
  
  argp4 = (floo::BMXRoomSDPInfoPtr *)imarg4;
  arg4 = *argp4;
  
  (arg1)->pubConfigue(arg2,arg3,arg4);
}

void _wrap_BMXRTCSignalService_subJoinRoom(void* imarg1, void* imarg2, void* imarg3) {
  floo::BMXRTCSignalService *arg1 = (floo::BMXRTCSignalService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSignalService::BMXRoomSubJoinOptions > > arg3 ;
  floo::BMXRTCSessionPtr *argp2 ;
  floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr *argp3 ;
  
  arg1 = (floo::BMXRTCSignalService *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  
  argp3 = (floo::BMXRTCSignalService::BMXRoomSubJoinOptionsPtr *)imarg3;
  arg3 = *argp3;
  
  (arg1)->subJoinRoom(arg2,arg3);
}

void _wrap_BMXRTCSignalService_subStart(void* imarg1, void* imarg2, void* imarg3, void* imarg4) {
  floo::BMXRTCSignalService *arg1 = (floo::BMXRTCSignalService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCRoom > > arg3 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRoomSDPInfo > > arg4 ;
  floo::BMXRTCSessionPtr *argp2 ;
  floo::BMXRTCRoomPtr *argp3 ;
  floo::BMXRoomSDPInfoPtr *argp4 ;
  
  arg1 = (floo::BMXRTCSignalService *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  
  argp3 = (floo::BMXRTCRoomPtr *)imarg3;
  arg3 = *argp3;
  
  
  argp4 = (floo::BMXRoomSDPInfoPtr *)imarg4;
  arg4 = *argp4;
  
  (arg1)->subStart(arg2,arg3,arg4);
}

void _wrap_BMXRTCSignalService_subPause(void* imarg1, void* imarg2, void* imarg3) {
  floo::BMXRTCSignalService *arg1 = (floo::BMXRTCSignalService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCRoom > > arg3 ;
  floo::BMXRTCSessionPtr *argp2 ;
  floo::BMXRTCRoomPtr *argp3 ;
  
  arg1 = (floo::BMXRTCSignalService *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  
  argp3 = (floo::BMXRTCRoomPtr *)imarg3;
  arg3 = *argp3;
  
  (arg1)->subPause(arg2,arg3);
}

void _wrap_BMXRTCSignalService_subUnsubscribe(void* imarg1, void* imarg2, void* imarg3, void* imarg4) {
  floo::BMXRTCSignalService *arg1 = (floo::BMXRTCSignalService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCRoom > > arg3 ;
  floo::BMXRTCStreams *arg4 = 0 ;
  floo::BMXRTCSessionPtr *argp2 ;
  floo::BMXRTCRoomPtr *argp3 ;
  
  arg1 = (floo::BMXRTCSignalService *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  
  argp3 = (floo::BMXRTCRoomPtr *)imarg3;
  arg3 = *argp3;
  
  arg4 = (floo::BMXRTCStreams *)imarg4;
  (arg1)->subUnsubscribe(arg2,arg3,(floo::BMXRTCStreams const &)*arg4);
}

void _wrap_BMXRTCSignalService_subConfigure(void* imarg1, void* imarg2, void* imarg3, void* imarg4) {
  floo::BMXRTCSignalService *arg1 = (floo::BMXRTCSignalService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSignalService::BMXRoomSubConfigureOptions > > arg3 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRoomSDPInfo > > arg4 ;
  floo::BMXRTCSessionPtr *argp2 ;
  floo::BMXRTCSignalService::BMXRoomSubConfigureOptionsPtr *argp3 ;
  floo::BMXRoomSDPInfoPtr *argp4 ;
  
  arg1 = (floo::BMXRTCSignalService *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  
  argp3 = (floo::BMXRTCSignalService::BMXRoomSubConfigureOptionsPtr *)imarg3;
  arg3 = *argp3;
  
  
  argp4 = (floo::BMXRoomSDPInfoPtr *)imarg4;
  arg4 = *argp4;
  
  (arg1)->subConfigure(arg2,arg3,arg4);
}

void _wrap_BMXRTCSignalService_subSwitch(void* imarg1, void* imarg2, void* imarg3) {
  floo::BMXRTCSignalService *arg1 = (floo::BMXRTCSignalService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSignalService::BMXRoomSubSwitchOptions > > arg3 ;
  floo::BMXRTCSessionPtr *argp2 ;
  floo::BMXRTCSignalService::BMXRoomSubSwitchOptionsPtr *argp3 ;
  
  arg1 = (floo::BMXRTCSignalService *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  
  argp3 = (floo::BMXRTCSignalService::BMXRoomSubSwitchOptionsPtr *)imarg3;
  arg3 = *argp3;
  
  (arg1)->subSwitch(arg2,arg3);
}

void _wrap_BMXRTCSignalService_leaveRoom(void* imarg1, void* imarg2) {
  floo::BMXRTCSignalService *arg1 = (floo::BMXRTCSignalService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  floo::BMXRTCSessionPtr *argp2 ;
  
  arg1 = (floo::BMXRTCSignalService *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  (arg1)->leaveRoom(arg2);
}

void _wrap_BMXRTCSignalService_hangUpSession(void* imarg1, void* imarg2) {
  floo::BMXRTCSignalService *arg1 = (floo::BMXRTCSignalService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  floo::BMXRTCSessionPtr *argp2 ;
  
  arg1 = (floo::BMXRTCSignalService *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  (arg1)->hangUpSession(arg2);
}

void _wrap_BMXRTCSignalService_detachSession(void* imarg1, void* imarg2, int imarg3) {
  floo::BMXRTCSignalService *arg1 = (floo::BMXRTCSignalService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  floo::BMXRTCSignalService::HandlerType arg3 ;
  floo::BMXRTCSessionPtr *argp2 ;
  
  arg1 = (floo::BMXRTCSignalService *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  arg3 = (floo::BMXRTCSignalService::HandlerType)imarg3;
  (arg1)->detachSession(arg2,arg3);
}

void _wrap_BMXRTCSignalService_destroySession(void* imarg1, void* imarg2) {
  floo::BMXRTCSignalService *arg1 = (floo::BMXRTCSignalService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  floo::BMXRTCSessionPtr *argp2 ;
  
  arg1 = (floo::BMXRTCSignalService *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  (arg1)->destroySession(arg2);
}

void _wrap_BMXRTCSignalService_addBMXRTCSignalServiceListener(void* imarg1, void* imarg2) {
  floo::BMXRTCSignalService *arg1 = (floo::BMXRTCSignalService *) 0 ;
  floo::BMXRTCSignalServiceListener *arg2 = (floo::BMXRTCSignalServiceListener *) 0 ;
  
  arg1 = (floo::BMXRTCSignalService *)imarg1;
  arg2 = (floo::BMXRTCSignalServiceListener *)imarg2;
  (arg1)->addBMXRTCSignalServiceListener(arg2);
}

void _wrap_BMXRTCSignalService_removeBMXRTCSignalServiceListener(void* imarg1, void* imarg2) {
  floo::BMXRTCSignalService *arg1 = (floo::BMXRTCSignalService *) 0 ;
  floo::BMXRTCSignalServiceListener *arg2 = (floo::BMXRTCSignalServiceListener *) 0 ;
  
  arg1 = (floo::BMXRTCSignalService *)imarg1;
  arg2 = (floo::BMXRTCSignalServiceListener *)imarg2;
  (arg1)->removeBMXRTCSignalServiceListener(arg2);
}

void* _wrap_new_BMXRTCSignalServiceListener() {
  void* imresult = 0 ;
  floo::BMXRTCSignalServiceListener *result = 0 ;
  
  result = (floo::BMXRTCSignalServiceListener *)new floo::BMXRTCSignalServiceListener();
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_delete_BMXRTCSignalServiceListener(void* imarg1) {
  floo::BMXRTCSignalServiceListener *arg1 = (floo::BMXRTCSignalServiceListener *) 0 ;
  
  arg1 = (floo::BMXRTCSignalServiceListener *)imarg1;
  delete arg1;
}

void _wrap_BMXRTCSignalServiceListener_onSessionCreate(void* imarg1, void* imarg2, int imarg3, NSString* imarg4) {
  floo::BMXRTCSignalServiceListener *arg1 = (floo::BMXRTCSignalServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  int arg3 ;
  std::string arg4 ;
  floo::BMXRTCSessionPtr *argp2 ;
  
  arg1 = (floo::BMXRTCSignalServiceListener *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  arg3 = (int)imarg3;
  if(!imarg4) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  
  (arg1)->onSessionCreate(arg2,arg3,getStdString(imarg4));
}

void _wrap_BMXRTCSignalServiceListener_onSessionAttach(void* imarg1, void* imarg2, int imarg3, int imarg4, NSString* imarg5) {
  floo::BMXRTCSignalServiceListener *arg1 = (floo::BMXRTCSignalServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  floo::BMXRTCSignalService::HandlerType arg3 ;
  int arg4 ;
  std::string arg5 ;
  floo::BMXRTCSessionPtr *argp2 ;
  
  arg1 = (floo::BMXRTCSignalServiceListener *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  arg3 = (floo::BMXRTCSignalService::HandlerType)imarg3;
  arg4 = (int)imarg4;
  if(!imarg5) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  
  (arg1)->onSessionAttach(arg2,arg3,arg4,getStdString(imarg5));
}

void _wrap_BMXRTCSignalServiceListener_onRoomCreate(void* imarg1, void* imarg2, void* imarg3, int imarg4, NSString* imarg5) {
  floo::BMXRTCSignalServiceListener *arg1 = (floo::BMXRTCSignalServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCRoom > > arg3 ;
  int arg4 ;
  std::string *arg5 = 0 ;
  floo::BMXRTCSessionPtr *argp2 ;
  floo::BMXRTCRoomPtr *argp3 ;
  
  arg1 = (floo::BMXRTCSignalServiceListener *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  
  argp3 = (floo::BMXRTCRoomPtr *)imarg3;
  arg3 = *argp3;
  
  arg4 = (int)imarg4;
  if(!imarg5) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg5_str(getStdString(imarg5));
  arg5 = &arg5_str;
  
  (arg1)->onRoomCreate(arg2,arg3,arg4,(std::string const &)*arg5);
}

void _wrap_BMXRTCSignalServiceListener_onRoomDestroy(void* imarg1, void* imarg2, long long imarg3, int imarg4, NSString* imarg5) {
  floo::BMXRTCSignalServiceListener *arg1 = (floo::BMXRTCSignalServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  int64_t arg3 ;
  int arg4 ;
  std::string *arg5 = 0 ;
  floo::BMXRTCSessionPtr *argp2 ;
  
  arg1 = (floo::BMXRTCSignalServiceListener *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  arg3 = (int64_t)imarg3;
  arg4 = (int)imarg4;
  if(!imarg5) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg5_str(getStdString(imarg5));
  arg5 = &arg5_str;
  
  (arg1)->onRoomDestroy(arg2,arg3,arg4,(std::string const &)*arg5);
}

void _wrap_BMXRTCSignalServiceListener_onRoomEdit(void* imarg1, void* imarg2, void* imarg3, int imarg4, NSString* imarg5) {
  floo::BMXRTCSignalServiceListener *arg1 = (floo::BMXRTCSignalServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCRoom > > arg3 ;
  int arg4 ;
  std::string *arg5 = 0 ;
  floo::BMXRTCSessionPtr *argp2 ;
  floo::BMXRTCRoomPtr *argp3 ;
  
  arg1 = (floo::BMXRTCSignalServiceListener *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  
  argp3 = (floo::BMXRTCRoomPtr *)imarg3;
  arg3 = *argp3;
  
  arg4 = (int)imarg4;
  if(!imarg5) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg5_str(getStdString(imarg5));
  arg5 = &arg5_str;
  
  (arg1)->onRoomEdit(arg2,arg3,arg4,(std::string const &)*arg5);
}

void _wrap_BMXRTCSignalServiceListener_onRoomExist(void* imarg1, void* imarg2, long long imarg3, BOOL imarg4, int imarg5, NSString* imarg6) {
  floo::BMXRTCSignalServiceListener *arg1 = (floo::BMXRTCSignalServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  int64_t arg3 ;
  bool arg4 ;
  int arg5 ;
  std::string *arg6 = 0 ;
  floo::BMXRTCSessionPtr *argp2 ;
  
  arg1 = (floo::BMXRTCSignalServiceListener *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  arg3 = (int64_t)imarg3;
  arg4 = imarg4? true : false;
  arg5 = (int)imarg5;
  if(!imarg6) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg6_str(getStdString(imarg6));
  arg6 = &arg6_str;
  
  (arg1)->onRoomExist(arg2,arg3,arg4,arg5,(std::string const &)*arg6);
}

void _wrap_BMXRTCSignalServiceListener_onRoomAllowed(void* imarg1, void* imarg2, void* imarg3, void* imarg4, int imarg5, NSString* imarg6) {
  floo::BMXRTCSignalServiceListener *arg1 = (floo::BMXRTCSignalServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCRoom > > arg3 ;
  std::vector< std::string > *arg4 = 0 ;
  int arg5 ;
  std::string *arg6 = 0 ;
  floo::BMXRTCSessionPtr *argp2 ;
  floo::BMXRTCRoomPtr *argp3 ;
  
  arg1 = (floo::BMXRTCSignalServiceListener *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  
  argp3 = (floo::BMXRTCRoomPtr *)imarg3;
  arg3 = *argp3;
  
  arg4 = (std::vector< std::string > *)imarg4;
  arg5 = (int)imarg5;
  if(!imarg6) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg6_str(getStdString(imarg6));
  arg6 = &arg6_str;
  
  (arg1)->onRoomAllowed(arg2,arg3,(std::vector< std::string > const &)*arg4,arg5,(std::string const &)*arg6);
}

void _wrap_BMXRTCSignalServiceListener_onRoomKick(void* imarg1, void* imarg2, void* imarg3, long long imarg4, int imarg5, NSString* imarg6) {
  floo::BMXRTCSignalServiceListener *arg1 = (floo::BMXRTCSignalServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCRoom > > arg3 ;
  int64_t arg4 ;
  int arg5 ;
  std::string *arg6 = 0 ;
  floo::BMXRTCSessionPtr *argp2 ;
  floo::BMXRTCRoomPtr *argp3 ;
  
  arg1 = (floo::BMXRTCSignalServiceListener *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  
  argp3 = (floo::BMXRTCRoomPtr *)imarg3;
  arg3 = *argp3;
  
  arg4 = (int64_t)imarg4;
  arg5 = (int)imarg5;
  if(!imarg6) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg6_str(getStdString(imarg6));
  arg6 = &arg6_str;
  
  (arg1)->onRoomKick(arg2,arg3,arg4,arg5,(std::string const &)*arg6);
}

void _wrap_BMXRTCSignalServiceListener_onRoomModerate(void* imarg1, void* imarg2, void* imarg3, long long imarg4, int imarg5, NSString* imarg6) {
  floo::BMXRTCSignalServiceListener *arg1 = (floo::BMXRTCSignalServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCRoom > > arg3 ;
  int64_t arg4 ;
  int arg5 ;
  std::string *arg6 = 0 ;
  floo::BMXRTCSessionPtr *argp2 ;
  floo::BMXRTCRoomPtr *argp3 ;
  
  arg1 = (floo::BMXRTCSignalServiceListener *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  
  argp3 = (floo::BMXRTCRoomPtr *)imarg3;
  arg3 = *argp3;
  
  arg4 = (int64_t)imarg4;
  arg5 = (int)imarg5;
  if(!imarg6) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg6_str(getStdString(imarg6));
  arg6 = &arg6_str;
  
  (arg1)->onRoomModerate(arg2,arg3,arg4,arg5,(std::string const &)*arg6);
}

void _wrap_BMXRTCSignalServiceListener_onRoomList(void* imarg1, void* imarg2, void* imarg3, int imarg4, NSString* imarg5) {
  floo::BMXRTCSignalServiceListener *arg1 = (floo::BMXRTCSignalServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  floo::BMXRTCRooms *arg3 = 0 ;
  int arg4 ;
  std::string *arg5 = 0 ;
  floo::BMXRTCSessionPtr *argp2 ;
  
  arg1 = (floo::BMXRTCSignalServiceListener *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  arg3 = (floo::BMXRTCRooms *)imarg3;
  arg4 = (int)imarg4;
  if(!imarg5) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg5_str(getStdString(imarg5));
  arg5 = &arg5_str;
  
  (arg1)->onRoomList(arg2,(floo::BMXRTCRooms const &)*arg3,arg4,(std::string const &)*arg5);
}

void _wrap_BMXRTCSignalServiceListener_onRoomListParticipants(void* imarg1, void* imarg2, void* imarg3, void* imarg4, int imarg5, NSString* imarg6) {
  floo::BMXRTCSignalServiceListener *arg1 = (floo::BMXRTCSignalServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCRoom > > arg3 ;
  floo::BMXRTCRoomParticipants *arg4 = 0 ;
  int arg5 ;
  std::string *arg6 = 0 ;
  floo::BMXRTCSessionPtr *argp2 ;
  floo::BMXRTCRoomPtr *argp3 ;
  
  arg1 = (floo::BMXRTCSignalServiceListener *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  
  argp3 = (floo::BMXRTCRoomPtr *)imarg3;
  arg3 = *argp3;
  
  arg4 = (floo::BMXRTCRoomParticipants *)imarg4;
  arg5 = (int)imarg5;
  if(!imarg6) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg6_str(getStdString(imarg6));
  arg6 = &arg6_str;
  
  (arg1)->onRoomListParticipants(arg2,arg3,(floo::BMXRTCRoomParticipants const &)*arg4,arg5,(std::string const &)*arg6);
}

void _wrap_BMXRTCSignalServiceListener_onPubJoinRoom(void* imarg1, void* imarg2, void* imarg3, void* imarg4, int imarg5, NSString* imarg6) {
  floo::BMXRTCSignalServiceListener *arg1 = (floo::BMXRTCSignalServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCRoom > > arg3 ;
  floo::BMXRTCPublishers *arg4 = 0 ;
  int arg5 ;
  std::string *arg6 = 0 ;
  floo::BMXRTCSessionPtr *argp2 ;
  floo::BMXRTCRoomPtr *argp3 ;
  
  arg1 = (floo::BMXRTCSignalServiceListener *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  
  argp3 = (floo::BMXRTCRoomPtr *)imarg3;
  arg3 = *argp3;
  
  arg4 = (floo::BMXRTCPublishers *)imarg4;
  arg5 = (int)imarg5;
  if(!imarg6) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg6_str(getStdString(imarg6));
  arg6 = &arg6_str;
  
  (arg1)->onPubJoinRoom(arg2,arg3,(floo::BMXRTCPublishers const &)*arg4,arg5,(std::string const &)*arg6);
}

void _wrap_BMXRTCSignalServiceListener_onOtherPubJoinRoom(void* imarg1, void* imarg2, void* imarg3, void* imarg4) {
  floo::BMXRTCSignalServiceListener *arg1 = (floo::BMXRTCSignalServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCRoom > > arg3 ;
  floo::BMXRTCPublishers *arg4 = 0 ;
  floo::BMXRTCSessionPtr *argp2 ;
  floo::BMXRTCRoomPtr *argp3 ;
  
  arg1 = (floo::BMXRTCSignalServiceListener *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  
  argp3 = (floo::BMXRTCRoomPtr *)imarg3;
  arg3 = *argp3;
  
  arg4 = (floo::BMXRTCPublishers *)imarg4;
  (arg1)->onOtherPubJoinRoom(arg2,arg3,(floo::BMXRTCPublishers const &)*arg4);
}

void _wrap_BMXRTCSignalServiceListener_onPubConfigure(void* imarg1, void* imarg2, void* imarg3, void* imarg4, void* imarg5, int imarg6, NSString* imarg7) {
  floo::BMXRTCSignalServiceListener *arg1 = (floo::BMXRTCSignalServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCRoom > > arg3 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRoomSDPInfo > > arg4 ;
  floo::BMXRTCStreams arg5 ;
  int arg6 ;
  std::string *arg7 = 0 ;
  floo::BMXRTCSessionPtr *argp2 ;
  floo::BMXRTCRoomPtr *argp3 ;
  floo::BMXRoomSDPInfoPtr *argp4 ;
  floo::BMXRTCStreams const *argp5 ;
  
  arg1 = (floo::BMXRTCSignalServiceListener *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  
  argp3 = (floo::BMXRTCRoomPtr *)imarg3;
  arg3 = *argp3;
  
  
  argp4 = (floo::BMXRoomSDPInfoPtr *)imarg4;
  arg4 = *argp4;
  
  
  argp5 = (floo::BMXRTCStreams *)imarg5;
  arg5 = *argp5;
  
  arg6 = (int)imarg6;
  if(!imarg7) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg7_str(getStdString(imarg7));
  arg7 = &arg7_str;
  
  (arg1)->onPubConfigure(arg2,arg3,arg4,arg5,arg6,(std::string const &)*arg7);
}

void _wrap_BMXRTCSignalServiceListener_onPubUnPublish(void* imarg1, void* imarg2, void* imarg3, int imarg4, int imarg5, NSString* imarg6) {
  floo::BMXRTCSignalServiceListener *arg1 = (floo::BMXRTCSignalServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCRoom > > arg3 ;
  int arg4 ;
  int arg5 ;
  std::string *arg6 = 0 ;
  floo::BMXRTCSessionPtr *argp2 ;
  floo::BMXRTCRoomPtr *argp3 ;
  
  arg1 = (floo::BMXRTCSignalServiceListener *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  
  argp3 = (floo::BMXRTCRoomPtr *)imarg3;
  arg3 = *argp3;
  
  arg4 = (int)imarg4;
  arg5 = (int)imarg5;
  if(!imarg6) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg6_str(getStdString(imarg6));
  arg6 = &arg6_str;
  
  (arg1)->onPubUnPublish(arg2,arg3,arg4,arg5,(std::string const &)*arg6);
}

void _wrap_BMXRTCSignalServiceListener_onPublishWebrtcUp(void* imarg1, void* imarg2) {
  floo::BMXRTCSignalServiceListener *arg1 = (floo::BMXRTCSignalServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  floo::BMXRTCSessionPtr *argp2 ;
  
  arg1 = (floo::BMXRTCSignalServiceListener *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  (arg1)->onPublishWebrtcUp(arg2);
}

void _wrap_BMXRTCSignalServiceListener_onSubJoinRoomUpdate(void* imarg1, void* imarg2, void* imarg3, void* imarg4, long long imarg5, void* imarg6, int imarg7, NSString* imarg8) {
  floo::BMXRTCSignalServiceListener *arg1 = (floo::BMXRTCSignalServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCRoom > > arg3 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRoomSDPInfo > > arg4 ;
  int64_t arg5 ;
  floo::BMXRTCStreams arg6 ;
  int arg7 ;
  std::string *arg8 = 0 ;
  floo::BMXRTCSessionPtr *argp2 ;
  floo::BMXRTCRoomPtr *argp3 ;
  floo::BMXRoomSDPInfoPtr *argp4 ;
  floo::BMXRTCStreams const *argp6 ;
  
  arg1 = (floo::BMXRTCSignalServiceListener *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  
  argp3 = (floo::BMXRTCRoomPtr *)imarg3;
  arg3 = *argp3;
  
  
  argp4 = (floo::BMXRoomSDPInfoPtr *)imarg4;
  arg4 = *argp4;
  
  arg5 = (int64_t)imarg5;
  
  argp6 = (floo::BMXRTCStreams *)imarg6;
  arg6 = *argp6;
  
  arg7 = (int)imarg7;
  if(!imarg8) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg8_str(getStdString(imarg8));
  arg8 = &arg8_str;
  
  (arg1)->onSubJoinRoomUpdate(arg2,arg3,arg4,arg5,arg6,arg7,(std::string const &)*arg8);
}

void _wrap_BMXRTCSignalServiceListener_onSubStart(void* imarg1, void* imarg2, void* imarg3, int imarg4, NSString* imarg5) {
  floo::BMXRTCSignalServiceListener *arg1 = (floo::BMXRTCSignalServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCRoom > > arg3 ;
  int arg4 ;
  std::string *arg5 = 0 ;
  floo::BMXRTCSessionPtr *argp2 ;
  floo::BMXRTCRoomPtr *argp3 ;
  
  arg1 = (floo::BMXRTCSignalServiceListener *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  
  argp3 = (floo::BMXRTCRoomPtr *)imarg3;
  arg3 = *argp3;
  
  arg4 = (int)imarg4;
  if(!imarg5) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg5_str(getStdString(imarg5));
  arg5 = &arg5_str;
  
  (arg1)->onSubStart(arg2,arg3,arg4,(std::string const &)*arg5);
}

void _wrap_BMXRTCSignalServiceListener_onSubPause(void* imarg1, void* imarg2, void* imarg3, int imarg4, NSString* imarg5) {
  floo::BMXRTCSignalServiceListener *arg1 = (floo::BMXRTCSignalServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCRoom > > arg3 ;
  int arg4 ;
  std::string *arg5 = 0 ;
  floo::BMXRTCSessionPtr *argp2 ;
  floo::BMXRTCRoomPtr *argp3 ;
  
  arg1 = (floo::BMXRTCSignalServiceListener *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  
  argp3 = (floo::BMXRTCRoomPtr *)imarg3;
  arg3 = *argp3;
  
  arg4 = (int)imarg4;
  if(!imarg5) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg5_str(getStdString(imarg5));
  arg5 = &arg5_str;
  
  (arg1)->onSubPause(arg2,arg3,arg4,(std::string const &)*arg5);
}

void _wrap_BMXRTCSignalServiceListener_onSubUnsubscribe(void* imarg1, void* imarg2, void* imarg3, void* imarg4, int imarg5, NSString* imarg6) {
  floo::BMXRTCSignalServiceListener *arg1 = (floo::BMXRTCSignalServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCRoom > > arg3 ;
  floo::BMXRTCStreams arg4 ;
  int arg5 ;
  std::string *arg6 = 0 ;
  floo::BMXRTCSessionPtr *argp2 ;
  floo::BMXRTCRoomPtr *argp3 ;
  floo::BMXRTCStreams const *argp4 ;
  
  arg1 = (floo::BMXRTCSignalServiceListener *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  
  argp3 = (floo::BMXRTCRoomPtr *)imarg3;
  arg3 = *argp3;
  
  
  argp4 = (floo::BMXRTCStreams *)imarg4;
  arg4 = *argp4;
  
  arg5 = (int)imarg5;
  if(!imarg6) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg6_str(getStdString(imarg6));
  arg6 = &arg6_str;
  
  (arg1)->onSubUnsubscribe(arg2,arg3,arg4,arg5,(std::string const &)*arg6);
}

void _wrap_BMXRTCSignalServiceListener_onSubConfigure(void* imarg1, void* imarg2, void* imarg3, int imarg4, NSString* imarg5) {
  floo::BMXRTCSignalServiceListener *arg1 = (floo::BMXRTCSignalServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCRoom > > arg3 ;
  int arg4 ;
  std::string *arg5 = 0 ;
  floo::BMXRTCSessionPtr *argp2 ;
  floo::BMXRTCRoomPtr *argp3 ;
  
  arg1 = (floo::BMXRTCSignalServiceListener *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  
  argp3 = (floo::BMXRTCRoomPtr *)imarg3;
  arg3 = *argp3;
  
  arg4 = (int)imarg4;
  if(!imarg5) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg5_str(getStdString(imarg5));
  arg5 = &arg5_str;
  
  (arg1)->onSubConfigure(arg2,arg3,arg4,(std::string const &)*arg5);
}

void _wrap_BMXRTCSignalServiceListener_onSubSwitch(void* imarg1, void* imarg2, void* imarg3, long long imarg4, int imarg5, NSString* imarg6) {
  floo::BMXRTCSignalServiceListener *arg1 = (floo::BMXRTCSignalServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCRoom > > arg3 ;
  int64_t arg4 ;
  int arg5 ;
  std::string *arg6 = 0 ;
  floo::BMXRTCSessionPtr *argp2 ;
  floo::BMXRTCRoomPtr *argp3 ;
  
  arg1 = (floo::BMXRTCSignalServiceListener *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  
  argp3 = (floo::BMXRTCRoomPtr *)imarg3;
  arg3 = *argp3;
  
  arg4 = (int64_t)imarg4;
  arg5 = (int)imarg5;
  if(!imarg6) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg6_str(getStdString(imarg6));
  arg6 = &arg6_str;
  
  (arg1)->onSubSwitch(arg2,arg3,arg4,arg5,(std::string const &)*arg6);
}

void _wrap_BMXRTCSignalServiceListener_onLeaveRoom(void* imarg1, void* imarg2, long long imarg3, long long imarg4, int imarg5, NSString* imarg6) {
  floo::BMXRTCSignalServiceListener *arg1 = (floo::BMXRTCSignalServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  int64_t arg3 ;
  int64_t arg4 ;
  int arg5 ;
  std::string arg6 ;
  floo::BMXRTCSessionPtr *argp2 ;
  
  arg1 = (floo::BMXRTCSignalServiceListener *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  arg3 = (int64_t)imarg3;
  arg4 = (int64_t)imarg4;
  arg5 = (int)imarg5;
  if(!imarg6) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  
  (arg1)->onLeaveRoom(arg2,arg3,arg4,arg5,getStdString(imarg6));
}

void _wrap_BMXRTCSignalServiceListener_onSubscribeWebrtcUp(void* imarg1, void* imarg2, long long imarg3) {
  floo::BMXRTCSignalServiceListener *arg1 = (floo::BMXRTCSignalServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  int64_t arg3 ;
  floo::BMXRTCSessionPtr *argp2 ;
  
  arg1 = (floo::BMXRTCSignalServiceListener *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  arg3 = (int64_t)imarg3;
  (arg1)->onSubscribeWebrtcUp(arg2,arg3);
}

void _wrap_BMXRTCSignalServiceListener_onMediaInfo(void* imarg1, void* imarg2, long long imarg3, int imarg4, BOOL imarg5, NSString* imarg6) {
  floo::BMXRTCSignalServiceListener *arg1 = (floo::BMXRTCSignalServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  int64_t arg3 ;
  floo::BMXTrackType arg4 ;
  bool arg5 ;
  std::string *arg6 = 0 ;
  floo::BMXRTCSessionPtr *argp2 ;
  
  arg1 = (floo::BMXRTCSignalServiceListener *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  arg3 = (int64_t)imarg3;
  arg4 = (floo::BMXTrackType)imarg4;
  arg5 = imarg5? true : false;
  if(!imarg6) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg6_str(getStdString(imarg6));
  arg6 = &arg6_str;
  
  (arg1)->onMediaInfo(arg2,arg3,arg4,arg5,(std::string const &)*arg6);
}

void _wrap_BMXRTCSignalServiceListener_onSlowlink(void* imarg1, void* imarg2, long long imarg3, BOOL imarg4, int imarg5) {
  floo::BMXRTCSignalServiceListener *arg1 = (floo::BMXRTCSignalServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  int64_t arg3 ;
  bool arg4 ;
  int arg5 ;
  floo::BMXRTCSessionPtr *argp2 ;
  
  arg1 = (floo::BMXRTCSignalServiceListener *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  arg3 = (int64_t)imarg3;
  arg4 = imarg4? true : false;
  arg5 = (int)imarg5;
  (arg1)->onSlowlink(arg2,arg3,arg4,arg5);
}

void _wrap_BMXRTCSignalServiceListener_onHangup(void* imarg1, void* imarg2, long long imarg3, NSString* imarg4) {
  floo::BMXRTCSignalServiceListener *arg1 = (floo::BMXRTCSignalServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  int64_t arg3 ;
  std::string *arg4 = 0 ;
  floo::BMXRTCSessionPtr *argp2 ;
  
  arg1 = (floo::BMXRTCSignalServiceListener *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  arg3 = (int64_t)imarg3;
  if(!imarg4) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg4_str(getStdString(imarg4));
  arg4 = &arg4_str;
  
  (arg1)->onHangup(arg2,arg3,(std::string const &)*arg4);
}

void _wrap_BMXRTCSignalServiceListener_onSessionHangup(void* imarg1, void* imarg2, long long imarg3, NSString* imarg4) {
  floo::BMXRTCSignalServiceListener *arg1 = (floo::BMXRTCSignalServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  int64_t arg3 ;
  std::string *arg4 = 0 ;
  floo::BMXRTCSessionPtr *argp2 ;
  
  arg1 = (floo::BMXRTCSignalServiceListener *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  arg3 = (int64_t)imarg3;
  if(!imarg4) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg4_str(getStdString(imarg4));
  arg4 = &arg4_str;
  
  (arg1)->onSessionHangup(arg2,arg3,(std::string const &)*arg4);
}

void _wrap_BMXRTCSignalServiceListener_onSessionDetach(void* imarg1, void* imarg2, int imarg3, int imarg4, NSString* imarg5) {
  floo::BMXRTCSignalServiceListener *arg1 = (floo::BMXRTCSignalServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRTCSession > > arg2 ;
  floo::BMXRTCSignalService::HandlerType arg3 ;
  int arg4 ;
  std::string arg5 ;
  floo::BMXRTCSessionPtr *argp2 ;
  
  arg1 = (floo::BMXRTCSignalServiceListener *)imarg1;
  
  argp2 = (floo::BMXRTCSessionPtr *)imarg2;
  arg2 = *argp2;
  
  arg3 = (floo::BMXRTCSignalService::HandlerType)imarg3;
  arg4 = (int)imarg4;
  if(!imarg5) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  
  (arg1)->onSessionDetach(arg2,arg3,arg4,getStdString(imarg5));
}

void _wrap_BMXRTCSignalServiceListener_onSessionDestroy(void* imarg1, long long imarg2, int imarg3, NSString* imarg4) {
  floo::BMXRTCSignalServiceListener *arg1 = (floo::BMXRTCSignalServiceListener *) 0 ;
  int64_t arg2 ;
  int arg3 ;
  std::string arg4 ;
  
  arg1 = (floo::BMXRTCSignalServiceListener *)imarg1;
  arg2 = (int64_t)imarg2;
  arg3 = (int)imarg3;
  if(!imarg4) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException"
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  
  (arg1)->onSessionDestroy(arg2,arg3,getStdString(imarg4));
}

void _wrap_BMXRTCSignalServiceListener_registerRTCSignalService(void* imarg1, void* imarg2) {
  floo::BMXRTCSignalServiceListener *arg1 = (floo::BMXRTCSignalServiceListener *) 0 ;
  floo::BMXRTCSignalService *arg2 = (floo::BMXRTCSignalService *) 0 ;
  
  arg1 = (floo::BMXRTCSignalServiceListener *)imarg1;
  arg2 = (floo::BMXRTCSignalService *)imarg2;
  (arg1)->registerRTCSignalService(arg2);
}

void _wrap_delete_BMXGroup(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroupPtr arg1 ;
  floo::BMXGroupPtr *argp1 = *(floo::BMXGroupPtr **)&larg1;
  delete argp1;
}

long long _wrap_BMXGroup_groupId(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroupPtr arg1 ;
  floo::BMXGroupPtr *argp1 = *(floo::BMXGroupPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  long long imresult = 0 ;
  int64_t result;
  
  result = (int64_t)(arg1)->groupId();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

int _wrap_BMXGroup_groupType(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroupPtr arg1 ;
  floo::BMXGroupPtr *argp1 = *(floo::BMXGroupPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  floo::BMXGroup::GroupType result;
  
  result = (floo::BMXGroup::GroupType)(arg1)->groupType();
  imresult = (int)result; 
  return imresult;
}

NSString* _wrap_BMXGroup_myNickname(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroupPtr arg1 ;
  floo::BMXGroupPtr *argp1 = *(floo::BMXGroupPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &(arg1)->myNickname();
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_BMXGroup_name(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroupPtr arg1 ;
  floo::BMXGroupPtr *argp1 = *(floo::BMXGroupPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &(arg1)->name();
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_BMXGroup_description(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroupPtr arg1 ;
  floo::BMXGroupPtr *argp1 = *(floo::BMXGroupPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &(arg1)->description();
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_BMXGroup_avatarRatelUrl(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroupPtr arg1 ;
  floo::BMXGroupPtr *argp1 = *(floo::BMXGroupPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string result;
  
  result = (arg1)->avatarRatelUrl();
  imresult = [NSString stringWithUTF8String: (&result)->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_BMXGroup_avatarUrl(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroupPtr arg1 ;
  floo::BMXGroupPtr *argp1 = *(floo::BMXGroupPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string result;
  
  result = (arg1)->avatarUrl();
  imresult = [NSString stringWithUTF8String: (&result)->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_BMXGroup_avatarPath(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroupPtr arg1 ;
  floo::BMXGroupPtr *argp1 = *(floo::BMXGroupPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string result;
  
  result = (arg1)->avatarPath();
  imresult = [NSString stringWithUTF8String: (&result)->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_BMXGroup_avatarThumbnailUrl(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroupPtr arg1 ;
  floo::BMXGroupPtr *argp1 = *(floo::BMXGroupPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string result;
  
  result = (arg1)->avatarThumbnailUrl();
  imresult = [NSString stringWithUTF8String: (&result)->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_BMXGroup_avatarThumbnailPath(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroupPtr arg1 ;
  floo::BMXGroupPtr *argp1 = *(floo::BMXGroupPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string result;
  
  result = (arg1)->avatarThumbnailPath();
  imresult = [NSString stringWithUTF8String: (&result)->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

long long _wrap_BMXGroup_createTime(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroupPtr arg1 ;
  floo::BMXGroupPtr *argp1 = *(floo::BMXGroupPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  long long imresult = 0 ;
  int64_t result;
  
  result = (int64_t)(arg1)->createTime();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

NSString* _wrap_BMXGroup_extension(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroupPtr arg1 ;
  floo::BMXGroupPtr *argp1 = *(floo::BMXGroupPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  floo::JSON *result = 0 ;
  
  result = (floo::JSON *) &(arg1)->extension();
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

long long _wrap_BMXGroup_ownerId(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroupPtr arg1 ;
  floo::BMXGroupPtr *argp1 = *(floo::BMXGroupPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  long long imresult = 0 ;
  int64_t result;
  
  result = (int64_t)(arg1)->ownerId();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

int _wrap_BMXGroup_capacity(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroupPtr arg1 ;
  floo::BMXGroupPtr *argp1 = *(floo::BMXGroupPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  int result;
  
  result = (int)(arg1)->capacity();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

int _wrap_BMXGroup_membersCount(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroupPtr arg1 ;
  floo::BMXGroupPtr *argp1 = *(floo::BMXGroupPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  int result;
  
  result = (int)(arg1)->membersCount();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

int _wrap_BMXGroup_adminsCount(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroupPtr arg1 ;
  floo::BMXGroupPtr *argp1 = *(floo::BMXGroupPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  int result;
  
  result = (int)(arg1)->adminsCount();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

int _wrap_BMXGroup_blockListSize(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroupPtr arg1 ;
  floo::BMXGroupPtr *argp1 = *(floo::BMXGroupPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  int result;
  
  result = (int)(arg1)->blockListSize();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

int _wrap_BMXGroup_bannedListSize(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroupPtr arg1 ;
  floo::BMXGroupPtr *argp1 = *(floo::BMXGroupPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  int result;
  
  result = (int)(arg1)->bannedListSize();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

int _wrap_BMXGroup_sharedFilesCount(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroupPtr arg1 ;
  floo::BMXGroupPtr *argp1 = *(floo::BMXGroupPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  int result;
  
  result = (int)(arg1)->sharedFilesCount();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

long long _wrap_BMXGroup_latestAnnouncementId(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroupPtr arg1 ;
  floo::BMXGroupPtr *argp1 = *(floo::BMXGroupPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  long long imresult = 0 ;
  int64_t result;
  
  result = (int64_t)(arg1)->latestAnnouncementId();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

int _wrap_BMXGroup_msgPushMode(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroupPtr arg1 ;
  floo::BMXGroupPtr *argp1 = *(floo::BMXGroupPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  floo::BMXGroup::MsgPushMode result;
  
  result = (floo::BMXGroup::MsgPushMode)(arg1)->msgPushMode();
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroup_modifyMode(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroupPtr arg1 ;
  floo::BMXGroupPtr *argp1 = *(floo::BMXGroupPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  floo::BMXGroup::ModifyMode result;
  
  result = (floo::BMXGroup::ModifyMode)(arg1)->modifyMode();
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroup_joinAuthMode(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroupPtr arg1 ;
  floo::BMXGroupPtr *argp1 = *(floo::BMXGroupPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  floo::BMXGroup::JoinAuthMode result;
  
  result = (floo::BMXGroup::JoinAuthMode)(arg1)->joinAuthMode();
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroup_inviteMode(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroupPtr arg1 ;
  floo::BMXGroupPtr *argp1 = *(floo::BMXGroupPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  floo::BMXGroup::InviteMode result;
  
  result = (floo::BMXGroup::InviteMode)(arg1)->inviteMode();
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroup_msgMuteMode(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroupPtr arg1 ;
  floo::BMXGroupPtr *argp1 = *(floo::BMXGroupPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  floo::BMXGroup::MsgMuteMode result;
  
  result = (floo::BMXGroup::MsgMuteMode)(arg1)->msgMuteMode();
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroup_groupStatus(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroupPtr arg1 ;
  floo::BMXGroupPtr *argp1 = *(floo::BMXGroupPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  floo::BMXGroup::GroupStatus result;
  
  result = (floo::BMXGroup::GroupStatus)(arg1)->groupStatus();
  imresult = (int)result; 
  return imresult;
}

BOOL _wrap_BMXGroup_isMember(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroupPtr arg1 ;
  floo::BMXGroupPtr *argp1 = *(floo::BMXGroupPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BOOL imresult = 0 ;
  bool result;
  
  result = (bool)(arg1)->isMember();
  imresult = (result)? YES:NO; 
  return imresult;
}

BOOL _wrap_BMXGroup_enableReadAck(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroupPtr arg1 ;
  floo::BMXGroupPtr *argp1 = *(floo::BMXGroupPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BOOL imresult = 0 ;
  bool result;
  
  result = (bool)(arg1)->enableReadAck();
  imresult = (result)? YES:NO; 
  return imresult;
}

BOOL _wrap_BMXGroup_historyVisible(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroupPtr arg1 ;
  floo::BMXGroupPtr *argp1 = *(floo::BMXGroupPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BOOL imresult = 0 ;
  bool result;
  
  result = (bool)(arg1)->historyVisible();
  imresult = (result)? YES:NO; 
  return imresult;
}

int _wrap_BMXGroup_roleType(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroupPtr arg1 ;
  floo::BMXGroupPtr *argp1 = *(floo::BMXGroupPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  floo::BMXGroup::MemberRoleType result;
  
  result = (floo::BMXGroup::MemberRoleType)(arg1)->roleType();
  imresult = (int)result; 
  return imresult;
}

long long _wrap_BMXGroup_banExpireTime(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXGroupPtr arg1 ;
  floo::BMXGroupPtr *argp1 = *(floo::BMXGroupPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  long long imresult = 0 ;
  int64_t result;
  
  result = (int64_t)(arg1)->banExpireTime();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_delete_BMXGroupService(void* imarg1) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  delete arg1;
}

int _wrap_BMXGroupService_get(void* imarg1, void* imarg2, BOOL imarg3) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  floo::BMXGroupList *arg2 = 0 ;
  bool arg3 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  arg2 = (floo::BMXGroupList *)imarg2; 
  arg3 = imarg3? true : false; 
  result = (floo::BMXErrorCode)(arg1)->get(*arg2,arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_search__SWIG_0(void* imarg1, void* imarg2, BOOL imarg3) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  floo::BMXGroupList *arg2 = 0 ;
  bool arg3 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  arg2 = (floo::BMXGroupList *)imarg2; 
  arg3 = imarg3? true : false; 
  result = (floo::BMXErrorCode)(arg1)->search(*arg2,arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_fetchGroupsByIdList(void* imarg1, void* imarg2, void* imarg3, BOOL imarg4) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  std::vector< int64_t > *arg2 = 0 ;
  floo::BMXGroupList *arg3 = 0 ;
  bool arg4 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  arg2 = (std::vector< int64_t > *)imarg2; 
  arg3 = (floo::BMXGroupList *)imarg3; 
  arg4 = imarg4? true : false; 
  result = (floo::BMXErrorCode)(arg1)->fetchGroupsByIdList((std::vector< int64_t > const &)*arg2,*arg3,arg4);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_search__SWIG_1(void* imarg1, void* imarg2, void* imarg3, BOOL imarg4) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  std::vector< int64_t > *arg2 = 0 ;
  floo::BMXGroupList *arg3 = 0 ;
  bool arg4 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  arg2 = (std::vector< int64_t > *)imarg2; 
  arg3 = (floo::BMXGroupList *)imarg3; 
  arg4 = imarg4? true : false; 
  result = (floo::BMXErrorCode)(arg1)->search((std::vector< int64_t > const &)*arg2,*arg3,arg4);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_fetchGroupById(void* imarg1, long long imarg2, void** imarg3, BOOL imarg4) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  int64_t arg2 ;
  floo::BMXGroupPtr arg3 = 0 ;
  bool arg4 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  arg2 = (int64_t)imarg2; 
  arg4 = imarg4? true : false;
  result = (floo::BMXErrorCode)(arg1)->fetchGroupById(arg2,arg3,arg4);
    
  BMXGroup2Void(arg3)
  *imarg3 = (void*)lresult;

  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_search__SWIG_2(void* imarg1, long long imarg2, void** imarg3, BOOL imarg4) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  int64_t arg2 ;
  floo::BMXGroupPtr arg3 = 0 ;
  bool arg4 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  arg2 = (int64_t)imarg2; 
  arg4 = imarg4? true : false;
  result = (floo::BMXErrorCode)(arg1)->search(arg2,arg3,arg4);
    
  BMXGroup2Void(arg3)
  *imarg3 = (void*)lresult;

  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_fetchLocalGroupsByName(void* imarg1, void* imarg2, NSString* imarg3) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  floo::BMXGroupList *arg2 = 0 ;
  std::string *arg3 = 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  arg2 = (floo::BMXGroupList *)imarg2; 
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str; 
  
  result = (floo::BMXErrorCode)(arg1)->fetchLocalGroupsByName(*arg2,(std::string const &)*arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_search__SWIG_3(void* imarg1, void* imarg2, NSString* imarg3) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  floo::BMXGroupList *arg2 = 0 ;
  std::string *arg3 = 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  arg2 = (floo::BMXGroupList *)imarg2; 
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str; 
  
  result = (floo::BMXErrorCode)(arg1)->search(*arg2,(std::string const &)*arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_create(void* imarg1, void* imarg2, void* imarg3) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  floo::BMXGroupPtr arg3 = 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  long long larg2 = (long long)imarg2;
  floo::BMXGroupService::CreateGroupOptionsPtr arg2 ;
  floo::BMXGroupService::CreateGroupOptionsPtr *argp2 = *(floo::BMXGroupService::CreateGroupOptionsPtr **)&larg2;
  if (argp2) arg2 = *argp2;

  result = (floo::BMXErrorCode)(arg1)->create((floo::BMXGroupService::CreateGroupOptions const &)*arg2,arg3);
  BMXGroup2Void(arg3)
  imarg3 = (void*)lresult;
  imresult = (int)result;
  return imresult;
}

int _wrap_BMXGroupService_destroy(void* imarg1, void* imarg2) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  result = (floo::BMXErrorCode)(arg1)->destroy(arg2);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_join(void* imarg1, void* imarg2, NSString* imarg3) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  std::string *arg3 = 0 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str; 
  
  result = (floo::BMXErrorCode)(arg1)->join(arg2,(std::string const &)*arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_leave(void* imarg1, void* imarg2) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  result = (floo::BMXErrorCode)(arg1)->leave(arg2);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_getInfo(void* imarg1, void* imarg2) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  result = (floo::BMXErrorCode)(arg1)->getInfo(arg2);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_getMembersNickname(void* imarg1, void* imarg2, void* imarg3, void* imarg4) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  std::vector< int64_t > *arg3 = 0 ;
  floo::BMXGroup::MemberList *arg4 = 0 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (std::vector< int64_t > *)imarg3; 
  arg4 = (floo::BMXGroup::MemberList *)imarg4; 
  result = (floo::BMXErrorCode)(arg1)->getMembersNickname(arg2,(std::vector< int64_t > const &)*arg3,*arg4);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_getInvitationList__SWIG_0(void* imarg1, void* imarg2, NSString* imarg3, int imarg4) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  BMXGroupInvitationPagePtr *arg2 = 0 ;
  std::string *arg3 = 0 ;
  int arg4 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  arg2 = (BMXGroupInvitationPagePtr *)imarg2; 
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str; 
  
  arg4 = (int)imarg4; 
  result = (floo::BMXErrorCode)(arg1)->getInvitationList(*arg2,(std::string const &)*arg3,arg4);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_getInvitationList__SWIG_1(void* imarg1, void* imarg2, NSString* imarg3) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  BMXGroupInvitationPagePtr *arg2 = 0 ;
  std::string *arg3 = 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  arg2 = (BMXGroupInvitationPagePtr *)imarg2; 
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str; 
  
  result = (floo::BMXErrorCode)(arg1)->getInvitationList(*arg2,(std::string const &)*arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_getInvitationList__SWIG_2(void* imarg1, void* imarg2) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  BMXGroupInvitationPagePtr *arg2 = 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  arg2 = (BMXGroupInvitationPagePtr *)imarg2; 
  result = (floo::BMXErrorCode)(arg1)->getInvitationList(*arg2);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_getApplicationList__SWIG_0(void* imarg1, void* imarg2, void* imarg3, NSString* imarg4, int imarg5) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  floo::BMXGroupList arg2 ;
  BMXGroupApplicationPagePtr *arg3 = 0 ;
  std::string *arg4 = 0 ;
  int arg5 ;
  floo::BMXGroupList *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupList *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (BMXGroupApplicationPagePtr *)imarg3; 
  if(!imarg4) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg4_str(getStdString(imarg4));
  arg4 = &arg4_str; 
  
  arg5 = (int)imarg5; 
  result = (floo::BMXErrorCode)(arg1)->getApplicationList(arg2,*arg3,(std::string const &)*arg4,arg5);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_getApplicationList__SWIG_1(void* imarg1, void* imarg2, void* imarg3, NSString* imarg4) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  floo::BMXGroupList arg2 ;
  BMXGroupApplicationPagePtr *arg3 = 0 ;
  std::string *arg4 = 0 ;
  floo::BMXGroupList *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupList *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (BMXGroupApplicationPagePtr *)imarg3; 
  if(!imarg4) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg4_str(getStdString(imarg4));
  arg4 = &arg4_str; 
  
  result = (floo::BMXErrorCode)(arg1)->getApplicationList(arg2,*arg3,(std::string const &)*arg4);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_getApplicationList__SWIG_2(void* imarg1, void* imarg2, void* imarg3) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  floo::BMXGroupList arg2 ;
  BMXGroupApplicationPagePtr *arg3 = 0 ;
  floo::BMXGroupList *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupList *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (BMXGroupApplicationPagePtr *)imarg3; 
  result = (floo::BMXErrorCode)(arg1)->getApplicationList(arg2,*arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_getMembers__SWIG_0(void* imarg1, void* imarg2, void* imarg3, NSString* imarg4, int imarg5) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  BMXGroupMemberResultPagePtr *arg3 = 0 ;
  std::string *arg4 = 0 ;
  int arg5 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (BMXGroupMemberResultPagePtr *)imarg3; 
  if(!imarg4) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg4_str(getStdString(imarg4));
  arg4 = &arg4_str; 
  
  arg5 = (int)imarg5; 
  result = (floo::BMXErrorCode)(arg1)->getMembers(arg2,*arg3,(std::string const &)*arg4,arg5);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_getMembers__SWIG_1(void* imarg1, void* imarg2, void* imarg3, NSString* imarg4) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  BMXGroupMemberResultPagePtr *arg3 = 0 ;
  std::string *arg4 = 0 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (BMXGroupMemberResultPagePtr *)imarg3; 
  if(!imarg4) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg4_str(getStdString(imarg4));
  arg4 = &arg4_str; 
  
  result = (floo::BMXErrorCode)(arg1)->getMembers(arg2,*arg3,(std::string const &)*arg4);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_getMembers__SWIG_2(void* imarg1, void* imarg2, void* imarg3) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  BMXGroupMemberResultPagePtr *arg3 = 0 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (BMXGroupMemberResultPagePtr *)imarg3; 
  result = (floo::BMXErrorCode)(arg1)->getMembers(arg2,*arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_getMembers__SWIG_3(void* imarg1, void* imarg2, void* imarg3, BOOL imarg4) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  floo::BMXGroup::MemberList *arg3 = 0 ;
  bool arg4 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (floo::BMXGroup::MemberList *)imarg3; 
  arg4 = imarg4? true : false; 
  result = (floo::BMXErrorCode)(arg1)->getMembers(arg2,*arg3,arg4);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_addMembers(void* imarg1, void* imarg2, void* imarg3, NSString* imarg4) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  std::vector< int64_t > *arg3 = 0 ;
  std::string *arg4 = 0 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (std::vector< int64_t > *)imarg3; 
  if(!imarg4) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg4_str(getStdString(imarg4));
  arg4 = &arg4_str; 
  
  result = (floo::BMXErrorCode)(arg1)->addMembers(arg2,(std::vector< int64_t > const &)*arg3,(std::string const &)*arg4);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_removeMembers(void* imarg1, void* imarg2, void* imarg3, NSString* imarg4) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  std::vector< int64_t > *arg3 = 0 ;
  std::string *arg4 = 0 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (std::vector< int64_t > *)imarg3; 
  if(!imarg4) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg4_str(getStdString(imarg4));
  arg4 = &arg4_str; 
  
  result = (floo::BMXErrorCode)(arg1)->removeMembers(arg2,(std::vector< int64_t > const &)*arg3,(std::string const &)*arg4);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_addAdmins(void* imarg1, void* imarg2, void* imarg3, NSString* imarg4) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  std::vector< int64_t > *arg3 = 0 ;
  std::string *arg4 = 0 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (std::vector< int64_t > *)imarg3; 
  if(!imarg4) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg4_str(getStdString(imarg4));
  arg4 = &arg4_str; 
  
  result = (floo::BMXErrorCode)(arg1)->addAdmins(arg2,(std::vector< int64_t > const &)*arg3,(std::string const &)*arg4);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_removeAdmins(void* imarg1, void* imarg2, void* imarg3, NSString* imarg4) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  std::vector< int64_t > *arg3 = 0 ;
  std::string *arg4 = 0 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (std::vector< int64_t > *)imarg3; 
  if(!imarg4) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg4_str(getStdString(imarg4));
  arg4 = &arg4_str; 
  
  result = (floo::BMXErrorCode)(arg1)->removeAdmins(arg2,(std::vector< int64_t > const &)*arg3,(std::string const &)*arg4);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_getAdmins(void* imarg1, void* imarg2, void* imarg3, BOOL imarg4) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  floo::BMXGroup::MemberList *arg3 = 0 ;
  bool arg4 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (floo::BMXGroup::MemberList *)imarg3; 
  arg4 = imarg4? true : false; 
  result = (floo::BMXErrorCode)(arg1)->getAdmins(arg2,*arg3,arg4);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_blockMembers(void* imarg1, void* imarg2, void* imarg3) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  std::vector< int64_t > *arg3 = 0 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (std::vector< int64_t > *)imarg3; 
  result = (floo::BMXErrorCode)(arg1)->blockMembers(arg2,(std::vector< int64_t > const &)*arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_unblockMembers(void* imarg1, void* imarg2, void* imarg3) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  std::vector< int64_t > *arg3 = 0 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (std::vector< int64_t > *)imarg3; 
  result = (floo::BMXErrorCode)(arg1)->unblockMembers(arg2,(std::vector< int64_t > const &)*arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_getBlockList__SWIG_0(void* imarg1, void* imarg2, void* imarg3, NSString* imarg4, int imarg5) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  BMXGroupMemberResultPagePtr *arg3 = 0 ;
  std::string *arg4 = 0 ;
  int arg5 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (BMXGroupMemberResultPagePtr *)imarg3; 
  if(!imarg4) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg4_str(getStdString(imarg4));
  arg4 = &arg4_str; 
  
  arg5 = (int)imarg5; 
  result = (floo::BMXErrorCode)(arg1)->getBlockList(arg2,*arg3,(std::string const &)*arg4,arg5);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_getBlockList__SWIG_1(void* imarg1, void* imarg2, void* imarg3, NSString* imarg4) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  BMXGroupMemberResultPagePtr *arg3 = 0 ;
  std::string *arg4 = 0 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (BMXGroupMemberResultPagePtr *)imarg3; 
  if(!imarg4) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg4_str(getStdString(imarg4));
  arg4 = &arg4_str; 
  
  result = (floo::BMXErrorCode)(arg1)->getBlockList(arg2,*arg3,(std::string const &)*arg4);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_getBlockList__SWIG_2(void* imarg1, void* imarg2, void* imarg3) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  BMXGroupMemberResultPagePtr *arg3 = 0 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (BMXGroupMemberResultPagePtr *)imarg3; 
  result = (floo::BMXErrorCode)(arg1)->getBlockList(arg2,*arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_getBlockList__SWIG_3(void* imarg1, void* imarg2, void* imarg3, BOOL imarg4) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  floo::BMXGroup::MemberList *arg3 = 0 ;
  bool arg4 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (floo::BMXGroup::MemberList *)imarg3; 
  arg4 = imarg4? true : false; 
  result = (floo::BMXErrorCode)(arg1)->getBlockList(arg2,*arg3,arg4);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_banMembers__SWIG_0(void* imarg1, void* imarg2, void* imarg3, long long imarg4, NSString* imarg5) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  std::vector< int64_t > *arg3 = 0 ;
  int64_t arg4 ;
  std::string *arg5 = 0 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (std::vector< int64_t > *)imarg3; 
  arg4 = (int64_t)imarg4; 
  if(!imarg5) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg5_str(getStdString(imarg5));
  arg5 = &arg5_str; 
  
  result = (floo::BMXErrorCode)(arg1)->banMembers(arg2,(std::vector< int64_t > const &)*arg3,arg4,(std::string const &)*arg5);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_banMembers__SWIG_1(void* imarg1, void* imarg2, void* imarg3, long long imarg4) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  std::vector< int64_t > *arg3 = 0 ;
  int64_t arg4 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (std::vector< int64_t > *)imarg3; 
  arg4 = (int64_t)imarg4; 
  result = (floo::BMXErrorCode)(arg1)->banMembers(arg2,(std::vector< int64_t > const &)*arg3,arg4);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_banGroup(void* imarg1, void* imarg2, long long imarg3) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  int64_t arg3 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (int64_t)imarg3; 
  result = (floo::BMXErrorCode)(arg1)->banGroup(arg2,arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_unbanMembers(void* imarg1, void* imarg2, void* imarg3) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  std::vector< int64_t > *arg3 = 0 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (std::vector< int64_t > *)imarg3; 
  result = (floo::BMXErrorCode)(arg1)->unbanMembers(arg2,(std::vector< int64_t > const &)*arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_unbanGroup(void* imarg1, void* imarg2) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  result = (floo::BMXErrorCode)(arg1)->unbanGroup(arg2);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_getBannedMembers__SWIG_0(void* imarg1, void* imarg2, void* imarg3, NSString* imarg4, int imarg5) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  BMXGroupBannedMemberResultPagePtr *arg3 = 0 ;
  std::string *arg4 = 0 ;
  int arg5 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (BMXGroupBannedMemberResultPagePtr *)imarg3; 
  if(!imarg4) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg4_str(getStdString(imarg4));
  arg4 = &arg4_str; 
  
  arg5 = (int)imarg5; 
  result = (floo::BMXErrorCode)(arg1)->getBannedMembers(arg2,*arg3,(std::string const &)*arg4,arg5);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_getBannedMembers__SWIG_1(void* imarg1, void* imarg2, void* imarg3, NSString* imarg4) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  BMXGroupBannedMemberResultPagePtr *arg3 = 0 ;
  std::string *arg4 = 0 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (BMXGroupBannedMemberResultPagePtr *)imarg3; 
  if(!imarg4) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg4_str(getStdString(imarg4));
  arg4 = &arg4_str; 
  
  result = (floo::BMXErrorCode)(arg1)->getBannedMembers(arg2,*arg3,(std::string const &)*arg4);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_getBannedMembers__SWIG_2(void* imarg1, void* imarg2, void* imarg3) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  BMXGroupBannedMemberResultPagePtr *arg3 = 0 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (BMXGroupBannedMemberResultPagePtr *)imarg3; 
  result = (floo::BMXErrorCode)(arg1)->getBannedMembers(arg2,*arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_getBannedMembers__SWIG_3(void* imarg1, void* imarg2, void* imarg3) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  floo::BMXGroup::BannedMemberList *arg3 = 0 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (floo::BMXGroup::BannedMemberList *)imarg3; 
  result = (floo::BMXErrorCode)(arg1)->getBannedMembers(arg2,*arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_muteMessage(void* imarg1, void* imarg2, int imarg3) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  floo::BMXGroup::MsgMuteMode arg3 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (floo::BMXGroup::MsgMuteMode)imarg3; 
  result = (floo::BMXErrorCode)(arg1)->muteMessage(arg2,arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_acceptApplication(void* imarg1, void* imarg2, long long imarg3) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  int64_t arg3 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (int64_t)imarg3; 
  result = (floo::BMXErrorCode)(arg1)->acceptApplication(arg2,arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_declineApplication__SWIG_0(void* imarg1, void* imarg2, long long imarg3, NSString* imarg4) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  int64_t arg3 ;
  std::string *arg4 = 0 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (int64_t)imarg3; 
  if(!imarg4) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg4_str(getStdString(imarg4));
  arg4 = &arg4_str; 
  
  result = (floo::BMXErrorCode)(arg1)->declineApplication(arg2,arg3,(std::string const &)*arg4);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_declineApplication__SWIG_1(void* imarg1, void* imarg2, long long imarg3) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  int64_t arg3 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (int64_t)imarg3; 
  result = (floo::BMXErrorCode)(arg1)->declineApplication(arg2,arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_acceptInvitation(void* imarg1, void* imarg2, long long imarg3) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  int64_t arg3 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (int64_t)imarg3; 
  result = (floo::BMXErrorCode)(arg1)->acceptInvitation(arg2,arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_declineInvitation__SWIG_0(void* imarg1, void* imarg2, long long imarg3, NSString* imarg4) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  int64_t arg3 ;
  std::string *arg4 = 0 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (int64_t)imarg3; 
  if(!imarg4) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg4_str(getStdString(imarg4));
  arg4 = &arg4_str; 
  
  result = (floo::BMXErrorCode)(arg1)->declineInvitation(arg2,arg3,(std::string const &)*arg4);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_declineInvitation__SWIG_1(void* imarg1, void* imarg2, long long imarg3) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  int64_t arg3 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (int64_t)imarg3; 
  result = (floo::BMXErrorCode)(arg1)->declineInvitation(arg2,arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_transferOwner(void* imarg1, void* imarg2, long long imarg3) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  int64_t arg3 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (int64_t)imarg3; 
  result = (floo::BMXErrorCode)(arg1)->transferOwner(arg2,arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_uploadSharedFile(void* imarg1, void* imarg2, NSString* imarg3, NSString* imarg4, NSString* imarg5, void* imarg6) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  std::string *arg5 = 0 ;
  floo::BMXGroupService::Callback arg6 ;
  floo::BMXGroupPtr *argp2 ;
  floo::BMXGroupService::Callback *argp6 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str; 
  
  if(!imarg4) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg4_str(getStdString(imarg4));
  arg4 = &arg4_str; 
  
  if(!imarg5) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg5_str(getStdString(imarg5));
  arg5 = &arg5_str; 
  
  
  argp6 = (floo::BMXGroupService::Callback *)imarg6;
  arg6 = nullptr;
  
  result = (floo::BMXErrorCode)(arg1)->uploadSharedFile(arg2,(std::string const &)*arg3,(std::string const &)*arg4,(std::string const &)*arg5,arg6);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_cancelUploadSharedFile(void* imarg1, void* imarg2, NSString* imarg3) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  std::string *arg3 = 0 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str; 
  
  result = (floo::BMXErrorCode)(arg1)->cancelUploadSharedFile(arg2,(std::string const &)*arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_removeSharedFile(void* imarg1, void* imarg2, void* imarg3) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup::SharedFile > > arg3 ;
  floo::BMXGroupPtr *argp2 ;
  floo::BMXGroup::SharedFilePtr *argp3 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  
  argp3 = (floo::BMXGroup::SharedFilePtr *)imarg3;
  arg3 = *argp3; 
  
  result = (floo::BMXErrorCode)(arg1)->removeSharedFile(arg2,arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_downloadSharedFile(void* imarg1, void* imarg2, void* imarg3, void* imarg4) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup::SharedFile > > arg3 ;
  floo::BMXGroupService::Callback arg4 ;
  floo::BMXGroupPtr *argp2 ;
  floo::BMXGroup::SharedFilePtr *argp3 ;
  floo::BMXGroupService::Callback *argp4 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  
  argp3 = (floo::BMXGroup::SharedFilePtr *)imarg3;
  arg3 = *argp3; 
  
  
  argp4 = (floo::BMXGroupService::Callback *)imarg4;
  arg4 = nullptr;
  
  result = (floo::BMXErrorCode)(arg1)->downloadSharedFile(arg2,arg3,arg4);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_cancelDownloadSharedFile(void* imarg1, void* imarg2, void* imarg3) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup::SharedFile > > arg3 ;
  floo::BMXGroupPtr *argp2 ;
  floo::BMXGroup::SharedFilePtr *argp3 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  
  argp3 = (floo::BMXGroup::SharedFilePtr *)imarg3;
  arg3 = *argp3; 
  
  result = (floo::BMXErrorCode)(arg1)->cancelDownloadSharedFile(arg2,arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_getSharedFilesList(void* imarg1, void* imarg2, void* imarg3, BOOL imarg4) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  floo::BMXGroup::SharedFileList *arg3 = 0 ;
  bool arg4 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (floo::BMXGroup::SharedFileList *)imarg3; 
  arg4 = imarg4? true : false; 
  result = (floo::BMXErrorCode)(arg1)->getSharedFilesList(arg2,*arg3,arg4);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_changeSharedFileName(void* imarg1, void* imarg2, void* imarg3, NSString* imarg4) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup::SharedFile > > arg3 ;
  std::string *arg4 = 0 ;
  floo::BMXGroupPtr *argp2 ;
  floo::BMXGroup::SharedFilePtr *argp3 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  
  argp3 = (floo::BMXGroup::SharedFilePtr *)imarg3;
  arg3 = *argp3; 
  
  if(!imarg4) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg4_str(getStdString(imarg4));
  arg4 = &arg4_str; 
  
  result = (floo::BMXErrorCode)(arg1)->changeSharedFileName(arg2,arg3,(std::string const &)*arg4);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_getLatestAnnouncement(void* imarg1, void* imarg2, void* imarg3, BOOL imarg4) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  floo::BMXGroup::AnnouncementPtr *arg3 = 0 ;
  bool arg4 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (floo::BMXGroup::AnnouncementPtr *)imarg3; 
  arg4 = imarg4? true : false; 
  result = (floo::BMXErrorCode)(arg1)->getLatestAnnouncement(arg2,*arg3,arg4);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_getAnnouncementList(void* imarg1, void* imarg2, void* imarg3, BOOL imarg4) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  floo::BMXGroup::AnnouncementList *arg3 = 0 ;
  bool arg4 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (floo::BMXGroup::AnnouncementList *)imarg3; 
  arg4 = imarg4? true : false; 
  result = (floo::BMXErrorCode)(arg1)->getAnnouncementList(arg2,*arg3,arg4);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_editAnnouncement(void* imarg1, void* imarg2, NSString* imarg3, NSString* imarg4) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str; 
  
  if(!imarg4) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg4_str(getStdString(imarg4));
  arg4 = &arg4_str; 
  
  result = (floo::BMXErrorCode)(arg1)->editAnnouncement(arg2,(std::string const &)*arg3,(std::string const &)*arg4);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_deleteAnnouncement(void* imarg1, void* imarg2, long long imarg3) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  int64_t arg3 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (int64_t)imarg3; 
  result = (floo::BMXErrorCode)(arg1)->deleteAnnouncement(arg2,arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_setName(void* imarg1, void* imarg2, NSString* imarg3) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  std::string *arg3 = 0 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str; 
  
  result = (floo::BMXErrorCode)(arg1)->setName(arg2,(std::string const &)*arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_setDescription(void* imarg1, void* imarg2, NSString* imarg3) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  std::string *arg3 = 0 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str; 
  
  result = (floo::BMXErrorCode)(arg1)->setDescription(arg2,(std::string const &)*arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_setExtension(void* imarg1, void* imarg2, NSString* imarg3) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  std::string *arg3 = 0 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str; 
  
  result = (floo::BMXErrorCode)(arg1)->setExtension(arg2,(std::string const &)*arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_setMyNickname(void* imarg1, void* imarg2, NSString* imarg3) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  std::string *arg3 = 0 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str; 
  
  result = (floo::BMXErrorCode)(arg1)->setMyNickname(arg2,(std::string const &)*arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_setMsgPushMode(void* imarg1, void* imarg2, int imarg3) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  floo::BMXGroup::MsgPushMode arg3 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (floo::BMXGroup::MsgPushMode)imarg3; 
  result = (floo::BMXErrorCode)(arg1)->setMsgPushMode(arg2,arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_setJoinAuthMode(void* imarg1, void* imarg2, int imarg3) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  floo::BMXGroup::JoinAuthMode arg3 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (floo::BMXGroup::JoinAuthMode)imarg3; 
  result = (floo::BMXErrorCode)(arg1)->setJoinAuthMode(arg2,arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_setInviteMode(void* imarg1, void* imarg2, int imarg3) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  floo::BMXGroup::InviteMode arg3 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (floo::BMXGroup::InviteMode)imarg3; 
  result = (floo::BMXErrorCode)(arg1)->setInviteMode(arg2,arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_setAllowMemberModify(void* imarg1, void* imarg2, BOOL imarg3) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  bool arg3 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = imarg3? true : false; 
  result = (floo::BMXErrorCode)(arg1)->setAllowMemberModify(arg2,arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_setEnableReadAck(void* imarg1, void* imarg2, BOOL imarg3) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  bool arg3 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = imarg3? true : false; 
  result = (floo::BMXErrorCode)(arg1)->setEnableReadAck(arg2,arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_setHistoryVisible(void* imarg1, void* imarg2, BOOL imarg3) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  bool arg3 ;
  floo::BMXGroupPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = imarg3? true : false; 
  result = (floo::BMXErrorCode)(arg1)->setHistoryVisible(arg2,arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_setAvatar(void* imarg1, void* imarg2, NSString* imarg3, void* imarg4) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  std::string *arg3 = 0 ;
  floo::BMXGroupService::Callback arg4 ;
  floo::BMXGroupPtr *argp2 ;
  floo::BMXGroupService::Callback *argp4 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str; 
  
  
  argp4 = (floo::BMXGroupService::Callback *)imarg4;
  arg4 = nullptr;
  
  result = (floo::BMXErrorCode)(arg1)->setAvatar(arg2,(std::string const &)*arg3,arg4);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXGroupService_downloadAvatar(void* imarg1, void* imarg2, BOOL imarg3, void* imarg4) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  bool arg3 ;
  floo::BMXGroupService::Callback arg4 ;
  floo::BMXGroupPtr *argp2 ;
  floo::BMXGroupService::Callback *argp4 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = imarg3? true : false; 
  
  argp4 = (floo::BMXGroupService::Callback *)imarg4;
  arg4 = nullptr;
  
  result = (floo::BMXErrorCode)(arg1)->downloadAvatar(arg2,arg3,arg4);
  imresult = (int)result; 
  return imresult;
}

void _wrap_BMXGroupService_addGroupListener(void* imarg1, void* imarg2) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  floo::BMXGroupServiceListener *arg2 = (floo::BMXGroupServiceListener *) 0 ;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  arg2 = (floo::BMXGroupServiceListener *)imarg2; 
  (arg1)->addGroupListener(arg2);
}

void _wrap_BMXGroupService_removeGroupListener(void* imarg1, void* imarg2) {
  floo::BMXGroupService *arg1 = (floo::BMXGroupService *) 0 ;
  floo::BMXGroupServiceListener *arg2 = (floo::BMXGroupServiceListener *) 0 ;
  
  arg1 = (floo::BMXGroupService *)imarg1; 
  arg2 = (floo::BMXGroupServiceListener *)imarg2; 
  (arg1)->removeGroupListener(arg2);
}

void* _wrap_new_BMXImageAttachment__SWIG_0(NSString* imarg1, void* imarg2, NSString* imarg3) {
  std::string *arg1 = 0 ;
  floo::BMXMessageAttachment::Size *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void* imresult = 0 ;
  floo::BMXImageAttachment *result = 0 ;
  
  if(!imarg1) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg1_str(getStdString(imarg1));
  arg1 = &arg1_str; 
  
  arg2 = (floo::BMXMessageAttachment::Size *)imarg2; 
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str; 
  
  result = (floo::BMXImageAttachment *)new floo::BMXImageAttachment((std::string const &)*arg1,(floo::BMXMessageAttachment::Size const &)*arg2,(std::string const &)*arg3);
  BMXMessageAttachment2Void(result)
  imresult = (void*)lresult;
  return imresult;
}

void* _wrap_new_BMXImageAttachment__SWIG_1(NSString* imarg1, void* imarg2) {
  std::string *arg1 = 0 ;
  floo::BMXMessageAttachment::Size *arg2 = 0 ;
  void* imresult = 0 ;
  floo::BMXImageAttachment *result = 0 ;
  
  if(!imarg1) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg1_str(getStdString(imarg1));
  arg1 = &arg1_str; 
  
  arg2 = (floo::BMXMessageAttachment::Size *)imarg2; 
  result = (floo::BMXImageAttachment *)new floo::BMXImageAttachment((std::string const &)*arg1,(floo::BMXMessageAttachment::Size const &)*arg2);
  BMXMessageAttachment2Void(result)
  imresult = (void*)lresult;
  return imresult;
}

void* _wrap_new_BMXImageAttachment__SWIG_2(NSString* imarg1, void* imarg2, NSString* imarg3, long long imarg4) {
  std::string *arg1 = 0 ;
  floo::BMXMessageAttachment::Size *arg2 = 0 ;
  std::string *arg3 = 0 ;
  int64_t arg4 ;
  void* imresult = 0 ;
  floo::BMXImageAttachment *result = 0 ;
  
  if(!imarg1) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg1_str(getStdString(imarg1));
  arg1 = &arg1_str; 
  
  arg2 = (floo::BMXMessageAttachment::Size *)imarg2; 
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str; 
  
  arg4 = (int64_t)imarg4; 
  result = (floo::BMXImageAttachment *)new floo::BMXImageAttachment((std::string const &)*arg1,(floo::BMXMessageAttachment::Size const &)*arg2,(std::string const &)*arg3,arg4);
  BMXMessageAttachment2Void(result)
  imresult = (void*)lresult;
  return imresult;
}

void _wrap_delete_BMXImageAttachment(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXImageAttachmentPtr arg1 ;
  floo::BMXImageAttachmentPtr *argp1 = *(floo::BMXImageAttachmentPtr **)&larg1;
  delete argp1;
}

int _wrap_BMXImageAttachment_type(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXImageAttachmentPtr arg1 ;
  floo::BMXImageAttachmentPtr *argp1 = *(floo::BMXImageAttachmentPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  floo::BMXMessageAttachment::Type result;
  
  result = (floo::BMXMessageAttachment::Type)(arg1)->type();
  imresult = (int)result; 
  return imresult;
}

void* _wrap_BMXImageAttachment_clone(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXImageAttachmentPtr arg1 ;
  floo::BMXImageAttachmentPtr *argp1 = *(floo::BMXImageAttachmentPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  void* imresult = 0 ;
  floo::BMXMessageAttachmentPtr *temp ;
  std::shared_ptr< floo::BMXMessageAttachment > result;
  
  result = (arg1)->clone();
  
  BMXMessageAttachment2Void(result)
  imresult = (void*)lresult;
  
  return imresult;
}

void* _wrap_BMXImageAttachment_size(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXImageAttachmentPtr arg1 ;
  floo::BMXImageAttachmentPtr *argp1 = *(floo::BMXImageAttachmentPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  void* imresult = 0 ;
  floo::BMXMessageAttachment::Size *result = 0 ;
  
  result = (floo::BMXMessageAttachment::Size *) &(arg1)->size();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

NSString* _wrap_BMXImageAttachment_thumbnailUrl(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXImageAttachmentPtr arg1 ;
  floo::BMXImageAttachmentPtr *argp1 = *(floo::BMXImageAttachmentPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &(arg1)->thumbnailUrl();
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXImageAttachment_setThumbnail(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXImageAttachmentPtr arg1 ;
  floo::BMXImageAttachmentPtr *argp1 = *(floo::BMXImageAttachmentPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  (arg1)->setThumbnail((std::string const &)*arg2);
}

NSString* _wrap_BMXImageAttachment_thumbnailPath(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXImageAttachmentPtr arg1 ;
  floo::BMXImageAttachmentPtr *argp1 = *(floo::BMXImageAttachmentPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &(arg1)->thumbnailPath();
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

int _wrap_BMXImageAttachment_thumbnailDownloadStatus(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXImageAttachmentPtr arg1 ;
  floo::BMXImageAttachmentPtr *argp1 = *(floo::BMXImageAttachmentPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  floo::BMXMessageAttachment::DownloadStatus result;
  
  result = (floo::BMXMessageAttachment::DownloadStatus)(arg1)->thumbnailDownloadStatus();
  imresult = (int)result; 
  return imresult;
}

void* _wrap_BMXImageAttachment_dynamic_cast(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXImageAttachmentPtr arg1 ;
  floo::BMXImageAttachmentPtr *argp1 = *(floo::BMXImageAttachmentPtr **)&larg1;
  if (argp1) arg1 = *argp1;
    
  return argp1;
}

void* _wrap_new_BMXLocationAttachment(double imarg1, double imarg2, NSString* imarg3) {
  double arg1 ;
  double arg2 ;
  std::string *arg3 = 0 ;
  void* imresult = 0 ;
  floo::BMXLocationAttachment *result = 0 ;
  
  arg1 = (double)imarg1; 
  arg2 = (double)imarg2; 
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str; 
  
  result = (floo::BMXLocationAttachment *)new floo::BMXLocationAttachment(arg1,arg2,(std::string const &)*arg3);
  BMXLocationAttachment2Void(result)
  imresult = (void*)lresult;
  return imresult;
}

void _wrap_delete_BMXLocationAttachment(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXLocationAttachmentPtr arg1 ;
  floo::BMXLocationAttachmentPtr *argp1 = *(floo::BMXLocationAttachmentPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  
  delete argp1;
}

int _wrap_BMXLocationAttachment_type(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXLocationAttachmentPtr arg1 ;
  floo::BMXLocationAttachmentPtr *argp1 = *(floo::BMXLocationAttachmentPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  floo::BMXMessageAttachment::Type result;
  
  result = (floo::BMXMessageAttachment::Type)(arg1)->type();
  imresult = (int)result; 
  return imresult;
}

void* _wrap_BMXLocationAttachment_clone(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXLocationAttachmentPtr arg1 ;
  floo::BMXLocationAttachmentPtr *argp1 = *(floo::BMXLocationAttachmentPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  void* imresult = 0 ;
  floo::BMXMessageAttachmentPtr *temp ;
  std::shared_ptr< floo::BMXMessageAttachment > result;
  
  result = (arg1)->clone();
  
  BMXMessageAttachment2Void(result)
  imresult = (void*)lresult; 
  
  return imresult;
}

double _wrap_BMXLocationAttachment_latitude(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXLocationAttachmentPtr arg1 ;
  floo::BMXLocationAttachmentPtr *argp1 = *(floo::BMXLocationAttachmentPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  double imresult = 0 ;
  double result;
  
  result = (double)(arg1)->latitude();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

double _wrap_BMXLocationAttachment_longitude(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXLocationAttachmentPtr arg1 ;
  floo::BMXLocationAttachmentPtr *argp1 = *(floo::BMXLocationAttachmentPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  double imresult = 0 ;
  double result;
  
  result = (double)(arg1)->longitude();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

NSString* _wrap_BMXLocationAttachment_address(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXLocationAttachmentPtr arg1 ;
  floo::BMXLocationAttachmentPtr *argp1 = *(floo::BMXLocationAttachmentPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &(arg1)->address();
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void* _wrap_BMXLocationAttachment_dynamic_cast(void* imarg1) {
    long long larg1 = (long long)imarg1;
    floo::BMXLocationAttachmentPtr arg1 ;
    floo::BMXLocationAttachmentPtr *argp1 = *(floo::BMXLocationAttachmentPtr **)&larg1;
    if (argp1) arg1 = *argp1;
      
    return argp1;
}

void _wrap_delete_BMXRosterService(void* imarg1) {
  floo::BMXRosterService *arg1 = (floo::BMXRosterService *) 0 ;
  
  arg1 = (floo::BMXRosterService *)imarg1; 
  delete arg1;
}

int _wrap_BMXRosterService_get(void* imarg1, void* imarg2, BOOL imarg3) {
  floo::BMXRosterService *arg1 = (floo::BMXRosterService *) 0 ;
  std::vector< int64_t > *arg2 = 0 ;
  bool arg3 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXRosterService *)imarg1; 
  arg2 = (std::vector< int64_t > *)imarg2; 
  arg3 = imarg3? true : false; 
  result = (floo::BMXErrorCode)(arg1)->get(*arg2,arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXRosterService_fetchRosterById(void* imarg1, long long imarg2, BOOL imarg3, void* imarg4) {
  floo::BMXRosterService *arg1 = (floo::BMXRosterService *) 0 ;
  int64_t arg2 ;
  bool arg3 ;
  BMXRosterItemPtr *arg4 = 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXRosterService *)imarg1; 
  arg2 = (int64_t)imarg2; 
  arg3 = imarg3? true : false; 
  arg4 = (BMXRosterItemPtr *)imarg4; 
  result = (floo::BMXErrorCode)(arg1)->fetchRosterById(arg2,arg3,*arg4);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXRosterService_search__SWIG_0(void* imarg1, long long imarg2, BOOL imarg3, void** imarg4) {
  floo::BMXRosterService *arg1 = (floo::BMXRosterService *) 0 ;
  int64_t arg2 ;
  bool arg3 ;
  BMXRosterItemPtr arg4 = 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXRosterService *)imarg1; 
  arg2 = (int64_t)imarg2; 
  arg3 = imarg3? true : false; 
  result = (floo::BMXErrorCode)(arg1)->search(arg2,arg3,arg4);
    
  BMXRosterItem2Void(arg4)
  *imarg4 = (void*)lresult;

  imresult = (int)result;
  return imresult;
}

int _wrap_BMXRosterService_fetchRosterByName(void* imarg1, NSString* imarg2, BOOL imarg3, void* imarg4) {
  floo::BMXRosterService *arg1 = (floo::BMXRosterService *) 0 ;
  std::string *arg2 = 0 ;
  bool arg3 ;
  BMXRosterItemPtr *arg4 = 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXRosterService *)imarg1; 
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  arg3 = imarg3? true : false; 
  arg4 = (BMXRosterItemPtr *)imarg4; 
  result = (floo::BMXErrorCode)(arg1)->fetchRosterByName((std::string const &)*arg2,arg3,*arg4);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXRosterService_search__SWIG_1(void* imarg1, NSString* imarg2, BOOL imarg3, void** imarg4) {
  floo::BMXRosterService *arg1 = (floo::BMXRosterService *) 0 ;
  std::string *arg2 = 0 ;
  bool arg3 ;
  BMXRosterItemPtr arg4 = 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXRosterService *)imarg1; 
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  arg3 = imarg3? true : false; 
  result = (floo::BMXErrorCode)(arg1)->search((std::string const &)*arg2,arg3,arg4);
    
  BMXRosterItem2Void(arg4)
  *imarg4 = (void*)lresult;

  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXRosterService_fetchRostersByIdList(void* imarg1, void* imarg2, void* imarg3, BOOL imarg4) {
  floo::BMXRosterService *arg1 = (floo::BMXRosterService *) 0 ;
  std::vector< int64_t > *arg2 = 0 ;
  BMXRosterList *arg3 = 0 ;
  bool arg4 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXRosterService *)imarg1; 
  arg2 = (std::vector< int64_t > *)imarg2; 
  arg3 = (BMXRosterList *)imarg3; 
  arg4 = imarg4? true : false; 
  result = (floo::BMXErrorCode)(arg1)->fetchRostersByIdList((std::vector< int64_t > const &)*arg2,*arg3,arg4);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXRosterService_search__SWIG_2(void* imarg1, void* imarg2, void** imarg3, BOOL imarg4) {
  floo::BMXRosterService *arg1 = (floo::BMXRosterService *) 0 ;
  std::vector< int64_t > *arg2 = 0 ;
  BMXRosterList arg3;
  bool arg4 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXRosterService *)imarg1; 
  arg2 = (std::vector< int64_t > *)imarg2; 
  arg4 = imarg4? true : false;
  result = (floo::BMXErrorCode)(arg1)->search((std::vector< int64_t > const &)*arg2,arg3,arg4);
  BMXRosterList2Void(arg3)
  *imarg3 = (void*)lresult;
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXRosterService_setItemLocalExtension(void* imarg1, void* imarg2, NSString* imarg3) {
  floo::BMXRosterService *arg1 = (floo::BMXRosterService *) 0 ;
  BMXRosterItemPtr arg2 ;
  floo::JSON *arg3 = 0 ;
  BMXRosterItemPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXRosterService *)imarg1; 
  
  argp2 = (BMXRosterItemPtr *)imarg2;
  arg2 = *argp2; 
  
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str; 
  
  result = (floo::BMXErrorCode)(arg1)->setItemLocalExtension(arg2,(floo::JSON const &)*arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXRosterService_setItemExtension(void* imarg1, void* imarg2, NSString* imarg3) {
  floo::BMXRosterService *arg1 = (floo::BMXRosterService *) 0 ;
  BMXRosterItemPtr arg2 ;
  floo::JSON *arg3 = 0 ;
  BMXRosterItemPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXRosterService *)imarg1; 
  
  argp2 = (BMXRosterItemPtr *)imarg2;
  arg2 = *argp2; 
  
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str; 
  
  result = (floo::BMXErrorCode)(arg1)->setItemExtension(arg2,(floo::JSON const &)*arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXRosterService_setItemAlias(void* imarg1, void* imarg2, NSString* imarg3) {
  floo::BMXRosterService *arg1 = (floo::BMXRosterService *) 0 ;
  BMXRosterItemPtr arg2 ;
  floo::JSON *arg3 = 0 ;
  BMXRosterItemPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXRosterService *)imarg1; 
  
  argp2 = (BMXRosterItemPtr *)imarg2;
  arg2 = *argp2; 
  
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str; 
  
  result = (floo::BMXErrorCode)(arg1)->setItemAlias(arg2,(floo::JSON const &)*arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXRosterService_setItemMuteNotification(void* imarg1, void* imarg2, BOOL imarg3) {
  floo::BMXRosterService *arg1 = (floo::BMXRosterService *) 0 ;
  BMXRosterItemPtr arg2 ;
  bool arg3 ;
  BMXRosterItemPtr *argp2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXRosterService *)imarg1; 
  
  argp2 = (BMXRosterItemPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = imarg3? true : false; 
  result = (floo::BMXErrorCode)(arg1)->setItemMuteNotification(arg2,arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXRosterService_getApplicationList__SWIG_0(void* imarg1, void** imarg2, NSString* imarg3, int imarg4) {
  floo::BMXRosterService *arg1 = (floo::BMXRosterService *) 0 ;
  BMXRosterService::BMXRosterApplicationResultPagePtr arg2;
  std::string *arg3 = 0 ;
  int arg4 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXRosterService *)imarg1; 
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str; 
  
  arg4 = (int)imarg4; 
  result = (floo::BMXErrorCode)(arg1)->getApplicationList(arg2,(std::string const &)*arg3,arg4);
  BMXRosterApplicationResultPage2Void(arg2)
  *imarg2 = (void*)lresult;
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXRosterService_getApplicationList__SWIG_1(void* imarg1, void* imarg2, NSString* imarg3) {
  floo::BMXRosterService *arg1 = (floo::BMXRosterService *) 0 ;
  BMXRosterService::BMXRosterApplicationResultPagePtr *arg2 = 0 ;
  std::string *arg3 = 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXRosterService *)imarg1; 
  arg2 = (BMXRosterService::BMXRosterApplicationResultPagePtr *)imarg2;
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str; 
  
  result = (floo::BMXErrorCode)(arg1)->getApplicationList(*arg2,(std::string const &)*arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXRosterService_apply__SWIG_0(void* imarg1, long long imarg2, NSString* imarg3, NSString* imarg4) {
  floo::BMXRosterService *arg1 = (floo::BMXRosterService *) 0 ;
  int64_t arg2 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXRosterService *)imarg1; 
  arg2 = (int64_t)imarg2; 
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str; 
  
  if(!imarg4) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg4_str(getStdString(imarg4));
  arg4 = &arg4_str; 
  
  result = (floo::BMXErrorCode)(arg1)->apply(arg2,(std::string const &)*arg3,(std::string const &)*arg4);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXRosterService_apply__SWIG_1(void* imarg1, long long imarg2, NSString* imarg3) {
  floo::BMXRosterService *arg1 = (floo::BMXRosterService *) 0 ;
  int64_t arg2 ;
  std::string *arg3 = 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXRosterService *)imarg1; 
  arg2 = (int64_t)imarg2; 
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str; 
  
  result = (floo::BMXErrorCode)(arg1)->apply(arg2,(std::string const &)*arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXRosterService_remove(void* imarg1, long long imarg2) {
  floo::BMXRosterService *arg1 = (floo::BMXRosterService *) 0 ;
  int64_t arg2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXRosterService *)imarg1; 
  arg2 = (int64_t)imarg2; 
  result = (floo::BMXErrorCode)(arg1)->remove(arg2);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXRosterService_accept(void* imarg1, long long imarg2) {
  floo::BMXRosterService *arg1 = (floo::BMXRosterService *) 0 ;
  int64_t arg2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXRosterService *)imarg1; 
  arg2 = (int64_t)imarg2; 
  result = (floo::BMXErrorCode)(arg1)->accept(arg2);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXRosterService_decline(void* imarg1, long long imarg2, NSString* imarg3) {
  floo::BMXRosterService *arg1 = (floo::BMXRosterService *) 0 ;
  int64_t arg2 ;
  std::string *arg3 = 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXRosterService *)imarg1; 
  arg2 = (int64_t)imarg2; 
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str; 
  
  result = (floo::BMXErrorCode)(arg1)->decline(arg2,(std::string const &)*arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXRosterService_block(void* imarg1, long long imarg2) {
  floo::BMXRosterService *arg1 = (floo::BMXRosterService *) 0 ;
  int64_t arg2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXRosterService *)imarg1; 
  arg2 = (int64_t)imarg2; 
  result = (floo::BMXErrorCode)(arg1)->block(arg2);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXRosterService_unblock(void* imarg1, long long imarg2) {
  floo::BMXRosterService *arg1 = (floo::BMXRosterService *) 0 ;
  int64_t arg2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXRosterService *)imarg1; 
  arg2 = (int64_t)imarg2; 
  result = (floo::BMXErrorCode)(arg1)->unblock(arg2);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXRosterService_getBlockList(void* imarg1, void* imarg2, BOOL imarg3) {
  floo::BMXRosterService *arg1 = (floo::BMXRosterService *) 0 ;
  std::vector< int64_t > *arg2 = 0 ;
  bool arg3 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXRosterService *)imarg1; 
  arg2 = (std::vector< int64_t > *)imarg2; 
  arg3 = imarg3? true : false; 
  result = (floo::BMXErrorCode)(arg1)->getBlockList(*arg2,arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXRosterService_downloadAvatar(void* imarg1, void* imarg2, BOOL imarg3, void* imarg4) {
  floo::BMXRosterService *arg1 = (floo::BMXRosterService *) 0 ;
  BMXRosterItemPtr arg2 ;
  bool arg3 ;
  floo::BMXRosterService::Callback arg4 ;
  BMXRosterItemPtr *argp2 ;
  floo::BMXRosterService::Callback *argp4 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXRosterService *)imarg1; 
  
  argp2 = (BMXRosterItemPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = imarg3? true : false; 
  
  argp4 = (floo::BMXRosterService::Callback *)imarg4;
  arg4 = nullptr; 
  
  result = (floo::BMXErrorCode)(arg1)->downloadAvatar(arg2,arg3,arg4);
  imresult = (int)result; 
  return imresult;
}

void _wrap_BMXRosterService_addRosterListener(void* imarg1, void* imarg2) {
  floo::BMXRosterService *arg1 = (floo::BMXRosterService *) 0 ;
  floo::BMXRosterServiceListener *arg2 = (floo::BMXRosterServiceListener *) 0 ;
  
  arg1 = (floo::BMXRosterService *)imarg1; 
  arg2 = (floo::BMXRosterServiceListener *)imarg2; 
  (arg1)->addRosterListener(arg2);
}

void _wrap_BMXRosterService_removeRosterListener(void* imarg1, void* imarg2) {
  floo::BMXRosterService *arg1 = (floo::BMXRosterService *) 0 ;
  floo::BMXRosterServiceListener *arg2 = (floo::BMXRosterServiceListener *) 0 ;
  
  arg1 = (floo::BMXRosterService *)imarg1; 
  arg2 = (floo::BMXRosterServiceListener *)imarg2; 
  (arg1)->removeRosterListener(arg2);
}

void* _wrap_new_BMXMessagePage__SWIG_0() {
  void* imresult = 0 ;
  floo::BMXResultPage< std::shared_ptr< floo::BMXMessage > > *result = 0 ;
  
  result = (floo::BMXResultPage< std::shared_ptr< floo::BMXMessage > > *)new floo::BMXResultPage< std::shared_ptr< floo::BMXMessage > >();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_BMXMessagePage__SWIG_1(void* imarg1, long long imarg2) {
  std::vector< std::shared_ptr< floo::BMXMessage > > *arg1 = 0 ;
  int64_t arg2 ;
  void* imresult = 0 ;
  floo::BMXResultPage< std::shared_ptr< floo::BMXMessage > > *result = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXMessage > > *)imarg1; 
  arg2 = (int64_t)imarg2; 
  result = (floo::BMXResultPage< std::shared_ptr< floo::BMXMessage > > *)new floo::BMXResultPage< std::shared_ptr< floo::BMXMessage > >((std::vector< std::shared_ptr< floo::BMXMessage > > const &)*arg1,arg2);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_BMXMessagePage__SWIG_2(void* imarg1, NSString* imarg2) {
  std::vector< std::shared_ptr< floo::BMXMessage > > *arg1 = 0 ;
  std::string arg2 ;
  void* imresult = 0 ;
  floo::BMXResultPage< std::shared_ptr< floo::BMXMessage > > *result = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXMessage > > *)imarg1; 
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  } 
  
  result = (floo::BMXResultPage< std::shared_ptr< floo::BMXMessage > > *)new floo::BMXResultPage< std::shared_ptr< floo::BMXMessage > >((std::vector< std::shared_ptr< floo::BMXMessage > > const &)*arg1,getStdString(imarg2));
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_BMXMessagePage__SWIG_3(void* imarg1) {
  floo::BMXResultPage< std::shared_ptr< floo::BMXMessage > > *arg1 = 0 ;
  void* imresult = 0 ;
  floo::BMXResultPage< std::shared_ptr< floo::BMXMessage > > *result = 0 ;
  
  arg1 = (floo::BMXResultPage< std::shared_ptr< floo::BMXMessage > > *)imarg1; 
  result = (floo::BMXResultPage< std::shared_ptr< floo::BMXMessage > > *)new floo::BMXResultPage< std::shared_ptr< floo::BMXMessage > >((floo::BMXResultPage< std::shared_ptr< floo::BMXMessage > > const &)*arg1);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_BMXMessagePage__SWIG_4(void* imarg1) {
    return 0;
}

void _wrap_delete_BMXMessagePage(void* imarg1) {
  floo::BMXResultPage< std::shared_ptr< floo::BMXMessage > > *arg1 = (floo::BMXResultPage< std::shared_ptr< floo::BMXMessage > > *) 0 ;
  
  arg1 = (floo::BMXResultPage< std::shared_ptr< floo::BMXMessage > > *)imarg1; 
  delete arg1;
}

unsigned long _wrap_BMXMessagePage_count(void* imarg1) {
  floo::BMXResultPage< std::shared_ptr< floo::BMXMessage > > *arg1 = (floo::BMXResultPage< std::shared_ptr< floo::BMXMessage > > *) 0 ;
  unsigned long imresult = 0 ;
  size_t result;
  
  arg1 = (floo::BMXResultPage< std::shared_ptr< floo::BMXMessage > > *)imarg1; 
  result = ((floo::BMXResultPage< std::shared_ptr< floo::BMXMessage > > const *)arg1)->count();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

long long _wrap_BMXMessagePage_offset(void* imarg1) {
  floo::BMXResultPage< std::shared_ptr< floo::BMXMessage > > *arg1 = (floo::BMXResultPage< std::shared_ptr< floo::BMXMessage > > *) 0 ;
  long long imresult = 0 ;
  int64_t result;
  
  arg1 = (floo::BMXResultPage< std::shared_ptr< floo::BMXMessage > > *)imarg1; 
  result = (int64_t)((floo::BMXResultPage< std::shared_ptr< floo::BMXMessage > > const *)arg1)->offset();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

NSString* _wrap_BMXMessagePage_cursor(void* imarg1) {
  floo::BMXResultPage< std::shared_ptr< floo::BMXMessage > > *arg1 = (floo::BMXResultPage< std::shared_ptr< floo::BMXMessage > > *) 0 ;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  arg1 = (floo::BMXResultPage< std::shared_ptr< floo::BMXMessage > > *)imarg1; 
  result = (std::string *) &((floo::BMXResultPage< std::shared_ptr< floo::BMXMessage > > const *)arg1)->cursor();
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void* _wrap_BMXMessagePage_result(void* imarg1) {
  floo::BMXResultPage< std::shared_ptr< floo::BMXMessage > > *arg1 = (floo::BMXResultPage< std::shared_ptr< floo::BMXMessage > > *) 0 ;
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXMessage > > *result = 0 ;
  
  arg1 = (floo::BMXResultPage< std::shared_ptr< floo::BMXMessage > > *)imarg1; 
  result = (std::vector< std::shared_ptr< floo::BMXMessage > > *) &((floo::BMXResultPage< std::shared_ptr< floo::BMXMessage > > const *)arg1)->result();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_BMXGroupMemberResultPage__SWIG_0() {
  void* imresult = 0 ;
  floo::BMXResultPage< BMXGroup::MemberPtr > *result = 0 ;
  
  result = (floo::BMXResultPage< BMXGroup::MemberPtr > *)new floo::BMXResultPage< BMXGroup::MemberPtr >();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_BMXGroupMemberResultPage__SWIG_1(void* imarg1, long long imarg2) {
    return 0;
}

void* _wrap_new_BMXGroupMemberResultPage__SWIG_2(void* imarg1, NSString* imarg2) {
    return 0;
}

void* _wrap_new_BMXGroupMemberResultPage__SWIG_3(void* imarg1) {
  floo::BMXResultPage< floo::BMXGroup::MemberPtr > *arg1 = 0 ;
  void* imresult = 0 ;
  floo::BMXResultPage< BMXGroup::MemberPtr > *result = 0 ;
  
  arg1 = (floo::BMXResultPage< floo::BMXGroup::MemberPtr > *)imarg1; 
  result = (floo::BMXResultPage< BMXGroup::MemberPtr > *)new floo::BMXResultPage< BMXGroup::MemberPtr >((floo::BMXResultPage< floo::BMXGroup::MemberPtr > const &)*arg1);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_BMXGroupMemberResultPage__SWIG_4(void* imarg1) {
    return 0;
}

void _wrap_delete_BMXGroupMemberResultPage(void* imarg1) {
  floo::BMXResultPage< BMXGroup::MemberPtr > *arg1 = (floo::BMXResultPage< BMXGroup::MemberPtr > *) 0 ;
  
  arg1 = (floo::BMXResultPage< BMXGroup::MemberPtr > *)imarg1; 
  delete arg1;
}

unsigned long _wrap_BMXGroupMemberResultPage_count(void* imarg1) {
  floo::BMXResultPage< BMXGroup::MemberPtr > *arg1 = (floo::BMXResultPage< BMXGroup::MemberPtr > *) 0 ;
  unsigned long imresult = 0 ;
  size_t result;
  
  arg1 = (floo::BMXResultPage< BMXGroup::MemberPtr > *)imarg1; 
  result = ((floo::BMXResultPage< BMXGroup::MemberPtr > const *)arg1)->count();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

long long _wrap_BMXGroupMemberResultPage_offset(void* imarg1) {
  floo::BMXResultPage< BMXGroup::MemberPtr > *arg1 = (floo::BMXResultPage< BMXGroup::MemberPtr > *) 0 ;
  long long imresult = 0 ;
  int64_t result;
  
  arg1 = (floo::BMXResultPage< BMXGroup::MemberPtr > *)imarg1; 
  result = (int64_t)((floo::BMXResultPage< BMXGroup::MemberPtr > const *)arg1)->offset();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

NSString* _wrap_BMXGroupMemberResultPage_cursor(void* imarg1) {
  floo::BMXResultPage< BMXGroup::MemberPtr > *arg1 = (floo::BMXResultPage< BMXGroup::MemberPtr > *) 0 ;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  arg1 = (floo::BMXResultPage< BMXGroup::MemberPtr > *)imarg1; 
  result = (std::string *) &((floo::BMXResultPage< BMXGroup::MemberPtr > const *)arg1)->cursor();
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void* _wrap_BMXGroupMemberResultPage_result(void* imarg1) {
  floo::BMXResultPage< BMXGroup::MemberPtr > *arg1 = (floo::BMXResultPage< BMXGroup::MemberPtr > *) 0 ;
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup::Member > > *result = 0 ;
  
  arg1 = (floo::BMXResultPage< BMXGroup::MemberPtr > *)imarg1; 
  result = (std::vector< std::shared_ptr< floo::BMXGroup::Member > > *) &((floo::BMXResultPage< BMXGroup::MemberPtr > const *)arg1)->result();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_BMXGroupBannedMemberResultPage__SWIG_0() {
  void* imresult = 0 ;
  floo::BMXResultPage< BMXGroup::BannedMemberPtr > *result = 0 ;
  
  result = (floo::BMXResultPage< BMXGroup::BannedMemberPtr > *)new floo::BMXResultPage< BMXGroup::BannedMemberPtr >();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_BMXGroupBannedMemberResultPage__SWIG_1(void* imarg1, long long imarg2) {
    return 0;
}

void* _wrap_new_BMXGroupBannedMemberResultPage__SWIG_2(void* imarg1, NSString* imarg2) {
  return 0;
}

void* _wrap_new_BMXGroupBannedMemberResultPage__SWIG_3(void* imarg1) {
  floo::BMXResultPage< floo::BMXGroup::BannedMemberPtr > *arg1 = 0 ;
  void* imresult = 0 ;
  floo::BMXResultPage< BMXGroup::BannedMemberPtr > *result = 0 ;
  
  arg1 = (floo::BMXResultPage< floo::BMXGroup::BannedMemberPtr > *)imarg1; 
  result = (floo::BMXResultPage< BMXGroup::BannedMemberPtr > *)new floo::BMXResultPage< BMXGroup::BannedMemberPtr >((floo::BMXResultPage< floo::BMXGroup::BannedMemberPtr > const &)*arg1);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_BMXGroupBannedMemberResultPage__SWIG_4(void* imarg1) {
    return 0;
}

void _wrap_delete_BMXGroupBannedMemberResultPage(void* imarg1) {
  floo::BMXResultPage< BMXGroup::BannedMemberPtr > *arg1 = (floo::BMXResultPage< BMXGroup::BannedMemberPtr > *) 0 ;
  
  arg1 = (floo::BMXResultPage< BMXGroup::BannedMemberPtr > *)imarg1; 
  delete arg1;
}

unsigned long _wrap_BMXGroupBannedMemberResultPage_count(void* imarg1) {
  floo::BMXResultPage< BMXGroup::BannedMemberPtr > *arg1 = (floo::BMXResultPage< BMXGroup::BannedMemberPtr > *) 0 ;
  unsigned long imresult = 0 ;
  size_t result;
  
  arg1 = (floo::BMXResultPage< BMXGroup::BannedMemberPtr > *)imarg1; 
  result = ((floo::BMXResultPage< BMXGroup::BannedMemberPtr > const *)arg1)->count();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

long long _wrap_BMXGroupBannedMemberResultPage_offset(void* imarg1) {
  floo::BMXResultPage< BMXGroup::BannedMemberPtr > *arg1 = (floo::BMXResultPage< BMXGroup::BannedMemberPtr > *) 0 ;
  long long imresult = 0 ;
  int64_t result;
  
  arg1 = (floo::BMXResultPage< BMXGroup::BannedMemberPtr > *)imarg1; 
  result = (int64_t)((floo::BMXResultPage< BMXGroup::BannedMemberPtr > const *)arg1)->offset();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

NSString* _wrap_BMXGroupBannedMemberResultPage_cursor(void* imarg1) {
  floo::BMXResultPage< BMXGroup::BannedMemberPtr > *arg1 = (floo::BMXResultPage< BMXGroup::BannedMemberPtr > *) 0 ;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  arg1 = (floo::BMXResultPage< BMXGroup::BannedMemberPtr > *)imarg1; 
  result = (std::string *) &((floo::BMXResultPage< BMXGroup::BannedMemberPtr > const *)arg1)->cursor();
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void* _wrap_BMXGroupBannedMemberResultPage_result(void* imarg1) {
  floo::BMXResultPage< BMXGroup::BannedMemberPtr > *arg1 = (floo::BMXResultPage< BMXGroup::BannedMemberPtr > *) 0 ;
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > > *result = 0 ;
  
  arg1 = (floo::BMXResultPage< BMXGroup::BannedMemberPtr > *)imarg1; 
  result = (std::vector< std::shared_ptr< floo::BMXGroup::BannedMember > > *) &((floo::BMXResultPage< BMXGroup::BannedMemberPtr > const *)arg1)->result();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_BMXRosterApplicationResultPage__SWIG_0() {
  void* imresult = 0 ;
  floo::BMXResultPage< std::shared_ptr< floo::BMXRosterService::Application > > *result = 0 ;
  
  result = (floo::BMXResultPage< std::shared_ptr< floo::BMXRosterService::Application > > *)new floo::BMXResultPage< std::shared_ptr< floo::BMXRosterService::Application > >();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_BMXRosterApplicationResultPage__SWIG_1(void* imarg1, long long imarg2) {
  std::vector< std::shared_ptr< floo::BMXRosterService::Application > > *arg1 = 0 ;
  int64_t arg2 ;
  void* imresult = 0 ;
  floo::BMXResultPage< std::shared_ptr< floo::BMXRosterService::Application > > *result = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXRosterService::Application > > *)imarg1; 
  arg2 = (int64_t)imarg2; 
  result = (floo::BMXResultPage< std::shared_ptr< floo::BMXRosterService::Application > > *)new floo::BMXResultPage< std::shared_ptr< floo::BMXRosterService::Application > >((std::vector< std::shared_ptr< floo::BMXRosterService::Application > > const &)*arg1,arg2);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_BMXRosterApplicationResultPage__SWIG_2(void* imarg1, NSString* imarg2) {
  std::vector< std::shared_ptr< floo::BMXRosterService::Application > > *arg1 = 0 ;
  std::string arg2 ;
  void* imresult = 0 ;
  floo::BMXResultPage< std::shared_ptr< floo::BMXRosterService::Application > > *result = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXRosterService::Application > > *)imarg1; 
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  } 
  
  result = (floo::BMXResultPage< std::shared_ptr< floo::BMXRosterService::Application > > *)new floo::BMXResultPage< std::shared_ptr< floo::BMXRosterService::Application > >((std::vector< std::shared_ptr< floo::BMXRosterService::Application > > const &)*arg1,getStdString(imarg2));
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_BMXRosterApplicationResultPage__SWIG_3(void* imarg1) {
  floo::BMXResultPage< std::shared_ptr< floo::BMXRosterService::Application > > *arg1 = 0 ;
  void* imresult = 0 ;
  floo::BMXResultPage< std::shared_ptr< floo::BMXRosterService::Application > > *result = 0 ;
  
  result = (floo::BMXResultPage< std::shared_ptr< floo::BMXRosterService::Application > > *)new floo::BMXResultPage< std::shared_ptr< floo::BMXRosterService::Application > >((floo::BMXResultPage< std::shared_ptr< floo::BMXRosterService::Application > > const &)*arg1);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_BMXRosterApplicationResultPage__SWIG_4(void* imarg1) {
  return 0;
}

void _wrap_delete_BMXRosterApplicationResultPage(void* imarg1) {
  long long larg1 = (long long)imarg1;
  std::shared_ptr< floo::BMXResultPage< std::shared_ptr< floo::BMXRosterService::Application > > > arg1 ;
  std::shared_ptr< floo::BMXResultPage< std::shared_ptr< floo::BMXRosterService::Application > > > *argp1 = *(std::shared_ptr< floo::BMXResultPage< std::shared_ptr< floo::BMXRosterService::Application > > > **)&larg1;
  if (argp1) arg1 = *argp1;
  
  delete argp1;
}

unsigned long _wrap_BMXRosterApplicationResultPage_count(void* imarg1) {
  long long larg1 = (long long)imarg1;
  std::shared_ptr< floo::BMXResultPage< std::shared_ptr< floo::BMXRosterService::Application > > > arg1 ;
  std::shared_ptr< floo::BMXResultPage< std::shared_ptr< floo::BMXRosterService::Application > > > *argp1 = *(std::shared_ptr< floo::BMXResultPage< std::shared_ptr< floo::BMXRosterService::Application > > > **)&larg1;
  if (argp1) arg1 = *argp1;
  unsigned long imresult = 0 ;
  size_t result;
  
  result = (arg1)->count();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

long long _wrap_BMXRosterApplicationResultPage_offset(void* imarg1) {
  long long larg1 = (long long)imarg1;
  std::shared_ptr< floo::BMXResultPage< std::shared_ptr< floo::BMXRosterService::Application > > > arg1 ;
  std::shared_ptr< floo::BMXResultPage< std::shared_ptr< floo::BMXRosterService::Application > > > *argp1 = *(std::shared_ptr< floo::BMXResultPage< std::shared_ptr< floo::BMXRosterService::Application > > > **)&larg1;
  if (argp1) arg1 = *argp1;
  long long imresult = 0 ;
  int64_t result;
  
  result = (int64_t)(arg1)->offset();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

NSString* _wrap_BMXRosterApplicationResultPage_cursor(void* imarg1) {
  long long larg1 = (long long)imarg1;
  std::shared_ptr< floo::BMXResultPage< std::shared_ptr< floo::BMXRosterService::Application > > > arg1 ;
  std::shared_ptr< floo::BMXResultPage< std::shared_ptr< floo::BMXRosterService::Application > > > *argp1 = *(std::shared_ptr< floo::BMXResultPage< std::shared_ptr< floo::BMXRosterService::Application > > > **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &(arg1)->cursor();
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void* _wrap_BMXRosterApplicationResultPage_result(void* imarg1) {
  long long larg1 = (long long)imarg1;
  std::shared_ptr< floo::BMXResultPage< std::shared_ptr< floo::BMXRosterService::Application > > > arg1 ;
  std::shared_ptr< floo::BMXResultPage< std::shared_ptr< floo::BMXRosterService::Application > > > *argp1 = *(std::shared_ptr< floo::BMXResultPage< std::shared_ptr< floo::BMXRosterService::Application > > > **)&larg1;
  if (argp1) arg1 = *argp1;
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXRosterService::Application > > *result = 0 ;
  
  result = (std::vector< std::shared_ptr< floo::BMXRosterService::Application > > *) &(arg1)->result();
  BMXRosterServiceApplicationList2Void(*result)
  imresult = (void*)lresult;
  return imresult;
}

void* _wrap_new_BMXGroupApplicationPage__SWIG_0() {
  void* imresult = 0 ;
  floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Application > > *result = 0 ;
  
  result = (floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Application > > *)new floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Application > >();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_BMXGroupApplicationPage__SWIG_1(void* imarg1, long long imarg2) {
  std::vector< std::shared_ptr< floo::BMXGroup::Application > > *arg1 = 0 ;
  int64_t arg2 ;
  void* imresult = 0 ;
  floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Application > > *result = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Application > > *)imarg1; 
  arg2 = (int64_t)imarg2; 
  result = (floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Application > > *)new floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Application > >((std::vector< std::shared_ptr< floo::BMXGroup::Application > > const &)*arg1,arg2);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_BMXGroupApplicationPage__SWIG_2(void* imarg1, NSString* imarg2) {
  std::vector< std::shared_ptr< floo::BMXGroup::Application > > *arg1 = 0 ;
  std::string arg2 ;
  void* imresult = 0 ;
  floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Application > > *result = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Application > > *)imarg1; 
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  } 
  
  result = (floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Application > > *)new floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Application > >((std::vector< std::shared_ptr< floo::BMXGroup::Application > > const &)*arg1,getStdString(imarg2));
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_BMXGroupApplicationPage__SWIG_3(void* imarg1) {
  floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Application > > *arg1 = 0 ;
  void* imresult = 0 ;
  floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Application > > *result = 0 ;
  
  result = (floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Application > > *)new floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Application > >((floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Application > > const &)*arg1);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_BMXGroupApplicationPage__SWIG_4(void* imarg1) {
    return 0;
}

void _wrap_delete_BMXGroupApplicationPage(void* imarg1) {
  long long larg1 = (long long)imarg1;
  std::shared_ptr< floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Application > > > arg1 ;
  std::shared_ptr< floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Application > > > *argp1 = *(std::shared_ptr< floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Application > > > **)&larg1;
  if (argp1) arg1 = *argp1;
  
  delete argp1;
}

unsigned long _wrap_BMXGroupApplicationPage_count(void* imarg1) {
  long long larg1 = (long long)imarg1;
  std::shared_ptr< floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Application > > > arg1 ;
  std::shared_ptr< floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Application > > > *argp1 = *(std::shared_ptr< floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Application > > > **)&larg1;
  if (argp1) arg1 = *argp1;
  unsigned long imresult = 0 ;
  size_t result;
  
  result = (arg1)->count();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

long long _wrap_BMXGroupApplicationPage_offset(void* imarg1) {
  long long larg1 = (long long)imarg1;
  std::shared_ptr< floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Application > > > arg1 ;
  std::shared_ptr< floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Application > > > *argp1 = *(std::shared_ptr< floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Application > > > **)&larg1;
  if (argp1) arg1 = *argp1;
  long long imresult = 0 ;
  int64_t result;
  
  result = (int64_t)(arg1)->offset();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

NSString* _wrap_BMXGroupApplicationPage_cursor(void* imarg1) {
  long long larg1 = (long long)imarg1;
  std::shared_ptr< floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Application > > > arg1 ;
  std::shared_ptr< floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Application > > > *argp1 = *(std::shared_ptr< floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Application > > > **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &(arg1)->cursor();
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void* _wrap_BMXGroupApplicationPage_result(void* imarg1) {
  long long larg1 = (long long)imarg1;
  std::shared_ptr< floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Application > > > arg1 ;
  std::shared_ptr< floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Application > > > *argp1 = *(std::shared_ptr< floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Application > > > **)&larg1;
  if (argp1) arg1 = *argp1;
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup::Application > > *result = 0 ;
  
  result = (std::vector< std::shared_ptr< floo::BMXGroup::Application > > *) &(arg1)->result();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_BMXGroupInvitationPage__SWIG_0() {
  void* imresult = 0 ;
  floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Invitation > > *result = 0 ;
  
  result = (floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Invitation > > *)new floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Invitation > >();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_BMXGroupInvitationPage__SWIG_1(void* imarg1, long long imarg2) {
  std::vector< std::shared_ptr< floo::BMXGroup::Invitation > > *arg1 = 0 ;
  int64_t arg2 ;
  void* imresult = 0 ;
  floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Invitation > > *result = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Invitation > > *)imarg1; 
  arg2 = (int64_t)imarg2; 
  result = (floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Invitation > > *)new floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Invitation > >((std::vector< std::shared_ptr< floo::BMXGroup::Invitation > > const &)*arg1,arg2);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_BMXGroupInvitationPage__SWIG_2(void* imarg1, NSString* imarg2) {
  std::vector< std::shared_ptr< floo::BMXGroup::Invitation > > *arg1 = 0 ;
  std::string arg2 ;
  void* imresult = 0 ;
  floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Invitation > > *result = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXGroup::Invitation > > *)imarg1; 
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  } 

  result = (floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Invitation > > *)new floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Invitation > >((std::vector< std::shared_ptr< floo::BMXGroup::Invitation > > const &)*arg1,getStdString(imarg2));
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_BMXGroupInvitationPage__SWIG_3(void* imarg1) {
  floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Invitation > > *arg1 = 0 ;
  void* imresult = 0 ;
  floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Invitation > > *result = 0 ;
  
  result = (floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Invitation > > *)new floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Invitation > >((floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Invitation > > const &)*arg1);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_BMXGroupInvitationPage__SWIG_4(void* imarg1) {
    return 0;
}

void _wrap_delete_BMXGroupInvitationPage(void* imarg1) {
  long long larg1 = (long long)imarg1;
  std::shared_ptr< floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Invitation > > > arg1 ;
  std::shared_ptr< floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Invitation > > > *argp1 = *(std::shared_ptr< floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Invitation > > > **)&larg1;
  if (argp1) arg1 = *argp1;
  
  delete argp1;
}

unsigned long _wrap_BMXGroupInvitationPage_count(void* imarg1) {
  long long larg1 = (long long)imarg1;
  std::shared_ptr< floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Invitation > > > arg1 ;
  std::shared_ptr< floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Invitation > > > *argp1 = *(std::shared_ptr< floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Invitation > > > **)&larg1;
  if (argp1) arg1 = *argp1;
  unsigned long imresult = 0 ;
  size_t result;
  
  result = (arg1)->count();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

long long _wrap_BMXGroupInvitationPage_offset(void* imarg1) {
  long long larg1 = (long long)imarg1;
  std::shared_ptr< floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Invitation > > > arg1 ;
  std::shared_ptr< floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Invitation > > > *argp1 = *(std::shared_ptr< floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Invitation > > > **)&larg1;
  if (argp1) arg1 = *argp1;
  long long imresult = 0 ;
  int64_t result;
  
  result = (int64_t)(arg1)->offset();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

NSString* _wrap_BMXGroupInvitationPage_cursor(void* imarg1) {
  long long larg1 = (long long)imarg1;
  std::shared_ptr< floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Invitation > > > arg1 ;
  std::shared_ptr< floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Invitation > > > *argp1 = *(std::shared_ptr< floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Invitation > > > **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &(arg1)->cursor();
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void* _wrap_BMXGroupInvitationPage_result(void* imarg1) {
  long long larg1 = (long long)imarg1;
  std::shared_ptr< floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Invitation > > > arg1 ;
  std::shared_ptr< floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Invitation > > > *argp1 = *(std::shared_ptr< floo::BMXResultPage< std::shared_ptr< floo::BMXGroup::Invitation > > > **)&larg1;
  if (argp1) arg1 = *argp1;
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXGroup::Invitation > > *result = 0 ;
  
  result = (std::vector< std::shared_ptr< floo::BMXGroup::Invitation > > *) &(arg1)->result();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_BMXMessageListList__SWIG_0() {
  void* imresult = 0 ;
  std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > > *result = 0 ;
  
  result = (std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > > *)new std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > >();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_BMXMessageListList__SWIG_1(unsigned long imarg1) {
  std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > >::size_type arg1 ;
  void* imresult = 0 ;
  std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > > *result = 0 ;
  
  arg1 = (std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > >::size_type)imarg1; 
  result = (std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > > *)new std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > >(arg1);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

unsigned long _wrap_BMXMessageListList_size(void* imarg1) {
  std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > > *arg1 = (std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > > *) 0 ;
  unsigned long imresult = 0 ;
  std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > >::size_type result;
  
  arg1 = (std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > > *)imarg1; 
  result = ((std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > > const *)arg1)->size();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

unsigned long _wrap_BMXMessageListList_capacity(void* imarg1) {
  std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > > *arg1 = (std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > > *) 0 ;
  unsigned long imresult = 0 ;
  std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > >::size_type result;
  
  arg1 = (std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > > *)imarg1; 
  result = ((std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > > const *)arg1)->capacity();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXMessageListList_reserve(void* imarg1, unsigned long imarg2) {
  std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > > *arg1 = (std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > > *) 0 ;
  std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > >::size_type arg2 ;
  
  arg1 = (std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > > *)imarg1; 
  arg2 = (std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > >::size_type)imarg2; 
  (arg1)->reserve(arg2);
}

BOOL _wrap_BMXMessageListList_isEmpty(void* imarg1) {
  std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > > *arg1 = (std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > > *) 0 ;
  BOOL imresult = 0 ;
  bool result;
  
  arg1 = (std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > > *)imarg1; 
  result = (bool)((std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > > const *)arg1)->empty();
  imresult = (result)? YES:NO; 
  return imresult;
}

void _wrap_BMXMessageListList_clear(void* imarg1) {
  std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > > *arg1 = (std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > > *) 0 ;
  
  arg1 = (std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > > *)imarg1; 
  (arg1)->clear();
}

void _wrap_BMXMessageListList_add(void* imarg1, void* imarg2) {
  std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > > *arg1 = (std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > > *) 0 ;
  std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > >::value_type *arg2 = 0 ;
  
  arg1 = (std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > > *)imarg1; 
  arg2 = (std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > >::value_type *)imarg2; 
  (arg1)->push_back((std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > >::value_type const &)*arg2);
}

void* _wrap_BMXMessageListList_get(void* imarg1, int imarg2) {
  std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > > *arg1 = (std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > > *) 0 ;
  int arg2 ;
  void* imresult = 0 ;
  std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > >::value_type *result = 0 ;
  
  arg1 = (std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > > *)imarg1; 
  arg2 = (int)imarg2; 
  try {
    result = (std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > >::value_type *) &std_vector_Sl_std_vector_Sl_std_shared_ptr_Sl_floo_BMXMessage_Sg__Sg__Sg__get(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_ObjcThrowException(SWIG_ObjcIndexOutOfBoundsException, (&_e)->what());
    return 0;
  }
  
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXMessageListList_set(void* imarg1, int imarg2, void* imarg3) {
  std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > > *arg1 = (std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > > *) 0 ;
  int arg2 ;
  std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > >::value_type *arg3 = 0 ;
  
  arg1 = (std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > > *)imarg1; 
  arg2 = (int)imarg2; 
  arg3 = (std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > >::value_type *)imarg3; 
  try {
    std_vector_Sl_std_vector_Sl_std_shared_ptr_Sl_floo_BMXMessage_Sg__Sg__Sg__set(arg1,arg2,(std::vector< std::shared_ptr< floo::BMXMessage > > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_ObjcThrowException(SWIG_ObjcIndexOutOfBoundsException, (&_e)->what());
    return ;
  }
  
}

void _wrap_delete_BMXMessageListList(void* imarg1) {
  std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > > *arg1 = (std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > > *) 0 ;
  
  arg1 = (std::vector< std::vector< std::shared_ptr< floo::BMXMessage > > > *)imarg1; 
  delete arg1;
}

void _wrap_delete_BMXRosterItem(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRosterItemPtr arg1 ;
  floo::BMXRosterItemPtr *argp1 = *(floo::BMXRosterItemPtr **)&larg1;
  delete argp1;
}

long long _wrap_BMXRosterItem_rosterId(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRosterItemPtr arg1 ;
  floo::BMXRosterItemPtr *argp1 = *(floo::BMXRosterItemPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  long long imresult = 0 ;
  int64_t result;
  
  result = (int64_t)(arg1)->rosterId();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

NSString* _wrap_BMXRosterItem_username(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRosterItemPtr arg1 ;
  floo::BMXRosterItemPtr *argp1 = *(floo::BMXRosterItemPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &(arg1)->username();
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_BMXRosterItem_nickname(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRosterItemPtr arg1 ;
  floo::BMXRosterItemPtr *argp1 = *(floo::BMXRosterItemPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &(arg1)->nickname();
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_BMXRosterItem_avatarRatelUrl(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRosterItemPtr arg1 ;
  floo::BMXRosterItemPtr *argp1 = *(floo::BMXRosterItemPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string result;
  
  result = (arg1)->avatarRatelUrl();
  imresult = [NSString stringWithUTF8String: (&result)->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_BMXRosterItem_avatarUrl(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRosterItemPtr arg1 ;
  floo::BMXRosterItemPtr *argp1 = *(floo::BMXRosterItemPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string result;
  
  result = (arg1)->avatarUrl();
  imresult = [NSString stringWithUTF8String: (&result)->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_BMXRosterItem_avatarPath(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRosterItemPtr arg1 ;
  floo::BMXRosterItemPtr *argp1 = *(floo::BMXRosterItemPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string result;
  
  result = (arg1)->avatarPath();
  imresult = [NSString stringWithUTF8String: (&result)->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_BMXRosterItem_avatarThumbnailUrl(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRosterItemPtr arg1 ;
  floo::BMXRosterItemPtr *argp1 = *(floo::BMXRosterItemPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string result;
  
  result = (arg1)->avatarThumbnailUrl();
  imresult = [NSString stringWithUTF8String: (&result)->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_BMXRosterItem_avatarThumbnailPath(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRosterItemPtr arg1 ;
  floo::BMXRosterItemPtr *argp1 = *(floo::BMXRosterItemPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string result;
  
  result = (arg1)->avatarThumbnailPath();
  imresult = [NSString stringWithUTF8String: (&result)->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_BMXRosterItem_publicInfo(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRosterItemPtr arg1 ;
  floo::BMXRosterItemPtr *argp1 = *(floo::BMXRosterItemPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  floo::JSON *result = 0 ;
  
  result = (floo::JSON *) &(arg1)->publicInfo();
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_BMXRosterItem_alias(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRosterItemPtr arg1 ;
  floo::BMXRosterItemPtr *argp1 = *(floo::BMXRosterItemPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  floo::JSON *result = 0 ;
  
  result = (floo::JSON *) &(arg1)->alias();
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_BMXRosterItem_ext(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRosterItemPtr arg1 ;
  floo::BMXRosterItemPtr *argp1 = *(floo::BMXRosterItemPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  floo::JSON *result = 0 ;
  
  result = (floo::JSON *) &(arg1)->ext();
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_BMXRosterItem_localExt(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRosterItemPtr arg1 ;
  floo::BMXRosterItemPtr *argp1 = *(floo::BMXRosterItemPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  floo::JSON *result = 0 ;
  
  result = (floo::JSON *) &(arg1)->localExt();
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

int _wrap_BMXRosterItem_relation(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRosterItemPtr arg1 ;
  floo::BMXRosterItemPtr *argp1 = *(floo::BMXRosterItemPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  floo::BMXRosterItem::RosterRelation result;
  
  result = (floo::BMXRosterItem::RosterRelation)(arg1)->relation();
  imresult = (int)result; 
  return imresult;
}

BOOL _wrap_BMXRosterItem_isMuteNotification(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRosterItemPtr arg1 ;
  floo::BMXRosterItemPtr *argp1 = *(floo::BMXRosterItemPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BOOL imresult = 0 ;
  bool result;
  
  result = (bool)(arg1)->isMuteNotification();
  imresult = (result)? YES:NO; 
  return imresult;
}

int _wrap_BMXRosterItem_addFriendAuthMode(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRosterItemPtr arg1 ;
  floo::BMXRosterItemPtr *argp1 = *(floo::BMXRosterItemPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  floo::BMXRosterItem::AddFriendAuthMode result;
  
  result = (floo::BMXRosterItem::AddFriendAuthMode)(arg1)->addFriendAuthMode();
  imresult = (int)result; 
  return imresult;
}

NSString* _wrap_BMXRosterItem_authQuestion(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXRosterItemPtr arg1 ;
  floo::BMXRosterItemPtr *argp1 = *(floo::BMXRosterItemPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &(arg1)->authQuestion();
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void* _wrap_new_BMXRosterItemList__SWIG_0() {
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXRosterItem > > *result = 0 ;
  
  result = (std::vector< std::shared_ptr< floo::BMXRosterItem > > *)new std::vector< std::shared_ptr< floo::BMXRosterItem > >();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_BMXRosterItemList__SWIG_1(unsigned long imarg1) {
  std::vector< std::shared_ptr< floo::BMXRosterItem > >::size_type arg1 ;
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXRosterItem > > *result = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXRosterItem > >::size_type)imarg1; 
  result = (std::vector< std::shared_ptr< floo::BMXRosterItem > > *)new std::vector< std::shared_ptr< floo::BMXRosterItem > >(arg1);
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

unsigned long _wrap_BMXRosterItemList_size(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXRosterItem > > *arg1 = (std::vector< std::shared_ptr< floo::BMXRosterItem > > *) 0 ;
  unsigned long imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXRosterItem > >::size_type result;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXRosterItem > > *)imarg1; 
  result = ((std::vector< std::shared_ptr< floo::BMXRosterItem > > const *)arg1)->size();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

unsigned long _wrap_BMXRosterItemList_capacity(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXRosterItem > > *arg1 = (std::vector< std::shared_ptr< floo::BMXRosterItem > > *) 0 ;
  unsigned long imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXRosterItem > >::size_type result;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXRosterItem > > *)imarg1; 
  result = ((std::vector< std::shared_ptr< floo::BMXRosterItem > > const *)arg1)->capacity();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXRosterItemList_reserve(void* imarg1, unsigned long imarg2) {
  std::vector< std::shared_ptr< floo::BMXRosterItem > > *arg1 = (std::vector< std::shared_ptr< floo::BMXRosterItem > > *) 0 ;
  std::vector< std::shared_ptr< floo::BMXRosterItem > >::size_type arg2 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXRosterItem > > *)imarg1; 
  arg2 = (std::vector< std::shared_ptr< floo::BMXRosterItem > >::size_type)imarg2; 
  (arg1)->reserve(arg2);
}

BOOL _wrap_BMXRosterItemList_isEmpty(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXRosterItem > > *arg1 = (std::vector< std::shared_ptr< floo::BMXRosterItem > > *) 0 ;
  BOOL imresult = 0 ;
  bool result;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXRosterItem > > *)imarg1; 
  result = (bool)((std::vector< std::shared_ptr< floo::BMXRosterItem > > const *)arg1)->empty();
  imresult = (result)? YES:NO; 
  return imresult;
}

void _wrap_BMXRosterItemList_clear(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXRosterItem > > *arg1 = (std::vector< std::shared_ptr< floo::BMXRosterItem > > *) 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXRosterItem > > *)imarg1; 
  (arg1)->clear();
}

void _wrap_BMXRosterItemList_add(void* imarg1, void* imarg2) {
  std::vector< std::shared_ptr< floo::BMXRosterItem > > *arg1 = (std::vector< std::shared_ptr< floo::BMXRosterItem > > *) 0 ;
  std::vector< std::shared_ptr< floo::BMXRosterItem > >::value_type *arg2 = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXRosterItem > > *)imarg1; 
  arg2 = (std::vector< std::shared_ptr< floo::BMXRosterItem > >::value_type *)imarg2; 
  (arg1)->push_back((std::vector< std::shared_ptr< floo::BMXRosterItem > >::value_type const &)*arg2);
}

void* _wrap_BMXRosterItemList_get(void* imarg1, int imarg2) {
  std::vector< std::shared_ptr< floo::BMXRosterItem > > *arg1 = (std::vector< std::shared_ptr< floo::BMXRosterItem > > *) 0 ;
  int arg2 ;
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXRosterItem > >::value_type *result = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXRosterItem > > *)imarg1; 
  arg2 = (int)imarg2; 
  try {
    result = (std::vector< std::shared_ptr< floo::BMXRosterItem > >::value_type *) &std_vector_Sl_std_shared_ptr_Sl_floo_BMXRosterItem_Sg__Sg__get(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_ObjcThrowException(SWIG_ObjcIndexOutOfBoundsException, (&_e)->what());
    return 0;
  }
  BMXRosterItem2Void(*result)
  imresult = (void*)lresult;
  return imresult;
}

void _wrap_BMXRosterItemList_set(void* imarg1, int imarg2, void* imarg3) {
  std::vector< std::shared_ptr< floo::BMXRosterItem > > *arg1 = (std::vector< std::shared_ptr< floo::BMXRosterItem > > *) 0 ;
  int arg2 ;
  std::vector< std::shared_ptr< floo::BMXRosterItem > >::value_type *arg3 = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXRosterItem > > *)imarg1; 
  arg2 = (int)imarg2; 
  arg3 = (std::vector< std::shared_ptr< floo::BMXRosterItem > >::value_type *)imarg3; 
  try {
    std_vector_Sl_std_shared_ptr_Sl_floo_BMXRosterItem_Sg__Sg__set(arg1,arg2,(std::shared_ptr< floo::BMXRosterItem > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_ObjcThrowException(SWIG_ObjcIndexOutOfBoundsException, (&_e)->what());
    return ;
  }
  
}

void _wrap_delete_BMXRosterItemList(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXRosterItem > > *arg1 = (std::vector< std::shared_ptr< floo::BMXRosterItem > > *) 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXRosterItem > > *)imarg1; 
  delete arg1;
}

void* _wrap_new_BMXRosterServiceListener() {
  void* imresult = 0 ;
  floo::BMXRosterServiceListener *result = 0 ;
  
  result = (floo::BMXRosterServiceListener *)new floo::BMXRosterServiceListener();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_delete_BMXRosterServiceListener(void* imarg1) {
  floo::BMXRosterServiceListener *arg1 = (floo::BMXRosterServiceListener *) 0 ;
  
  arg1 = (floo::BMXRosterServiceListener *)imarg1; 
  delete arg1;
}

void _wrap_BMXRosterServiceListener_onFriendAdded(void* imarg1, long long imarg2, long long imarg3) {
  floo::BMXRosterServiceListener *arg1 = (floo::BMXRosterServiceListener *) 0 ;
  int64_t arg2 ;
  int64_t arg3 ;
  
  arg1 = (floo::BMXRosterServiceListener *)imarg1; 
  arg2 = (int64_t)imarg2; 
  arg3 = (int64_t)imarg3; 
  (arg1)->onFriendAdded(arg2,arg3);
}

void _wrap_BMXRosterServiceListener_onFriendRemoved(void* imarg1, long long imarg2, long long imarg3) {
  floo::BMXRosterServiceListener *arg1 = (floo::BMXRosterServiceListener *) 0 ;
  int64_t arg2 ;
  int64_t arg3 ;
  
  arg1 = (floo::BMXRosterServiceListener *)imarg1; 
  arg2 = (int64_t)imarg2; 
  arg3 = (int64_t)imarg3; 
  (arg1)->onFriendRemoved(arg2,arg3);
}

void _wrap_BMXRosterServiceListener_onApplied(void* imarg1, long long imarg2, long long imarg3, NSString* imarg4) {
  floo::BMXRosterServiceListener *arg1 = (floo::BMXRosterServiceListener *) 0 ;
  int64_t arg2 ;
  int64_t arg3 ;
  std::string *arg4 = 0 ;
  
  arg1 = (floo::BMXRosterServiceListener *)imarg1; 
  arg2 = (int64_t)imarg2; 
  arg3 = (int64_t)imarg3; 
  if(!imarg4) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg4_str(getStdString(imarg4));
  arg4 = &arg4_str; 
  
  (arg1)->onApplied(arg2,arg3,(std::string const &)*arg4);
}

void _wrap_BMXRosterServiceListener_onApplicationAccepted(void* imarg1, long long imarg2, long long imarg3) {
  floo::BMXRosterServiceListener *arg1 = (floo::BMXRosterServiceListener *) 0 ;
  int64_t arg2 ;
  int64_t arg3 ;
  
  arg1 = (floo::BMXRosterServiceListener *)imarg1; 
  arg2 = (int64_t)imarg2; 
  arg3 = (int64_t)imarg3; 
  (arg1)->onApplicationAccepted(arg2,arg3);
}

void _wrap_BMXRosterServiceListener_onApplicationDeclined(void* imarg1, long long imarg2, long long imarg3, NSString* imarg4) {
  floo::BMXRosterServiceListener *arg1 = (floo::BMXRosterServiceListener *) 0 ;
  int64_t arg2 ;
  int64_t arg3 ;
  std::string *arg4 = 0 ;
  
  arg1 = (floo::BMXRosterServiceListener *)imarg1; 
  arg2 = (int64_t)imarg2; 
  arg3 = (int64_t)imarg3; 
  if(!imarg4) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg4_str(getStdString(imarg4));
  arg4 = &arg4_str; 
  
  (arg1)->onApplicationDeclined(arg2,arg3,(std::string const &)*arg4);
}

void _wrap_BMXRosterServiceListener_onBlockListAdded(void* imarg1, long long imarg2, long long imarg3) {
  floo::BMXRosterServiceListener *arg1 = (floo::BMXRosterServiceListener *) 0 ;
  int64_t arg2 ;
  int64_t arg3 ;
  
  arg1 = (floo::BMXRosterServiceListener *)imarg1; 
  arg2 = (int64_t)imarg2; 
  arg3 = (int64_t)imarg3; 
  (arg1)->onBlockListAdded(arg2,arg3);
}

void _wrap_BMXRosterServiceListener_onBlockListRemoved(void* imarg1, long long imarg2, long long imarg3) {
  floo::BMXRosterServiceListener *arg1 = (floo::BMXRosterServiceListener *) 0 ;
  int64_t arg2 ;
  int64_t arg3 ;
  
  arg1 = (floo::BMXRosterServiceListener *)imarg1; 
  arg2 = (int64_t)imarg2; 
  arg3 = (int64_t)imarg3; 
  (arg1)->onBlockListRemoved(arg2,arg3);
}

void _wrap_BMXRosterServiceListener_onRosterInfoUpdate(void* imarg1, void* imarg2) {
  floo::BMXRosterServiceListener *arg1 = (floo::BMXRosterServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXRosterItem > > arg2 ;
  floo::BMXRosterItemPtr *argp2 ;
  
  arg1 = (floo::BMXRosterServiceListener *)imarg1; 
  
  argp2 = (floo::BMXRosterItemPtr *)imarg2;
  arg2 = *argp2; 
  
  (arg1)->onRosterInfoUpdate(arg2);
}

void _wrap_BMXRosterServiceListener_onRosterListUpdate(void* imarg1) {
  floo::BMXRosterServiceListener *arg1 = (floo::BMXRosterServiceListener *) 0 ;
  
  arg1 = (floo::BMXRosterServiceListener *)imarg1; 
  (arg1)->onRosterListUpdate();
}

void _wrap_BMXRosterServiceListener_registerRosterService(void* imarg1, void* imarg2) {
  floo::BMXRosterServiceListener *arg1 = (floo::BMXRosterServiceListener *) 0 ;
  floo::BMXRosterService *arg2 = (floo::BMXRosterService *) 0 ;
  
  arg1 = (floo::BMXRosterServiceListener *)imarg1; 
  arg2 = (floo::BMXRosterService *)imarg2; 
  (arg1)->registerRosterService(arg2);
}

void _wrap_delete_BMXUserProfile(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXUserProfilePtr arg1 ;
  floo::BMXUserProfilePtr *argp1 = *(floo::BMXUserProfilePtr **)&larg1;
  delete argp1;
}

long long _wrap_BMXUserProfile_userId(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXUserProfilePtr arg1 ;
  floo::BMXUserProfilePtr *argp1 = *(floo::BMXUserProfilePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  long long imresult = 0 ;
  int64_t result;
  
  result = (int64_t)(arg1)->userId();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

int _wrap_BMXUserProfile_category(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXUserProfilePtr arg1 ;
  floo::BMXUserProfilePtr *argp1 = *(floo::BMXUserProfilePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  floo::BMXUserProfile::UserCategory result;
  
  result = (floo::BMXUserProfile::UserCategory)(arg1)->category();
  imresult = (int)result; 
  return imresult;
}

NSString* _wrap_BMXUserProfile_username(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXUserProfilePtr arg1 ;
  floo::BMXUserProfilePtr *argp1 = *(floo::BMXUserProfilePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &(arg1)->username();
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_BMXUserProfile_nickname(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXUserProfilePtr arg1 ;
  floo::BMXUserProfilePtr *argp1 = *(floo::BMXUserProfilePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &(arg1)->nickname();
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_BMXUserProfile_avatarRatelUrl(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXUserProfilePtr arg1 ;
  floo::BMXUserProfilePtr *argp1 = *(floo::BMXUserProfilePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string result;
  
  result = (arg1)->avatarRatelUrl();
  imresult = [NSString stringWithUTF8String: (&result)->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_BMXUserProfile_avatarUrl(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXUserProfilePtr arg1 ;
  floo::BMXUserProfilePtr *argp1 = *(floo::BMXUserProfilePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string result;
  
  result = (arg1)->avatarUrl();
  imresult = [NSString stringWithUTF8String: (&result)->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_BMXUserProfile_avatarPath(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXUserProfilePtr arg1 ;
  floo::BMXUserProfilePtr *argp1 = *(floo::BMXUserProfilePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string result;
  
  result = (arg1)->avatarPath();
  imresult = [NSString stringWithUTF8String: (&result)->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_BMXUserProfile_avatarThumbnailPath(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXUserProfilePtr arg1 ;
  floo::BMXUserProfilePtr *argp1 = *(floo::BMXUserProfilePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string result;
  
  result = (arg1)->avatarThumbnailPath();
  imresult = [NSString stringWithUTF8String: (&result)->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_BMXUserProfile_mobilePhone(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXUserProfilePtr arg1 ;
  floo::BMXUserProfilePtr *argp1 = *(floo::BMXUserProfilePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &(arg1)->mobilePhone();
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_BMXUserProfile_email(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXUserProfilePtr arg1 ;
  floo::BMXUserProfilePtr *argp1 = *(floo::BMXUserProfilePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &(arg1)->email();
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_BMXUserProfile_publicInfo(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXUserProfilePtr arg1 ;
  floo::BMXUserProfilePtr *argp1 = *(floo::BMXUserProfilePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  floo::JSON *result = 0 ;
  
  result = (floo::JSON *) &(arg1)->publicInfo();
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_BMXUserProfile_privateInfo(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXUserProfilePtr arg1 ;
  floo::BMXUserProfilePtr *argp1 = *(floo::BMXUserProfilePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  floo::JSON *result = 0 ;
  
  result = (floo::JSON *) &(arg1)->privateInfo();
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

int _wrap_BMXUserProfile_addFriendAuthMode(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXUserProfilePtr arg1 ;
  floo::BMXUserProfilePtr *argp1 = *(floo::BMXUserProfilePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  floo::BMXUserProfile::AddFriendAuthMode result;
  
  result = (floo::BMXUserProfile::AddFriendAuthMode)(arg1)->addFriendAuthMode();
  imresult = (int)result; 
  return imresult;
}

void* _wrap_BMXUserProfile_authQuestion(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXUserProfilePtr arg1 ;
  floo::BMXUserProfilePtr *argp1 = *(floo::BMXUserProfilePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  void* imresult = 0 ;
  BMXUserProfileAuthQuestion *result = 0 ;
  
  result = (BMXUserProfileAuthQuestion *) &(arg1)->authQuestion();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_BMXUserProfile_messageSetting(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXUserProfilePtr arg1 ;
  floo::BMXUserProfilePtr *argp1 = *(floo::BMXUserProfilePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  void* imresult = 0 ;
  BMXUserProfileMessageSetting *result = 0 ;
  
  result = (BMXUserProfileMessageSetting *) &(arg1)->messageSetting();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

BOOL _wrap_BMXUserProfile_isAutoAcceptGroupInvite(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXUserProfilePtr arg1 ;
  floo::BMXUserProfilePtr *argp1 = *(floo::BMXUserProfilePtr **)&larg1;
  if (argp1) arg1 = *argp1;
  BOOL imresult = 0 ;
  bool result;
  
  result = (bool)(arg1)->isAutoAcceptGroupInvite();
  imresult = (result)? YES:NO; 
  return imresult;
}

void _wrap_delete_BMXUserService(void* imarg1) {
  floo::BMXUserService *arg1 = (floo::BMXUserService *) 0 ;
  
  arg1 = (floo::BMXUserService *)imarg1; 
  delete arg1;
}

int _wrap_BMXUserService_bindDevice(void* imarg1, NSString* imarg2) {
  floo::BMXUserService *arg1 = (floo::BMXUserService *) 0 ;
  std::string *arg2 = 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXUserService *)imarg1; 
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  result = (floo::BMXErrorCode)(arg1)->bindDevice((std::string const &)*arg2);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXUserService_getDeviceList(void* imarg1, void* imarg2) {
  floo::BMXUserService *arg1 = (floo::BMXUserService *) 0 ;
  floo::BMXDeviceList *arg2 = 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXUserService *)imarg1; 
  arg2 = (floo::BMXDeviceList *)imarg2; 
  result = (floo::BMXErrorCode)(arg1)->getDeviceList(*arg2);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXUserService_deleteDevice(void* imarg1, int imarg2) {
  floo::BMXUserService *arg1 = (floo::BMXUserService *) 0 ;
  int32_t arg2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXUserService *)imarg1; 
  arg2 = (int32_t)imarg2; 
  result = (floo::BMXErrorCode)(arg1)->deleteDevice(arg2);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXUserService_getProfile(void* imarg1, void** imarg2, BOOL imarg3) {
  floo::BMXUserService *arg1 = (floo::BMXUserService *) 0 ;
  floo::BMXUserProfilePtr arg2;
  bool arg3 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXUserService *)imarg1; 
  arg3 = imarg3? true : false;
  result = (floo::BMXErrorCode)(arg1)->getProfile(arg2,arg3);

  BMXUserProfile2Void(arg2)
  *imarg2 = (void*)lresult;

  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXUserService_setNickname(void* imarg1, NSString* imarg2) {
  floo::BMXUserService *arg1 = (floo::BMXUserService *) 0 ;
  std::string *arg2 = 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXUserService *)imarg1; 
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  result = (floo::BMXErrorCode)(arg1)->setNickname((std::string const &)*arg2);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXUserService_uploadAvatar(void* imarg1, NSString* imarg2, void* imarg3) {
  floo::BMXUserService *arg1 = (floo::BMXUserService *) 0 ;
  std::string *arg2 = 0 ;
  floo::BMXUserService::Callback arg3 ;
  floo::BMXUserService::Callback *argp3 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXUserService *)imarg1; 
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  
  argp3 = (floo::BMXUserService::Callback *)imarg3;
  arg3 = nullptr;
  
  result = (floo::BMXErrorCode)(arg1)->uploadAvatar((std::string const &)*arg2,arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXUserService_downloadAvatar(void* imarg1, void* imarg2, BOOL imarg3, void* imarg4) {
  floo::BMXUserService *arg1 = (floo::BMXUserService *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXUserProfile > > arg2 ;
  bool arg3 ;
  floo::BMXUserService::Callback arg4 ;
  floo::BMXUserProfilePtr *argp2 ;
  floo::BMXUserService::Callback *argp4 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXUserService *)imarg1; 
  
  argp2 = (floo::BMXUserProfilePtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = imarg3? true : false; 
  
  argp4 = (floo::BMXUserService::Callback *)imarg4;
  arg4 = nullptr;
  
  result = (floo::BMXErrorCode)(arg1)->downloadAvatar(arg2,arg3,arg4);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXUserService_setPublicInfo(void* imarg1, NSString* imarg2) {
  floo::BMXUserService *arg1 = (floo::BMXUserService *) 0 ;
  std::string *arg2 = 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXUserService *)imarg1; 
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  result = (floo::BMXErrorCode)(arg1)->setPublicInfo((std::string const &)*arg2);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXUserService_setPrivateInfo(void* imarg1, NSString* imarg2) {
  floo::BMXUserService *arg1 = (floo::BMXUserService *) 0 ;
  std::string *arg2 = 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXUserService *)imarg1; 
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  result = (floo::BMXErrorCode)(arg1)->setPrivateInfo((std::string const &)*arg2);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXUserService_setAddFriendAuthMode(void* imarg1, int imarg2) {
  floo::BMXUserService *arg1 = (floo::BMXUserService *) 0 ;
  floo::BMXUserProfile::AddFriendAuthMode arg2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXUserService *)imarg1; 
  arg2 = (floo::BMXUserProfile::AddFriendAuthMode)imarg2; 
  result = (floo::BMXErrorCode)(arg1)->setAddFriendAuthMode(arg2);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXUserService_setAuthQuestion(void* imarg1, void* imarg2) {
  floo::BMXUserService *arg1 = (floo::BMXUserService *) 0 ;
  BMXUserProfileAuthQuestion *arg2 = 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXUserService *)imarg1; 
  arg2 = (BMXUserProfileAuthQuestion *)imarg2; 
  result = (floo::BMXErrorCode)(arg1)->setAuthQuestion((BMXUserProfile::AuthQuestion const &)*arg2);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXUserService_setEnablePush(void* imarg1, BOOL imarg2) {
  floo::BMXUserService *arg1 = (floo::BMXUserService *) 0 ;
  bool arg2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXUserService *)imarg1; 
  arg2 = imarg2? true : false; 
  result = (floo::BMXErrorCode)(arg1)->setEnablePush(arg2);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXUserService_setEnablePushDetaile(void* imarg1, BOOL imarg2) {
  floo::BMXUserService *arg1 = (floo::BMXUserService *) 0 ;
  bool arg2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXUserService *)imarg1; 
  arg2 = imarg2? true : false; 
  result = (floo::BMXErrorCode)(arg1)->setEnablePushDetaile(arg2);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXUserService_setPushNickname(void* imarg1, NSString* imarg2) {
  floo::BMXUserService *arg1 = (floo::BMXUserService *) 0 ;
  std::string *arg2 = 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXUserService *)imarg1; 
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  result = (floo::BMXErrorCode)(arg1)->setPushNickname((std::string const &)*arg2);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXUserService_setPushAlias(void* imarg1, NSString* imarg2, NSString* imarg3) {
  floo::BMXUserService *arg1 = (floo::BMXUserService *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXUserService *)imarg1; 
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str; 
  
  result = (floo::BMXErrorCode)(arg1)->setPushAlias((std::string const &)*arg2,(std::string const &)*arg3);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXUserService_setNotificationSound(void* imarg1, BOOL imarg2) {
  floo::BMXUserService *arg1 = (floo::BMXUserService *) 0 ;
  bool arg2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXUserService *)imarg1; 
  arg2 = imarg2? true : false; 
  result = (floo::BMXErrorCode)(arg1)->setNotificationSound(arg2);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXUserService_setNotificationVibrate(void* imarg1, BOOL imarg2) {
  floo::BMXUserService *arg1 = (floo::BMXUserService *) 0 ;
  bool arg2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXUserService *)imarg1; 
  arg2 = imarg2? true : false; 
  result = (floo::BMXErrorCode)(arg1)->setNotificationVibrate(arg2);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXUserService_setAutoDownloadAttachment(void* imarg1, BOOL imarg2) {
  floo::BMXUserService *arg1 = (floo::BMXUserService *) 0 ;
  bool arg2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXUserService *)imarg1; 
  arg2 = imarg2? true : false; 
  result = (floo::BMXErrorCode)(arg1)->setAutoDownloadAttachment(arg2);
  imresult = (int)result; 
  return imresult;
}

int _wrap_BMXUserService_setAutoAcceptGroupInvite(void* imarg1, BOOL imarg2) {
  floo::BMXUserService *arg1 = (floo::BMXUserService *) 0 ;
  bool arg2 ;
  int imresult = 0 ;
  floo::BMXErrorCode result;
  
  arg1 = (floo::BMXUserService *)imarg1; 
  arg2 = imarg2? true : false; 
  result = (floo::BMXErrorCode)(arg1)->setAutoAcceptGroupInvite(arg2);
  imresult = (int)result; 
  return imresult;
}

void _wrap_BMXUserService_addUserListener(void* imarg1, void* imarg2) {
  floo::BMXUserService *arg1 = (floo::BMXUserService *) 0 ;
  floo::BMXUserServiceListener *arg2 = (floo::BMXUserServiceListener *) 0 ;
  
  arg1 = (floo::BMXUserService *)imarg1; 
  arg2 = (floo::BMXUserServiceListener *)imarg2; 
  (arg1)->addUserListener(arg2);
}

void _wrap_BMXUserService_removeUserListener(void* imarg1, void* imarg2) {
  floo::BMXUserService *arg1 = (floo::BMXUserService *) 0 ;
  floo::BMXUserServiceListener *arg2 = (floo::BMXUserServiceListener *) 0 ;
  
  arg1 = (floo::BMXUserService *)imarg1; 
  arg2 = (floo::BMXUserServiceListener *)imarg2; 
  (arg1)->removeUserListener(arg2);
}

void* _wrap_new_BMXUserServiceListener() {
  void* imresult = 0 ;
  floo::BMXUserServiceListener *result = 0 ;
  
  result = (floo::BMXUserServiceListener *)new floo::BMXUserServiceListener();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_delete_BMXUserServiceListener(void* imarg1) {
  floo::BMXUserServiceListener *arg1 = (floo::BMXUserServiceListener *) 0 ;
  
  arg1 = (floo::BMXUserServiceListener *)imarg1; 
  delete arg1;
}

void _wrap_BMXUserServiceListener_onConnectStatusChanged(void* imarg1, int imarg2) {
  floo::BMXUserServiceListener *arg1 = (floo::BMXUserServiceListener *) 0 ;
  floo::BMXConnectStatus arg2 ;
  
  arg1 = (floo::BMXUserServiceListener *)imarg1; 
  arg2 = (floo::BMXConnectStatus)imarg2; 
  (arg1)->onConnectStatusChanged(arg2);
}

void _wrap_BMXUserServiceListener_onUserSignIn(void* imarg1, void* imarg2) {
  floo::BMXUserServiceListener *arg1 = (floo::BMXUserServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXUserProfile > > arg2 ;
  floo::BMXUserProfilePtr *argp2 ;
  
  arg1 = (floo::BMXUserServiceListener *)imarg1; 
  
  argp2 = (floo::BMXUserProfilePtr *)imarg2;
  arg2 = *argp2; 
  
  (arg1)->onUserSignIn(arg2);
}

void _wrap_BMXUserServiceListener_onUserSignOut(void* imarg1, int imarg2, long long imarg3) {
  floo::BMXUserServiceListener *arg1 = (floo::BMXUserServiceListener *) 0 ;
  floo::BMXErrorCode arg2 ;
  int64_t arg3 ;
  
  arg1 = (floo::BMXUserServiceListener *)imarg1; 
  arg2 = (floo::BMXErrorCode)imarg2; 
  arg3 = (int64_t)imarg3; 
  (arg1)->onUserSignOut(arg2,arg3);
}

void _wrap_BMXUserServiceListener_onInfoUpdated(void* imarg1, void* imarg2) {
  floo::BMXUserServiceListener *arg1 = (floo::BMXUserServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXUserProfile > > arg2 ;
  floo::BMXUserProfilePtr *argp2 ;
  
  arg1 = (floo::BMXUserServiceListener *)imarg1; 
  
  argp2 = (floo::BMXUserProfilePtr *)imarg2;
  arg2 = *argp2; 
  
  (arg1)->onInfoUpdated(arg2);
}

void _wrap_BMXUserServiceListener_onOtherDeviceSingIn(void* imarg1, int imarg2) {
  floo::BMXUserServiceListener *arg1 = (floo::BMXUserServiceListener *) 0 ;
  int arg2 ;
  
  arg1 = (floo::BMXUserServiceListener *)imarg1; 
  arg2 = (int)imarg2; 
  (arg1)->onOtherDeviceSingIn(arg2);
}

void _wrap_BMXUserServiceListener_onOtherDeviceSingOut(void* imarg1, int imarg2) {
  floo::BMXUserServiceListener *arg1 = (floo::BMXUserServiceListener *) 0 ;
  int arg2 ;
  
  arg1 = (floo::BMXUserServiceListener *)imarg1; 
  arg2 = (int)imarg2; 
  (arg1)->onOtherDeviceSingOut(arg2);
}

void _wrap_BMXUserServiceListener_onTrafficLimitExceeded(void* imarg1) {
  floo::BMXUserServiceListener *arg1 = (floo::BMXUserServiceListener *) 0 ;
  
  arg1 = (floo::BMXUserServiceListener *)imarg1; 
  (arg1)->onTrafficLimitExceeded();
}

void _wrap_BMXUserServiceListener_registerUserService(void* imarg1, void* imarg2) {
  floo::BMXUserServiceListener *arg1 = (floo::BMXUserServiceListener *) 0 ;
  floo::BMXUserService *arg2 = (floo::BMXUserService *) 0 ;
  
  arg1 = (floo::BMXUserServiceListener *)imarg1; 
  arg2 = (floo::BMXUserService *)imarg2; 
  (arg1)->registerUserService(arg2);
}

void* _wrap_new_BMXVideoAttachment__SWIG_0(NSString* imarg1, int imarg2, void* imarg3, NSString* imarg4) {
  std::string *arg1 = 0 ;
  int arg2 ;
  floo::BMXMessageAttachment::Size *arg3 = 0 ;
  std::string *arg4 = 0 ;
  void* imresult = 0 ;
  floo::BMXVideoAttachment *result = 0 ;
  
  if(!imarg1) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg1_str(getStdString(imarg1));
  arg1 = &arg1_str; 
  
  arg2 = (int)imarg2; 
  arg3 = (floo::BMXMessageAttachment::Size *)imarg3; 
  if(!imarg4) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg4_str(getStdString(imarg4));
  arg4 = &arg4_str; 
  
  result = (floo::BMXVideoAttachment *)new floo::BMXVideoAttachment((std::string const &)*arg1,arg2,(floo::BMXMessageAttachment::Size const &)*arg3,(std::string const &)*arg4);
  BMXVideoAttachment2Void(result)
  imresult = (void*)lresult;
  return imresult;
}

void* _wrap_new_BMXVideoAttachment__SWIG_1(NSString* imarg1, int imarg2, void* imarg3) {
  std::string *arg1 = 0 ;
  int arg2 ;
  floo::BMXMessageAttachment::Size *arg3 = 0 ;
  void* imresult = 0 ;
  floo::BMXVideoAttachment *result = 0 ;
  
  if(!imarg1) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg1_str(getStdString(imarg1));
  arg1 = &arg1_str; 
  
  arg2 = (int)imarg2; 
  arg3 = (floo::BMXMessageAttachment::Size *)imarg3; 
  result = (floo::BMXVideoAttachment *)new floo::BMXVideoAttachment((std::string const &)*arg1,arg2,(floo::BMXMessageAttachment::Size const &)*arg3);
  BMXVideoAttachment2Void(result)
  imresult = (void*)lresult;
  return imresult;
}

void* _wrap_new_BMXVideoAttachment__SWIG_2(NSString* imarg1, NSString* imarg2, int imarg3, void* imarg4, NSString* imarg5) {
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  int arg3 ;
  floo::BMXMessageAttachment::Size *arg4 = 0 ;
  std::string *arg5 = 0 ;
  void* imresult = 0 ;
  floo::BMXVideoAttachment *result = 0 ;
  
  if(!imarg1) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg1_str(getStdString(imarg1));
  arg1 = &arg1_str; 
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  arg3 = (int)imarg3; 
  arg4 = (floo::BMXMessageAttachment::Size *)imarg4; 
  if(!imarg5) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg5_str(getStdString(imarg5));
  arg5 = &arg5_str; 
  
  result = (floo::BMXVideoAttachment *)new floo::BMXVideoAttachment((std::string const &)*arg1,(std::string const &)*arg2,arg3,(floo::BMXMessageAttachment::Size const &)*arg4,(std::string const &)*arg5);
  BMXVideoAttachment2Void(result)
  imresult = (void*)lresult;
  return imresult;
}

void* _wrap_new_BMXVideoAttachment__SWIG_3(NSString* imarg1, NSString* imarg2, int imarg3, void* imarg4) {
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  int arg3 ;
  floo::BMXMessageAttachment::Size *arg4 = 0 ;
  void* imresult = 0 ;
  floo::BMXVideoAttachment *result = 0 ;
  
  if(!imarg1) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg1_str(getStdString(imarg1));
  arg1 = &arg1_str; 
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  arg3 = (int)imarg3; 
  arg4 = (floo::BMXMessageAttachment::Size *)imarg4; 
  result = (floo::BMXVideoAttachment *)new floo::BMXVideoAttachment((std::string const &)*arg1,(std::string const &)*arg2,arg3,(floo::BMXMessageAttachment::Size const &)*arg4);
  BMXVideoAttachment2Void(result)
  imresult = (void*)lresult;
  return imresult;
}

void* _wrap_new_BMXVideoAttachment__SWIG_4(NSString* imarg1, int imarg2, void* imarg3, NSString* imarg4, long long imarg5) {
  std::string *arg1 = 0 ;
  int arg2 ;
  floo::BMXMessageAttachment::Size *arg3 = 0 ;
  std::string *arg4 = 0 ;
  int64_t arg5 ;
  void* imresult = 0 ;
  floo::BMXVideoAttachment *result = 0 ;
  
  if(!imarg1) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg1_str(getStdString(imarg1));
  arg1 = &arg1_str; 
  
  arg2 = (int)imarg2; 
  arg3 = (floo::BMXMessageAttachment::Size *)imarg3; 
  if(!imarg4) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg4_str(getStdString(imarg4));
  arg4 = &arg4_str; 
  
  arg5 = (int64_t)imarg5; 
  result = (floo::BMXVideoAttachment *)new floo::BMXVideoAttachment((std::string const &)*arg1,arg2,(floo::BMXMessageAttachment::Size const &)*arg3,(std::string const &)*arg4,arg5);
  BMXVideoAttachment2Void(result)
  imresult = (void*)lresult;
  return imresult;
}

void* _wrap_new_BMXVideoAttachment__SWIG_5(NSString* imarg1, NSString* imarg2, int imarg3, void* imarg4, NSString* imarg5, long long imarg6) {
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  int arg3 ;
  floo::BMXMessageAttachment::Size *arg4 = 0 ;
  std::string *arg5 = 0 ;
  int64_t arg6 ;
  void* imresult = 0 ;
  floo::BMXVideoAttachment *result = 0 ;
  
  if(!imarg1) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg1_str(getStdString(imarg1));
  arg1 = &arg1_str; 
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  arg3 = (int)imarg3; 
  arg4 = (floo::BMXMessageAttachment::Size *)imarg4; 
  if(!imarg5) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg5_str(getStdString(imarg5));
  arg5 = &arg5_str; 
  
  arg6 = (int64_t)imarg6; 
  result = (floo::BMXVideoAttachment *)new floo::BMXVideoAttachment((std::string const &)*arg1,(std::string const &)*arg2,arg3,(floo::BMXMessageAttachment::Size const &)*arg4,(std::string const &)*arg5,arg6);
  BMXVideoAttachment2Void(result)
  imresult = (void*)lresult;
  return imresult;
}

void _wrap_delete_BMXVideoAttachment(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXVideoAttachmentPtr arg1 ;
  floo::BMXVideoAttachmentPtr *argp1 = *(floo::BMXVideoAttachmentPtr **)&larg1;
  delete argp1;
}

int _wrap_BMXVideoAttachment_type(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXVideoAttachmentPtr arg1 ;
  floo::BMXVideoAttachmentPtr *argp1 = *(floo::BMXVideoAttachmentPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  floo::BMXMessageAttachment::Type result;
  
  result = (floo::BMXMessageAttachment::Type)(arg1)->type();
  imresult = (int)result; 
  return imresult;
}

void* _wrap_BMXVideoAttachment_clone(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXVideoAttachmentPtr arg1 ;
  floo::BMXVideoAttachmentPtr *argp1 = *(floo::BMXVideoAttachmentPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  void* imresult = 0 ;
  floo::BMXMessageAttachmentPtr *temp ;
  std::shared_ptr< floo::BMXMessageAttachment > result;
  
  result = (arg1)->clone();
  
  BMXMessageAttachment2Void(result)
  imresult = (void*)lresult;
  
  return imresult;
}

void* _wrap_BMXVideoAttachment_size(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXVideoAttachmentPtr arg1 ;
  floo::BMXVideoAttachmentPtr *argp1 = *(floo::BMXVideoAttachmentPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  void* imresult = 0 ;
  floo::BMXMessageAttachment::Size *result = 0 ;
  
  result = (floo::BMXMessageAttachment::Size *) &(arg1)->size();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

int _wrap_BMXVideoAttachment_duration(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXVideoAttachmentPtr arg1 ;
  floo::BMXVideoAttachmentPtr *argp1 = *(floo::BMXVideoAttachmentPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  int32_t result;
  
  result = (int32_t)(arg1)->duration();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_BMXVideoAttachment_setThumbnail(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXVideoAttachmentPtr arg1 ;
  floo::BMXVideoAttachmentPtr *argp1 = *(floo::BMXVideoAttachmentPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  (arg1)->setThumbnail((std::string const &)*arg2);
}

NSString* _wrap_BMXVideoAttachment_thumbnailPath(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXVideoAttachmentPtr arg1 ;
  floo::BMXVideoAttachmentPtr *argp1 = *(floo::BMXVideoAttachmentPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &(arg1)->thumbnailPath();
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_BMXVideoAttachment_thumbnailUrl(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXVideoAttachmentPtr arg1 ;
  floo::BMXVideoAttachmentPtr *argp1 = *(floo::BMXVideoAttachmentPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &(arg1)->thumbnailUrl();
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void _wrap_BMXVideoAttachment_setThumbnailRatelUrl(void* imarg1, NSString* imarg2) {
  long long larg1 = (long long)imarg1;
  floo::BMXVideoAttachmentPtr arg1 ;
  floo::BMXVideoAttachmentPtr *argp1 = *(floo::BMXVideoAttachmentPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  std::string *arg2 = 0 ;
  
  if(!imarg2) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg2_str(getStdString(imarg2));
  arg2 = &arg2_str; 
  
  (arg1)->setThumbnailRatelUrl((std::string const &)*arg2);
}

NSString* _wrap_BMXVideoAttachment_thumbnailRatelUrl(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXVideoAttachmentPtr arg1 ;
  floo::BMXVideoAttachmentPtr *argp1 = *(floo::BMXVideoAttachmentPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  NSString* imresult = 0 ;
  std::string *result = 0 ;
  
  result = (std::string *) &(arg1)->thumbnailRatelUrl();
  imresult = [NSString stringWithUTF8String: result->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

int _wrap_BMXVideoAttachment_thumbnailDownloadStatus(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXVideoAttachmentPtr arg1 ;
  floo::BMXVideoAttachmentPtr *argp1 = *(floo::BMXVideoAttachmentPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  floo::BMXMessageAttachment::DownloadStatus result;
  
  result = (floo::BMXMessageAttachment::DownloadStatus)(arg1)->thumbnailDownloadStatus();
  imresult = (int)result; 
  return imresult;
}

void* _wrap_BMXVideoAttachment_dynamic_cast(void* imarg1) {
    long long larg1 = (long long)imarg1;
    floo::BMXVideoAttachmentPtr arg1 ;
    floo::BMXVideoAttachmentPtr *argp1 = *(floo::BMXVideoAttachmentPtr **)&larg1;
    if (argp1) arg1 = *argp1;
      
    return argp1;
}

void* _wrap_new_BMXVoiceAttachment__SWIG_0(NSString* imarg1, int imarg2, NSString* imarg3) {
  std::string *arg1 = 0 ;
  int arg2 ;
  std::string *arg3 = 0 ;
  void* imresult = 0 ;
  floo::BMXVoiceAttachment *result = 0 ;
  
  if(!imarg1) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg1_str(getStdString(imarg1));
  arg1 = &arg1_str; 
  
  arg2 = (int)imarg2; 
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str; 
  
  result = (floo::BMXVoiceAttachment *)new floo::BMXVoiceAttachment((std::string const &)*arg1,arg2,(std::string const &)*arg3);
  BMXVoiceAttachment2Void(result)
  imresult = (void*)lresult;
  return imresult;
}

void* _wrap_new_BMXVoiceAttachment__SWIG_1(NSString* imarg1, int imarg2) {
  std::string *arg1 = 0 ;
  int arg2 ;
  void* imresult = 0 ;
  floo::BMXVoiceAttachment *result = 0 ;
  
  if(!imarg1) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg1_str(getStdString(imarg1));
  arg1 = &arg1_str; 
  
  arg2 = (int)imarg2; 
  result = (floo::BMXVoiceAttachment *)new floo::BMXVoiceAttachment((std::string const &)*arg1,arg2);
  BMXVoiceAttachment2Void(result)
  imresult = (void*)lresult;
  return imresult;
}

void* _wrap_new_BMXVoiceAttachment__SWIG_2(NSString* imarg1, int imarg2, NSString* imarg3, long long imarg4) {
  std::string *arg1 = 0 ;
  int arg2 ;
  std::string *arg3 = 0 ;
  int64_t arg4 ;
  void* imresult = 0 ;
  floo::BMXVoiceAttachment *result = 0 ;
  
  if(!imarg1) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg1_str(getStdString(imarg1));
  arg1 = &arg1_str; 
  
  arg2 = (int)imarg2; 
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str; 
  
  arg4 = (int64_t)imarg4; 
  result = (floo::BMXVoiceAttachment *)new floo::BMXVoiceAttachment((std::string const &)*arg1,arg2,(std::string const &)*arg3,arg4);
  BMXVoiceAttachment2Void(result)
  imresult = (void*)lresult;
  return imresult;
}

void _wrap_delete_BMXVoiceAttachment(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXVoiceAttachmentPtr arg1 ;
  floo::BMXVoiceAttachmentPtr *argp1 = *(floo::BMXVoiceAttachmentPtr **)&larg1;
  delete argp1;
}

int _wrap_BMXVoiceAttachment_type(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXVoiceAttachmentPtr arg1 ;
  floo::BMXVoiceAttachmentPtr *argp1 = *(floo::BMXVoiceAttachmentPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  floo::BMXMessageAttachment::Type result;
  
  result = (floo::BMXMessageAttachment::Type)(arg1)->type();
  imresult = (int)result; 
  return imresult;
}

void* _wrap_BMXVoiceAttachment_clone(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXVoiceAttachmentPtr arg1 ;
  floo::BMXVoiceAttachmentPtr *argp1 = *(floo::BMXVoiceAttachmentPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  void* imresult = 0 ;
  floo::BMXMessageAttachmentPtr *temp ;
  std::shared_ptr< floo::BMXMessageAttachment > result;
  
  result = (arg1)->clone();
  
  BMXMessageAttachment2Void(result)
  imresult = (void*)lresult; 
  
  return imresult;
}

int _wrap_BMXVoiceAttachment_duration(void* imarg1) {
  long long larg1 = (long long)imarg1;
  floo::BMXVoiceAttachmentPtr arg1 ;
  floo::BMXVoiceAttachmentPtr *argp1 = *(floo::BMXVoiceAttachmentPtr **)&larg1;
  if (argp1) arg1 = *argp1;
  int imresult = 0 ;
  int32_t result;
  
  result = (int32_t)(arg1)->duration();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_BMXVoiceAttachment_dynamic_cast(void* imarg1) {
    long long larg1 = (long long)imarg1;
    floo::BMXVoiceAttachmentPtr arg1 ;
    floo::BMXVoiceAttachmentPtr *argp1 = *(floo::BMXVoiceAttachmentPtr **)&larg1;
    if (argp1) arg1 = *argp1;
      
    return argp1;
}

void* _wrap_new_BMXGroupServiceListener() {
  void* imresult = 0 ;
  floo::BMXGroupServiceListener *result = 0 ;
  
  result = (floo::BMXGroupServiceListener *)new floo::BMXGroupServiceListener();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void _wrap_delete_BMXGroupServiceListener(void* imarg1) {
  floo::BMXGroupServiceListener *arg1 = (floo::BMXGroupServiceListener *) 0 ;
  
  arg1 = (floo::BMXGroupServiceListener *)imarg1; 
  delete arg1;
}

void _wrap_BMXGroupServiceListener_onGroupCreate(void* imarg1, void* imarg2) {
  floo::BMXGroupServiceListener *arg1 = (floo::BMXGroupServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  floo::BMXGroupPtr *argp2 ;
  
  arg1 = (floo::BMXGroupServiceListener *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  (arg1)->onGroupCreate(arg2);
}

void _wrap_BMXGroupServiceListener_onGroupListUpdate__SWIG_0(void* imarg1, void* imarg2) {
  floo::BMXGroupServiceListener *arg1 = (floo::BMXGroupServiceListener *) 0 ;
  floo::BMXGroupList *arg2 = 0 ;
  
  arg1 = (floo::BMXGroupServiceListener *)imarg1; 
  arg2 = (floo::BMXGroupList *)imarg2; 
  (arg1)->onGroupListUpdate((floo::BMXGroupList const &)*arg2);
}

void _wrap_BMXGroupServiceListener_onGroupJoined(void* imarg1, void* imarg2) {
  floo::BMXGroupServiceListener *arg1 = (floo::BMXGroupServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  floo::BMXGroupPtr *argp2 ;
  
  arg1 = (floo::BMXGroupServiceListener *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  (arg1)->onGroupJoined(arg2);
}

void _wrap_BMXGroupServiceListener_onGroupLeft(void* imarg1, void* imarg2, NSString* imarg3) {
  floo::BMXGroupServiceListener *arg1 = (floo::BMXGroupServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  std::string *arg3 = 0 ;
  floo::BMXGroupPtr *argp2 ;
  
  arg1 = (floo::BMXGroupServiceListener *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  if(!imarg3) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg3_str(getStdString(imarg3));
  arg3 = &arg3_str; 
  
  (arg1)->onGroupLeft(arg2,(std::string const &)*arg3);
}

void _wrap_BMXGroupServiceListener_onInvitated(void* imarg1, long long imarg2, long long imarg3, NSString* imarg4) {
  floo::BMXGroupServiceListener *arg1 = (floo::BMXGroupServiceListener *) 0 ;
  int64_t arg2 ;
  int64_t arg3 ;
  std::string *arg4 = 0 ;
  
  arg1 = (floo::BMXGroupServiceListener *)imarg1; 
  arg2 = (int64_t)imarg2; 
  arg3 = (int64_t)imarg3; 
  if(!imarg4) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg4_str(getStdString(imarg4));
  arg4 = &arg4_str; 
  
  (arg1)->onInvitated(arg2,arg3,(std::string const &)*arg4);
}

void _wrap_BMXGroupServiceListener_onInvitationAccepted(void* imarg1, void* imarg2, long long imarg3) {
  floo::BMXGroupServiceListener *arg1 = (floo::BMXGroupServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  int64_t arg3 ;
  floo::BMXGroupPtr *argp2 ;
  
  arg1 = (floo::BMXGroupServiceListener *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (int64_t)imarg3; 
  (arg1)->onInvitationAccepted(arg2,arg3);
}

void _wrap_BMXGroupServiceListener_onInvitationDeclined(void* imarg1, void* imarg2, long long imarg3, NSString* imarg4) {
  floo::BMXGroupServiceListener *arg1 = (floo::BMXGroupServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  int64_t arg3 ;
  std::string *arg4 = 0 ;
  floo::BMXGroupPtr *argp2 ;
  
  arg1 = (floo::BMXGroupServiceListener *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (int64_t)imarg3; 
  if(!imarg4) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg4_str(getStdString(imarg4));
  arg4 = &arg4_str; 
  
  (arg1)->onInvitationDeclined(arg2,arg3,(std::string const &)*arg4);
}

void _wrap_BMXGroupServiceListener_onApplied(void* imarg1, void* imarg2, long long imarg3, NSString* imarg4) {
  floo::BMXGroupServiceListener *arg1 = (floo::BMXGroupServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  int64_t arg3 ;
  std::string *arg4 = 0 ;
  floo::BMXGroupPtr *argp2 ;
  
  arg1 = (floo::BMXGroupServiceListener *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (int64_t)imarg3; 
  if(!imarg4) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg4_str(getStdString(imarg4));
  arg4 = &arg4_str; 
  
  (arg1)->onApplied(arg2,arg3,(std::string const &)*arg4);
}

void _wrap_BMXGroupServiceListener_onApplicationAccepted(void* imarg1, void* imarg2, long long imarg3) {
  floo::BMXGroupServiceListener *arg1 = (floo::BMXGroupServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  int64_t arg3 ;
  floo::BMXGroupPtr *argp2 ;
  
  arg1 = (floo::BMXGroupServiceListener *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (int64_t)imarg3; 
  (arg1)->onApplicationAccepted(arg2,arg3);
}

void _wrap_BMXGroupServiceListener_onApplicationDeclined(void* imarg1, void* imarg2, long long imarg3, NSString* imarg4) {
  floo::BMXGroupServiceListener *arg1 = (floo::BMXGroupServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  int64_t arg3 ;
  std::string *arg4 = 0 ;
  floo::BMXGroupPtr *argp2 ;
  
  arg1 = (floo::BMXGroupServiceListener *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (int64_t)imarg3; 
  if(!imarg4) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg4_str(getStdString(imarg4));
  arg4 = &arg4_str; 
  
  (arg1)->onApplicationDeclined(arg2,arg3,(std::string const &)*arg4);
}

void _wrap_BMXGroupServiceListener_onMembersBanned(void* imarg1, void* imarg2, void* imarg3, long long imarg4) {
  floo::BMXGroupServiceListener *arg1 = (floo::BMXGroupServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  std::vector< int64_t > *arg3 = 0 ;
  int64_t arg4 ;
  floo::BMXGroupPtr *argp2 ;
  
  arg1 = (floo::BMXGroupServiceListener *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (std::vector< int64_t > *)imarg3; 
  arg4 = (int64_t)imarg4; 
  (arg1)->onMembersBanned(arg2,(std::vector< int64_t > const &)*arg3,arg4);
}

void _wrap_BMXGroupServiceListener_onMembersUnbanned(void* imarg1, void* imarg2, void* imarg3) {
  floo::BMXGroupServiceListener *arg1 = (floo::BMXGroupServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  std::vector< int64_t > *arg3 = 0 ;
  floo::BMXGroupPtr *argp2 ;
  
  arg1 = (floo::BMXGroupServiceListener *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (std::vector< int64_t > *)imarg3; 
  (arg1)->onMembersUnbanned(arg2,(std::vector< int64_t > const &)*arg3);
}

void _wrap_BMXGroupServiceListener_onMemberJoined(void* imarg1, void* imarg2, long long imarg3, long long imarg4) {
  floo::BMXGroupServiceListener *arg1 = (floo::BMXGroupServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  int64_t arg3 ;
  int64_t arg4 ;
  floo::BMXGroupPtr *argp2 ;
  
  arg1 = (floo::BMXGroupServiceListener *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (int64_t)imarg3; 
  arg4 = (int64_t)imarg4; 
  (arg1)->onMemberJoined(arg2,arg3,arg4);
}

void _wrap_BMXGroupServiceListener_onMemberLeft(void* imarg1, void* imarg2, long long imarg3, NSString* imarg4) {
  floo::BMXGroupServiceListener *arg1 = (floo::BMXGroupServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  int64_t arg3 ;
  std::string *arg4 = 0 ;
  floo::BMXGroupPtr *argp2 ;
  
  arg1 = (floo::BMXGroupServiceListener *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (int64_t)imarg3; 
  if(!imarg4) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg4_str(getStdString(imarg4));
  arg4 = &arg4_str; 
  
  (arg1)->onMemberLeft(arg2,arg3,(std::string const &)*arg4);
}

void _wrap_BMXGroupServiceListener_onAdminsAdded(void* imarg1, void* imarg2, void* imarg3) {
  floo::BMXGroupServiceListener *arg1 = (floo::BMXGroupServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  std::vector< int64_t > *arg3 = 0 ;
  floo::BMXGroupPtr *argp2 ;
  
  arg1 = (floo::BMXGroupServiceListener *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (std::vector< int64_t > *)imarg3; 
  (arg1)->onAdminsAdded(arg2,(std::vector< int64_t > const &)*arg3);
}

void _wrap_BMXGroupServiceListener_onAdminsRemoved(void* imarg1, void* imarg2, void* imarg3, NSString* imarg4) {
  floo::BMXGroupServiceListener *arg1 = (floo::BMXGroupServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  std::vector< int64_t > *arg3 = 0 ;
  std::string *arg4 = 0 ;
  floo::BMXGroupPtr *argp2 ;
  
  arg1 = (floo::BMXGroupServiceListener *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (std::vector< int64_t > *)imarg3; 
  if(!imarg4) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg4_str(getStdString(imarg4));
  arg4 = &arg4_str; 
  
  (arg1)->onAdminsRemoved(arg2,(std::vector< int64_t > const &)*arg3,(std::string const &)*arg4);
}

void _wrap_BMXGroupServiceListener_onOwnerAssigned(void* imarg1, void* imarg2) {
  floo::BMXGroupServiceListener *arg1 = (floo::BMXGroupServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  floo::BMXGroupPtr *argp2 ;
  
  arg1 = (floo::BMXGroupServiceListener *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  (arg1)->onOwnerAssigned(arg2);
}

void _wrap_BMXGroupServiceListener_onGroupInfoUpdate(void* imarg1, void* imarg2, int imarg3) {
  floo::BMXGroupServiceListener *arg1 = (floo::BMXGroupServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  floo::BMXGroup::UpdateInfoType arg3 ;
  floo::BMXGroupPtr *argp2 ;
  
  arg1 = (floo::BMXGroupServiceListener *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (floo::BMXGroup::UpdateInfoType)imarg3; 
  (arg1)->onGroupInfoUpdate(arg2,arg3);
}

void _wrap_BMXGroupServiceListener_onMemberChangeNickName(void* imarg1, void* imarg2, long long imarg3, NSString* imarg4) {
  floo::BMXGroupServiceListener *arg1 = (floo::BMXGroupServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  int64_t arg3 ;
  std::string *arg4 = 0 ;
  floo::BMXGroupPtr *argp2 ;
  
  arg1 = (floo::BMXGroupServiceListener *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (int64_t)imarg3; 
  if(!imarg4) {
    NSException* anException = [NSException exceptionWithName:@"NullPointerException" 
    reason:@"null std::string" userInfo:nil];
    @throw anException;
  }
  std::string arg4_str(getStdString(imarg4));
  arg4 = &arg4_str; 
  
  (arg1)->onMemberChangeNickName(arg2,arg3,(std::string const &)*arg4);
}

void _wrap_BMXGroupServiceListener_onAnnouncementUpdate(void* imarg1, void* imarg2, void* imarg3) {
  floo::BMXGroupServiceListener *arg1 = (floo::BMXGroupServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup::Announcement > > arg3 ;
  floo::BMXGroupPtr *argp2 ;
  floo::BMXGroup::AnnouncementPtr *argp3 ;
  
  arg1 = (floo::BMXGroupServiceListener *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  
  argp3 = (floo::BMXGroup::AnnouncementPtr *)imarg3;
  arg3 = *argp3; 
  
  (arg1)->onAnnouncementUpdate(arg2,arg3);
}

void _wrap_BMXGroupServiceListener_onSharedFileUploaded(void* imarg1, void* imarg2, void* imarg3) {
  floo::BMXGroupServiceListener *arg1 = (floo::BMXGroupServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup::SharedFile > > arg3 ;
  floo::BMXGroupPtr *argp2 ;
  floo::BMXGroup::SharedFilePtr *argp3 ;
  
  arg1 = (floo::BMXGroupServiceListener *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  
  argp3 = (floo::BMXGroup::SharedFilePtr *)imarg3;
  arg3 = *argp3; 
  
  (arg1)->onSharedFileUploaded(arg2,arg3);
}

void _wrap_BMXGroupServiceListener_onSharedFileDeleted(void* imarg1, void* imarg2, void* imarg3) {
  floo::BMXGroupServiceListener *arg1 = (floo::BMXGroupServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup::SharedFile > > arg3 ;
  floo::BMXGroupPtr *argp2 ;
  floo::BMXGroup::SharedFilePtr *argp3 ;
  
  arg1 = (floo::BMXGroupServiceListener *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  
  argp3 = (floo::BMXGroup::SharedFilePtr *)imarg3;
  arg3 = *argp3; 
  
  (arg1)->onSharedFileDeleted(arg2,arg3);
}

void _wrap_BMXGroupServiceListener_onSharedFileUpdated(void* imarg1, void* imarg2, void* imarg3) {
  floo::BMXGroupServiceListener *arg1 = (floo::BMXGroupServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup::SharedFile > > arg3 ;
  floo::BMXGroupPtr *argp2 ;
  floo::BMXGroup::SharedFilePtr *argp3 ;
  
  arg1 = (floo::BMXGroupServiceListener *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  
  argp3 = (floo::BMXGroup::SharedFilePtr *)imarg3;
  arg3 = *argp3; 
  
  (arg1)->onSharedFileUpdated(arg2,arg3);
}

void _wrap_BMXGroupServiceListener_onBlockListAdded(void* imarg1, void* imarg2, void* imarg3) {
  floo::BMXGroupServiceListener *arg1 = (floo::BMXGroupServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  std::vector< int64_t > *arg3 = 0 ;
  floo::BMXGroupPtr *argp2 ;
  
  arg1 = (floo::BMXGroupServiceListener *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (std::vector< int64_t > *)imarg3; 
  (arg1)->onBlockListAdded(arg2,(std::vector< int64_t > const &)*arg3);
}

void _wrap_BMXGroupServiceListener_onBlockListRemoved(void* imarg1, void* imarg2, void* imarg3) {
  floo::BMXGroupServiceListener *arg1 = (floo::BMXGroupServiceListener *) 0 ;
  SwigValueWrapper< std::shared_ptr< floo::BMXGroup > > arg2 ;
  std::vector< int64_t > *arg3 = 0 ;
  floo::BMXGroupPtr *argp2 ;
  
  arg1 = (floo::BMXGroupServiceListener *)imarg1; 
  
  argp2 = (floo::BMXGroupPtr *)imarg2;
  arg2 = *argp2; 
  
  arg3 = (std::vector< int64_t > *)imarg3; 
  (arg1)->onBlockListRemoved(arg2,(std::vector< int64_t > const &)*arg3);
}

void _wrap_BMXGroupServiceListener_onGroupListUpdate__SWIG_1(void* imarg1) {
  floo::BMXGroupServiceListener *arg1 = (floo::BMXGroupServiceListener *) 0 ;
  
  arg1 = (floo::BMXGroupServiceListener *)imarg1; 
  (arg1)->onGroupListUpdate();
}

void _wrap_BMXGroupServiceListener_registerGroupService(void* imarg1, void* imarg2) {
  floo::BMXGroupServiceListener *arg1 = (floo::BMXGroupServiceListener *) 0 ;
  floo::BMXGroupService *arg2 = (floo::BMXGroupService *) 0 ;
  
  arg1 = (floo::BMXGroupServiceListener *)imarg1; 
  arg2 = (floo::BMXGroupService *)imarg2; 
  (arg1)->registerGroupService(arg2);
}

void _wrap_delete_BMXPushUserProfile(void* imarg1) {
  floo::BMXPushUserProfile *arg1 = (floo::BMXPushUserProfile *) 0 ;
  
  arg1 = (floo::BMXPushUserProfile *)imarg1; 
  delete arg1;
}

long long _wrap_BMXPushUserProfile_userId(void* imarg1) {
  floo::BMXPushUserProfile *arg1 = (floo::BMXPushUserProfile *) 0 ;
  long long imresult = 0 ;
  int64_t result;
  
  arg1 = (floo::BMXPushUserProfile *)imarg1; 
  result = (int64_t)(arg1)->userId();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

NSString* _wrap_BMXPushUserProfile_pushAlias(void* imarg1) {
  floo::BMXPushUserProfile *arg1 = (floo::BMXPushUserProfile *) 0 ;
  NSString* imresult = 0 ;
  std::string result;
  
  arg1 = (floo::BMXPushUserProfile *)imarg1; 
  result = (arg1)->pushAlias();
  imresult = [NSString stringWithUTF8String: (&result)->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

NSString* _wrap_BMXPushUserProfile_pushToken(void* imarg1) {
  floo::BMXPushUserProfile *arg1 = (floo::BMXPushUserProfile *) 0 ;
  NSString* imresult = 0 ;
  std::string result;
  
  arg1 = (floo::BMXPushUserProfile *)imarg1; 
  result = (arg1)->pushToken();
  imresult = [NSString stringWithUTF8String: (&result)->c_str()];
#if !__has_feature(objc_arc)
  [imresult autorelease];
#endif
  return imresult;
}

void* _wrap_BMXPushUserProfile_messagePushSetting(void* imarg1) {
  floo::BMXPushUserProfile *arg1 = (floo::BMXPushUserProfile *) 0 ;
  void* imresult = 0 ;
  floo::BMXPushUserProfile::MessagePushSetting *result = 0 ;
  
  arg1 = (floo::BMXPushUserProfile *)imarg1; 
  result = (floo::BMXPushUserProfile::MessagePushSetting *) &(arg1)->messagePushSetting();
  imresult = *(typeof(imresult)*)&result; 
  return imresult;
}

void* _wrap_new_BMXRTCStreams__SWIG_0() {
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > > *result = 0 ;
  
  result = (std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > > *)new std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > >();
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void* _wrap_new_BMXRTCStreams__SWIG_1(unsigned long imarg1) {
  std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > >::size_type arg1 ;
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > > *result = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > >::size_type)imarg1;
  result = (std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > > *)new std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > >(arg1);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

unsigned long _wrap_BMXRTCStreams_size(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > > *arg1 = (std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > > *) 0 ;
  unsigned long imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > >::size_type result;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > > *)imarg1;
  result = ((std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > > const *)arg1)->size();
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

unsigned long _wrap_BMXRTCStreams_capacity(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > > *arg1 = (std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > > *) 0 ;
  unsigned long imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > >::size_type result;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > > *)imarg1;
  result = ((std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > > const *)arg1)->capacity();
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_BMXRTCStreams_reserve(void* imarg1, unsigned long imarg2) {
  std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > > *arg1 = (std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > > *) 0 ;
  std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > >::size_type arg2 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > > *)imarg1;
  arg2 = (std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > >::size_type)imarg2;
  (arg1)->reserve(arg2);
}

BOOL _wrap_BMXRTCStreams_isEmpty(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > > *arg1 = (std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > > *) 0 ;
  BOOL imresult = 0 ;
  bool result;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > > *)imarg1;
  result = (bool)((std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > > const *)arg1)->empty();
  imresult = (result)? YES:NO;
  return imresult;
}

void _wrap_BMXRTCStreams_clear(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > > *arg1 = (std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > > *) 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > > *)imarg1;
  (arg1)->clear();
}

void _wrap_BMXRTCStreams_add(void* imarg1, void* imarg2) {
  std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > > *arg1 = (std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > > *) 0 ;
  std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > >::value_type *arg2 = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > > *)imarg1;
  arg2 = (std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > >::value_type *)imarg2;
  (arg1)->push_back((std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > >::value_type const &)*arg2);
}

void* _wrap_BMXRTCStreams_get(void* imarg1, int imarg2) {
  std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > > *arg1 = (std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > > *) 0 ;
  int arg2 ;
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > >::value_type *result = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > > *)imarg1;
  arg2 = (int)imarg2;
  try {
    result = (std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > >::value_type *) &std_vector_Sl_std_shared_ptr_Sl_floo_BMXJanusStreamInfo_Sg__Sg__get(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_ObjcThrowException(SWIG_ObjcIndexOutOfBoundsException, (&_e)->what());
    return 0;
  }
  
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_BMXRTCStreams_set(void* imarg1, int imarg2, void* imarg3) {
  std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > > *arg1 = (std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > > *) 0 ;
  int arg2 ;
  std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > >::value_type *arg3 = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > > *)imarg1;
  arg2 = (int)imarg2;
  arg3 = (std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > >::value_type *)imarg3;
  try {
    std_vector_Sl_std_shared_ptr_Sl_floo_BMXJanusStreamInfo_Sg__Sg__set(arg1,arg2,(std::shared_ptr< floo::BMXJanusStreamInfo > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_ObjcThrowException(SWIG_ObjcIndexOutOfBoundsException, (&_e)->what());
    return ;
  }
  
}

void _wrap_delete_BMXRTCStreams(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > > *arg1 = (std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > > *) 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXJanusStreamInfo > > *)imarg1;
  delete arg1;
}

void* _wrap_new_BMXRTCRoomParticipants__SWIG_0() {
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXRoomParticipant > > *result = 0 ;
  
  result = (std::vector< std::shared_ptr< floo::BMXRoomParticipant > > *)new std::vector< std::shared_ptr< floo::BMXRoomParticipant > >();
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void* _wrap_new_BMXRTCRoomParticipants__SWIG_1(unsigned long imarg1) {
  std::vector< std::shared_ptr< floo::BMXRoomParticipant > >::size_type arg1 ;
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXRoomParticipant > > *result = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXRoomParticipant > >::size_type)imarg1;
  result = (std::vector< std::shared_ptr< floo::BMXRoomParticipant > > *)new std::vector< std::shared_ptr< floo::BMXRoomParticipant > >(arg1);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

unsigned long _wrap_BMXRTCRoomParticipants_size(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXRoomParticipant > > *arg1 = (std::vector< std::shared_ptr< floo::BMXRoomParticipant > > *) 0 ;
  unsigned long imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXRoomParticipant > >::size_type result;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXRoomParticipant > > *)imarg1;
  result = ((std::vector< std::shared_ptr< floo::BMXRoomParticipant > > const *)arg1)->size();
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

unsigned long _wrap_BMXRTCRoomParticipants_capacity(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXRoomParticipant > > *arg1 = (std::vector< std::shared_ptr< floo::BMXRoomParticipant > > *) 0 ;
  unsigned long imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXRoomParticipant > >::size_type result;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXRoomParticipant > > *)imarg1;
  result = ((std::vector< std::shared_ptr< floo::BMXRoomParticipant > > const *)arg1)->capacity();
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_BMXRTCRoomParticipants_reserve(void* imarg1, unsigned long imarg2) {
  std::vector< std::shared_ptr< floo::BMXRoomParticipant > > *arg1 = (std::vector< std::shared_ptr< floo::BMXRoomParticipant > > *) 0 ;
  std::vector< std::shared_ptr< floo::BMXRoomParticipant > >::size_type arg2 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXRoomParticipant > > *)imarg1;
  arg2 = (std::vector< std::shared_ptr< floo::BMXRoomParticipant > >::size_type)imarg2;
  (arg1)->reserve(arg2);
}

BOOL _wrap_BMXRTCRoomParticipants_isEmpty(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXRoomParticipant > > *arg1 = (std::vector< std::shared_ptr< floo::BMXRoomParticipant > > *) 0 ;
  BOOL imresult = 0 ;
  bool result;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXRoomParticipant > > *)imarg1;
  result = (bool)((std::vector< std::shared_ptr< floo::BMXRoomParticipant > > const *)arg1)->empty();
  imresult = (result)? YES:NO;
  return imresult;
}

void _wrap_BMXRTCRoomParticipants_clear(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXRoomParticipant > > *arg1 = (std::vector< std::shared_ptr< floo::BMXRoomParticipant > > *) 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXRoomParticipant > > *)imarg1;
  (arg1)->clear();
}

void _wrap_BMXRTCRoomParticipants_add(void* imarg1, void* imarg2) {
  std::vector< std::shared_ptr< floo::BMXRoomParticipant > > *arg1 = (std::vector< std::shared_ptr< floo::BMXRoomParticipant > > *) 0 ;
  std::vector< std::shared_ptr< floo::BMXRoomParticipant > >::value_type *arg2 = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXRoomParticipant > > *)imarg1;
  arg2 = (std::vector< std::shared_ptr< floo::BMXRoomParticipant > >::value_type *)imarg2;
  (arg1)->push_back((std::vector< std::shared_ptr< floo::BMXRoomParticipant > >::value_type const &)*arg2);
}

void* _wrap_BMXRTCRoomParticipants_get(void* imarg1, int imarg2) {
  std::vector< std::shared_ptr< floo::BMXRoomParticipant > > *arg1 = (std::vector< std::shared_ptr< floo::BMXRoomParticipant > > *) 0 ;
  int arg2 ;
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXRoomParticipant > >::value_type *result = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXRoomParticipant > > *)imarg1;
  arg2 = (int)imarg2;
  try {
    result = (std::vector< std::shared_ptr< floo::BMXRoomParticipant > >::value_type *) &std_vector_Sl_std_shared_ptr_Sl_floo_BMXRoomParticipant_Sg__Sg__get(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_ObjcThrowException(SWIG_ObjcIndexOutOfBoundsException, (&_e)->what());
    return 0;
  }
  
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_BMXRTCRoomParticipants_set(void* imarg1, int imarg2, void* imarg3) {
  std::vector< std::shared_ptr< floo::BMXRoomParticipant > > *arg1 = (std::vector< std::shared_ptr< floo::BMXRoomParticipant > > *) 0 ;
  int arg2 ;
  std::vector< std::shared_ptr< floo::BMXRoomParticipant > >::value_type *arg3 = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXRoomParticipant > > *)imarg1;
  arg2 = (int)imarg2;
  arg3 = (std::vector< std::shared_ptr< floo::BMXRoomParticipant > >::value_type *)imarg3;
  try {
    std_vector_Sl_std_shared_ptr_Sl_floo_BMXRoomParticipant_Sg__Sg__set(arg1,arg2,(std::shared_ptr< floo::BMXRoomParticipant > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_ObjcThrowException(SWIG_ObjcIndexOutOfBoundsException, (&_e)->what());
    return ;
  }
  
}

void _wrap_delete_BMXRTCRoomParticipants(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXRoomParticipant > > *arg1 = (std::vector< std::shared_ptr< floo::BMXRoomParticipant > > *) 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXRoomParticipant > > *)imarg1;
  delete arg1;
}

void* _wrap_new_BMXRTCPublishers__SWIG_0() {
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXJanusPublisher > > *result = 0 ;
  
  result = (std::vector< std::shared_ptr< floo::BMXJanusPublisher > > *)new std::vector< std::shared_ptr< floo::BMXJanusPublisher > >();
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void* _wrap_new_BMXRTCPublishers__SWIG_1(unsigned long imarg1) {
  std::vector< std::shared_ptr< floo::BMXJanusPublisher > >::size_type arg1 ;
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXJanusPublisher > > *result = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXJanusPublisher > >::size_type)imarg1;
  result = (std::vector< std::shared_ptr< floo::BMXJanusPublisher > > *)new std::vector< std::shared_ptr< floo::BMXJanusPublisher > >(arg1);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

unsigned long _wrap_BMXRTCPublishers_size(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXJanusPublisher > > *arg1 = (std::vector< std::shared_ptr< floo::BMXJanusPublisher > > *) 0 ;
  unsigned long imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXJanusPublisher > >::size_type result;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXJanusPublisher > > *)imarg1;
  result = ((std::vector< std::shared_ptr< floo::BMXJanusPublisher > > const *)arg1)->size();
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

unsigned long _wrap_BMXRTCPublishers_capacity(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXJanusPublisher > > *arg1 = (std::vector< std::shared_ptr< floo::BMXJanusPublisher > > *) 0 ;
  unsigned long imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXJanusPublisher > >::size_type result;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXJanusPublisher > > *)imarg1;
  result = ((std::vector< std::shared_ptr< floo::BMXJanusPublisher > > const *)arg1)->capacity();
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_BMXRTCPublishers_reserve(void* imarg1, unsigned long imarg2) {
  std::vector< std::shared_ptr< floo::BMXJanusPublisher > > *arg1 = (std::vector< std::shared_ptr< floo::BMXJanusPublisher > > *) 0 ;
  std::vector< std::shared_ptr< floo::BMXJanusPublisher > >::size_type arg2 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXJanusPublisher > > *)imarg1;
  arg2 = (std::vector< std::shared_ptr< floo::BMXJanusPublisher > >::size_type)imarg2;
  (arg1)->reserve(arg2);
}

BOOL _wrap_BMXRTCPublishers_isEmpty(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXJanusPublisher > > *arg1 = (std::vector< std::shared_ptr< floo::BMXJanusPublisher > > *) 0 ;
  BOOL imresult = 0 ;
  bool result;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXJanusPublisher > > *)imarg1;
  result = (bool)((std::vector< std::shared_ptr< floo::BMXJanusPublisher > > const *)arg1)->empty();
  imresult = (result)? YES:NO;
  return imresult;
}

void _wrap_BMXRTCPublishers_clear(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXJanusPublisher > > *arg1 = (std::vector< std::shared_ptr< floo::BMXJanusPublisher > > *) 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXJanusPublisher > > *)imarg1;
  (arg1)->clear();
}

void _wrap_BMXRTCPublishers_add(void* imarg1, void* imarg2) {
  std::vector< std::shared_ptr< floo::BMXJanusPublisher > > *arg1 = (std::vector< std::shared_ptr< floo::BMXJanusPublisher > > *) 0 ;
  std::vector< std::shared_ptr< floo::BMXJanusPublisher > >::value_type *arg2 = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXJanusPublisher > > *)imarg1;
  arg2 = (std::vector< std::shared_ptr< floo::BMXJanusPublisher > >::value_type *)imarg2;
  (arg1)->push_back((std::vector< std::shared_ptr< floo::BMXJanusPublisher > >::value_type const &)*arg2);
}

void* _wrap_BMXRTCPublishers_get(void* imarg1, int imarg2) {
  std::vector< std::shared_ptr< floo::BMXJanusPublisher > > *arg1 = (std::vector< std::shared_ptr< floo::BMXJanusPublisher > > *) 0 ;
  int arg2 ;
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXJanusPublisher > >::value_type *result = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXJanusPublisher > > *)imarg1;
  arg2 = (int)imarg2;
  try {
    result = (std::vector< std::shared_ptr< floo::BMXJanusPublisher > >::value_type *) &std_vector_Sl_std_shared_ptr_Sl_floo_BMXJanusPublisher_Sg__Sg__get(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_ObjcThrowException(SWIG_ObjcIndexOutOfBoundsException, (&_e)->what());
    return 0;
  }
  
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_BMXRTCPublishers_set(void* imarg1, int imarg2, void* imarg3) {
  std::vector< std::shared_ptr< floo::BMXJanusPublisher > > *arg1 = (std::vector< std::shared_ptr< floo::BMXJanusPublisher > > *) 0 ;
  int arg2 ;
  std::vector< std::shared_ptr< floo::BMXJanusPublisher > >::value_type *arg3 = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXJanusPublisher > > *)imarg1;
  arg2 = (int)imarg2;
  arg3 = (std::vector< std::shared_ptr< floo::BMXJanusPublisher > >::value_type *)imarg3;
  try {
    std_vector_Sl_std_shared_ptr_Sl_floo_BMXJanusPublisher_Sg__Sg__set(arg1,arg2,(std::shared_ptr< floo::BMXJanusPublisher > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_ObjcThrowException(SWIG_ObjcIndexOutOfBoundsException, (&_e)->what());
    return ;
  }
  
}

void _wrap_delete_BMXRTCPublishers(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXJanusPublisher > > *arg1 = (std::vector< std::shared_ptr< floo::BMXJanusPublisher > > *) 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXJanusPublisher > > *)imarg1;
  delete arg1;
}

void* _wrap_new_BMXRTCRooms__SWIG_0() {
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXRTCRoom > > *result = 0 ;
  
  result = (std::vector< std::shared_ptr< floo::BMXRTCRoom > > *)new std::vector< std::shared_ptr< floo::BMXRTCRoom > >();
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void* _wrap_new_BMXRTCRooms__SWIG_1(unsigned long imarg1) {
  std::vector< std::shared_ptr< floo::BMXRTCRoom > >::size_type arg1 ;
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXRTCRoom > > *result = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXRTCRoom > >::size_type)imarg1;
  result = (std::vector< std::shared_ptr< floo::BMXRTCRoom > > *)new std::vector< std::shared_ptr< floo::BMXRTCRoom > >(arg1);
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

unsigned long _wrap_BMXRTCRooms_size(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXRTCRoom > > *arg1 = (std::vector< std::shared_ptr< floo::BMXRTCRoom > > *) 0 ;
  unsigned long imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXRTCRoom > >::size_type result;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXRTCRoom > > *)imarg1;
  result = ((std::vector< std::shared_ptr< floo::BMXRTCRoom > > const *)arg1)->size();
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

unsigned long _wrap_BMXRTCRooms_capacity(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXRTCRoom > > *arg1 = (std::vector< std::shared_ptr< floo::BMXRTCRoom > > *) 0 ;
  unsigned long imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXRTCRoom > >::size_type result;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXRTCRoom > > *)imarg1;
  result = ((std::vector< std::shared_ptr< floo::BMXRTCRoom > > const *)arg1)->capacity();
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_BMXRTCRooms_reserve(void* imarg1, unsigned long imarg2) {
  std::vector< std::shared_ptr< floo::BMXRTCRoom > > *arg1 = (std::vector< std::shared_ptr< floo::BMXRTCRoom > > *) 0 ;
  std::vector< std::shared_ptr< floo::BMXRTCRoom > >::size_type arg2 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXRTCRoom > > *)imarg1;
  arg2 = (std::vector< std::shared_ptr< floo::BMXRTCRoom > >::size_type)imarg2;
  (arg1)->reserve(arg2);
}

BOOL _wrap_BMXRTCRooms_isEmpty(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXRTCRoom > > *arg1 = (std::vector< std::shared_ptr< floo::BMXRTCRoom > > *) 0 ;
  BOOL imresult = 0 ;
  bool result;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXRTCRoom > > *)imarg1;
  result = (bool)((std::vector< std::shared_ptr< floo::BMXRTCRoom > > const *)arg1)->empty();
  imresult = (result)? YES:NO;
  return imresult;
}

void _wrap_BMXRTCRooms_clear(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXRTCRoom > > *arg1 = (std::vector< std::shared_ptr< floo::BMXRTCRoom > > *) 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXRTCRoom > > *)imarg1;
  (arg1)->clear();
}

void _wrap_BMXRTCRooms_add(void* imarg1, void* imarg2) {
  std::vector< std::shared_ptr< floo::BMXRTCRoom > > *arg1 = (std::vector< std::shared_ptr< floo::BMXRTCRoom > > *) 0 ;
  std::vector< std::shared_ptr< floo::BMXRTCRoom > >::value_type *arg2 = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXRTCRoom > > *)imarg1;
  arg2 = (std::vector< std::shared_ptr< floo::BMXRTCRoom > >::value_type *)imarg2;
  (arg1)->push_back((std::vector< std::shared_ptr< floo::BMXRTCRoom > >::value_type const &)*arg2);
}

void* _wrap_BMXRTCRooms_get(void* imarg1, int imarg2) {
  std::vector< std::shared_ptr< floo::BMXRTCRoom > > *arg1 = (std::vector< std::shared_ptr< floo::BMXRTCRoom > > *) 0 ;
  int arg2 ;
  void* imresult = 0 ;
  std::vector< std::shared_ptr< floo::BMXRTCRoom > >::value_type *result = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXRTCRoom > > *)imarg1;
  arg2 = (int)imarg2;
  try {
    result = (std::vector< std::shared_ptr< floo::BMXRTCRoom > >::value_type *) &std_vector_Sl_std_shared_ptr_Sl_floo_BMXRTCRoom_Sg__Sg__get(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_ObjcThrowException(SWIG_ObjcIndexOutOfBoundsException, (&_e)->what());
    return 0;
  }
  
  imresult = *(typeof(imresult)*)&result;
  return imresult;
}

void _wrap_BMXRTCRooms_set(void* imarg1, int imarg2, void* imarg3) {
  std::vector< std::shared_ptr< floo::BMXRTCRoom > > *arg1 = (std::vector< std::shared_ptr< floo::BMXRTCRoom > > *) 0 ;
  int arg2 ;
  std::vector< std::shared_ptr< floo::BMXRTCRoom > >::value_type *arg3 = 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXRTCRoom > > *)imarg1;
  arg2 = (int)imarg2;
  arg3 = (std::vector< std::shared_ptr< floo::BMXRTCRoom > >::value_type *)imarg3;
  try {
    std_vector_Sl_std_shared_ptr_Sl_floo_BMXRTCRoom_Sg__Sg__set(arg1,arg2,(std::shared_ptr< floo::BMXRTCRoom > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_ObjcThrowException(SWIG_ObjcIndexOutOfBoundsException, (&_e)->what());
    return ;
  }
  
}

void _wrap_delete_BMXRTCRooms(void* imarg1) {
  std::vector< std::shared_ptr< floo::BMXRTCRoom > > *arg1 = (std::vector< std::shared_ptr< floo::BMXRTCRoom > > *) 0 ;
  
  arg1 = (std::vector< std::shared_ptr< floo::BMXRTCRoom > > *)imarg1;
  delete arg1;
}


#ifdef __cplusplus
}
#endif
